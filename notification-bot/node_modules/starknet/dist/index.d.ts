import * as starknet_types from 'starknet-types';
import { StarknetDomain, StarknetEnumType, StarknetMerkleType, StarknetType, TypedData, TypedDataRevision, StarknetWindowObject, AccountChangeEventHandler, NetworkChangeEventHandler, WatchAssetParameters, AddStarknetChainParameters, StarknetChainId as StarknetChainId$1, AddInvokeTransactionParameters, AddDeclareTransactionParameters, AddDeployAccountTransactionParameters } from 'starknet-types';
export { StarknetDomain, StarknetEnumType, StarknetMerkleType, StarknetType, TypedData, TypedDataRevision } from 'starknet-types';
import * as weierstrass from '@noble/curves/abstract/weierstrass';
import { RecoveredSignatureType } from '@noble/curves/abstract/weierstrass';
import * as ts_mixer_dist_types_types from 'ts-mixer/dist/types/types';
import { Abi as Abi$1, TypedContract } from 'abi-wan-kanabi';
import * as poseidon from '@noble/curves/abstract/poseidon';
import * as json$1 from 'lossless-json';
import * as starknet from '@scure/starknet';

/**
 * PRIMITIVES
 */
/**
 * A field element. represented by at most 63 hex digits
 * @pattern ^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,62})$
 */
type FELT$2 = string;
/**
 * an ethereum address represented as 40 hex digits
 * @pattern ^0x[a-fA-F0-9]{40}$
 */
type ETH_ADDRESS$1 = string;
/**
 * A storage key. Represented as up to 62 hex digits, 3 bits, and 5 leading zeroes.
 * @pattern ^0x0[0-7]{1}[a-fA-F0-9]{0,62}$
 */
type STORAGE_KEY$1 = string;
type ADDRESS$1 = FELT$2;
type NUM_AS_HEX$1 = string;
/**
 * 64 bit integers, represented by hex string of length at most 16
 * "pattern": "^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,15})$"
 */
type u64$1 = string;
/**
 * 64 bit integers, represented by hex string of length at most 32
 * "pattern": "^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,31})$"
 */
type u128$1 = string;
type SIGNATURE$1 = Array<FELT$2>;
type BLOCK_NUMBER$2 = number;
type BLOCK_HASH$2 = FELT$2;
type TXN_HASH$2 = FELT$2;
type CHAIN_ID$1 = NUM_AS_HEX$1;
type STRUCT_ABI_TYPE$1 = 'struct';
type EVENT_ABI_TYPE$1 = 'event';
type FUNCTION_ABI_TYPE$1 = 'function' | 'l1_handler' | 'constructor';
type ENTRY_POINT_TYPE$1 = 'EXTERNAL' | 'L1_HANDLER' | 'CONSTRUCTOR';
type CALL_TYPE$1 = 'DELEGATE' | 'LIBRARY_CALL' | 'CALL';
type TXN_STATUS$1 = 'RECEIVED' | 'REJECTED' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';
type SIMULATION_FLAG$3 = 'SKIP_VALIDATE' | 'SKIP_FEE_CHARGE';
type DA_MODE$1 = 'L1' | 'L2';
type TXN_TYPE$1 = 'DECLARE' | 'DEPLOY' | 'DEPLOY_ACCOUNT' | 'INVOKE' | 'L1_HANDLER';
type TXN_FINALITY_STATUS$1 = 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';
type TXN_EXECUTION_STATUS$1 = 'SUCCEEDED' | 'REVERTED';
type BLOCK_STATUS$1 = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';
type BLOCK_TAG$1 = 'latest' | 'pending';
/**
 * READ API
 */
type EVENTS_CHUNK$1 = {
    events: EMITTED_EVENT$1[];
    continuation_token?: string;
};
type RESULT_PAGE_REQUEST$1 = {
    continuation_token?: string;
    chunk_size: number;
};
type EMITTED_EVENT$1 = EVENT$2 & {
    block_hash: BLOCK_HASH$2;
    block_number: BLOCK_NUMBER$2;
    transaction_hash: TXN_HASH$2;
};
type EVENT$2 = {
    from_address: ADDRESS$1;
} & EVENT_CONTENT$1;
type EVENT_CONTENT$1 = {
    keys: FELT$2[];
    data: FELT$2[];
};
type EVENT_FILTER$1 = {
    from_block?: BLOCK_ID$1;
    to_block?: BLOCK_ID$1;
    address?: ADDRESS$1;
    keys?: FELT$2[][];
};
type BLOCK_ID$1 = {
    block_hash?: BLOCK_HASH$2;
    block_number?: BLOCK_NUMBER$2;
} | BLOCK_TAG$1;
type SYNC_STATUS$1 = {
    starting_block_hash: BLOCK_HASH$2;
    starting_block_num: BLOCK_NUMBER$2;
    current_block_hash: BLOCK_HASH$2;
    current_block_num: BLOCK_NUMBER$2;
    highest_block_hash: BLOCK_HASH$2;
    highest_block_num: BLOCK_NUMBER$2;
};
type NEW_CLASSES$1 = {
    class_hash: FELT$2;
    compiled_class_hash: FELT$2;
};
type REPLACED_CLASS$1 = {
    class_hash: FELT$2;
    contract_address: FELT$2;
};
type NONCE_UPDATE$1 = {
    contract_address: ADDRESS$1;
    nonce: FELT$2;
};
type STATE_DIFF$1 = {
    storage_diffs: CONTRACT_STORAGE_DIFF_ITEM$1[];
    deprecated_declared_classes: FELT$2[];
    declared_classes: NEW_CLASSES$1[];
    deployed_contracts: DEPLOYED_CONTRACT_ITEM$1[];
    replaced_classes: REPLACED_CLASS$1[];
    nonces: NONCE_UPDATE$1[];
};
type PENDING_STATE_UPDATE$2 = {
    old_root: FELT$2;
    state_diff: STATE_DIFF$1;
    block_hash: never;
};
type STATE_UPDATE$2 = {
    block_hash: BLOCK_HASH$2;
    old_root: FELT$2;
    new_root: FELT$2;
    state_diff: STATE_DIFF$1;
};
type BLOCK_BODY_WITH_TX_HASHES$1 = {
    transactions: TXN_HASH$2[];
};
type BLOCK_BODY_WITH_TXS$1 = {
    transactions: (TXN$1 & {
        transaction_hash: TXN_HASH$2;
    })[];
};
type BLOCK_BODY_WITH_RECEIPTS = {
    transactions: {
        transaction: TXN$1;
        receipt: TXN_RECEIPT$1;
    }[];
};
type BLOCK_HEADER$1 = {
    block_hash: BLOCK_HASH$2;
    parent_hash: BLOCK_HASH$2;
    block_number: BLOCK_NUMBER$2;
    new_root: FELT$2;
    timestamp: number;
    sequencer_address: FELT$2;
    l1_gas_price: RESOURCE_PRICE$2;
    l1_data_gas_price: RESOURCE_PRICE$2;
    l1_da_mode: 'BLOB' | 'CALLDATA';
    starknet_version: string;
};
type PENDING_BLOCK_HEADER$1 = {
    parent_hash: BLOCK_HASH$2;
    timestamp: number;
    sequencer_address: FELT$2;
    l1_gas_price: RESOURCE_PRICE$2;
    l1_data_gas_price: RESOURCE_PRICE$2;
    l1_da_mode: 'BLOB' | 'CALLDATA';
    starknet_version: string;
};
type BLOCK_WITH_TX_HASHES$1 = {
    status: BLOCK_STATUS$1;
} & BLOCK_HEADER$1 & BLOCK_BODY_WITH_TX_HASHES$1;
type BLOCK_WITH_TXS$1 = {
    status: BLOCK_STATUS$1;
} & BLOCK_HEADER$1 & BLOCK_BODY_WITH_TXS$1;
type BLOCK_WITH_RECEIPTS = {
    status: BLOCK_STATUS$1;
} & BLOCK_HEADER$1 & BLOCK_BODY_WITH_RECEIPTS;
type PENDING_BLOCK_WITH_TX_HASHES$1 = BLOCK_BODY_WITH_TX_HASHES$1 & PENDING_BLOCK_HEADER$1;
type PENDING_BLOCK_WITH_TXS$1 = BLOCK_BODY_WITH_TXS$1 & PENDING_BLOCK_HEADER$1;
type PENDING_BLOCK_WITH_RECEIPTS = BLOCK_BODY_WITH_RECEIPTS & PENDING_BLOCK_HEADER$1;
type DEPLOYED_CONTRACT_ITEM$1 = {
    address: FELT$2;
    class_hash: FELT$2;
};
type CONTRACT_STORAGE_DIFF_ITEM$1 = {
    address: string;
    storage_entries: StorageDiffItem$1[];
};
type StorageDiffItem$1 = {
    key: string;
    value: string;
};
type TXN$1 = INVOKE_TXN$1 | L1_HANDLER_TXN$1 | DECLARE_TXN$1 | DEPLOY_TXN$1 | DEPLOY_ACCOUNT_TXN$1;
type DECLARE_TXN$1 = DECLARE_TXN_V0$1 | DECLARE_TXN_V1$1 | DECLARE_TXN_V2$1 | DECLARE_TXN_V3$1;
type DECLARE_TXN_V0$1 = {
    type: 'DECLARE';
    sender_address: ADDRESS$1;
    max_fee: FELT$2;
    version: '0x0' | '0x100000000000000000000000000000000';
    signature: SIGNATURE$1;
    class_hash: FELT$2;
};
type DECLARE_TXN_V1$1 = {
    type: 'DECLARE';
    sender_address: ADDRESS$1;
    max_fee: FELT$2;
    version: '0x1' | '0x100000000000000000000000000000001';
    signature: SIGNATURE$1;
    nonce: FELT$2;
    class_hash: FELT$2;
};
type DECLARE_TXN_V2$1 = {
    type: 'DECLARE';
    sender_address: ADDRESS$1;
    compiled_class_hash: FELT$2;
    max_fee: FELT$2;
    version: '0x2' | '0x100000000000000000000000000000002';
    signature: SIGNATURE$1;
    nonce: FELT$2;
    class_hash: FELT$2;
};
type DECLARE_TXN_V3$1 = {
    type: 'DECLARE';
    sender_address: ADDRESS$1;
    compiled_class_hash: FELT$2;
    version: '0x3' | '0x100000000000000000000000000000003';
    signature: SIGNATURE$1;
    nonce: FELT$2;
    class_hash: FELT$2;
    resource_bounds: RESOURCE_BOUNDS_MAPPING$1;
    tip: u64$1;
    paymaster_data: FELT$2[];
    account_deployment_data: FELT$2[];
    nonce_data_availability_mode: DA_MODE$1;
    fee_data_availability_mode: DA_MODE$1;
};
type BROADCASTED_TXN$1 = BROADCASTED_INVOKE_TXN$1 | BROADCASTED_DECLARE_TXN$1 | BROADCASTED_DEPLOY_ACCOUNT_TXN$1;
type BROADCASTED_INVOKE_TXN$1 = INVOKE_TXN$1;
type BROADCASTED_DEPLOY_ACCOUNT_TXN$1 = DEPLOY_ACCOUNT_TXN$1;
type BROADCASTED_DECLARE_TXN$1 = BROADCASTED_DECLARE_TXN_V1$1 | BROADCASTED_DECLARE_TXN_V2$1 | BROADCASTED_DECLARE_TXN_V3$1;
type BROADCASTED_DECLARE_TXN_V1$1 = {
    type: 'DECLARE';
    sender_address: ADDRESS$1;
    max_fee: FELT$2;
    version: '0x1' | '0x100000000000000000000000000000001';
    signature: SIGNATURE$1;
    nonce: FELT$2;
    contract_class: DEPRECATED_CONTRACT_CLASS$1;
};
type BROADCASTED_DECLARE_TXN_V2$1 = {
    type: 'DECLARE';
    sender_address: ADDRESS$1;
    compiled_class_hash: FELT$2;
    max_fee: FELT$2;
    version: '0x2' | '0x100000000000000000000000000000002';
    signature: SIGNATURE$1;
    nonce: FELT$2;
    contract_class: CONTRACT_CLASS$1;
};
type BROADCASTED_DECLARE_TXN_V3$1 = {
    type: 'DECLARE';
    sender_address: ADDRESS$1;
    compiled_class_hash: FELT$2;
    version: '0x3' | '0x100000000000000000000000000000003';
    signature: SIGNATURE$1;
    nonce: FELT$2;
    contract_class: CONTRACT_CLASS$1;
    resource_bounds: RESOURCE_BOUNDS_MAPPING$1;
    tip: u64$1;
    paymaster_data: FELT$2[];
    account_deployment_data: FELT$2[];
    nonce_data_availability_mode: DA_MODE$1;
    fee_data_availability_mode: DA_MODE$1;
};
type DEPLOY_ACCOUNT_TXN$1 = DEPLOY_ACCOUNT_TXN_V1$1 | DEPLOY_ACCOUNT_TXN_V3$1;
type DEPLOY_ACCOUNT_TXN_V1$1 = {
    type: 'DEPLOY_ACCOUNT';
    max_fee: FELT$2;
    version: '0x1' | '0x100000000000000000000000000000001';
    signature: SIGNATURE$1;
    nonce: FELT$2;
    contract_address_salt: FELT$2;
    constructor_calldata: FELT$2[];
    class_hash: FELT$2;
};
type DEPLOY_ACCOUNT_TXN_V3$1 = {
    type: 'DEPLOY_ACCOUNT';
    version: '0x3' | '0x100000000000000000000000000000003';
    signature: SIGNATURE$1;
    nonce: FELT$2;
    contract_address_salt: FELT$2;
    constructor_calldata: FELT$2[];
    class_hash: FELT$2;
    resource_bounds: RESOURCE_BOUNDS_MAPPING$1;
    tip: u64$1;
    paymaster_data: FELT$2[];
    nonce_data_availability_mode: DA_MODE$1;
    fee_data_availability_mode: DA_MODE$1;
};
type DEPLOY_TXN$1 = {
    type: 'DEPLOY';
    version: FELT$2;
    contract_address_salt: FELT$2;
    constructor_calldata: FELT$2[];
    class_hash: FELT$2;
};
type INVOKE_TXN$1 = INVOKE_TXN_V0$1 | INVOKE_TXN_V1$1 | INVOKE_TXN_V3$1;
type INVOKE_TXN_V0$1 = {
    type: 'INVOKE';
    max_fee: FELT$2;
    version: '0x0' | '0x100000000000000000000000000000000';
    signature: SIGNATURE$1;
    contract_address: ADDRESS$1;
    entry_point_selector: FELT$2;
    calldata: FELT$2[];
};
type INVOKE_TXN_V1$1 = {
    type: 'INVOKE';
    sender_address: ADDRESS$1;
    calldata: FELT$2[];
    max_fee: FELT$2;
    version: '0x1' | '0x100000000000000000000000000000001';
    signature: SIGNATURE$1;
    nonce: FELT$2;
};
type INVOKE_TXN_V3$1 = {
    type: 'INVOKE';
    sender_address: ADDRESS$1;
    calldata: FELT$2[];
    version: '0x3' | '0x100000000000000000000000000000003';
    signature: SIGNATURE$1;
    nonce: FELT$2;
    resource_bounds: RESOURCE_BOUNDS_MAPPING$1;
    tip: u64$1;
    paymaster_data: FELT$2[];
    account_deployment_data: FELT$2[];
    nonce_data_availability_mode: DA_MODE$1;
    fee_data_availability_mode: DA_MODE$1;
};
type L1_HANDLER_TXN$1 = {
    version: '0x0';
    type: 'L1_HANDLER';
    nonce: NUM_AS_HEX$1;
} & FUNCTION_CALL$1;
type COMMON_RECEIPT_PROPERTIES$1 = {
    transaction_hash: TXN_HASH$2;
    actual_fee: FEE_PAYMENT$1;
    execution_status: TXN_EXECUTION_STATUS$1;
    finality_status: TXN_FINALITY_STATUS$1;
    messages_sent: MSG_TO_L1$1[];
    revert_reason?: string;
    events: EVENT$2[];
    execution_resources: EXECUTION_RESOURCES$1;
};
type INVOKE_TXN_RECEIPT$2 = {
    type: 'INVOKE';
} & COMMON_RECEIPT_PROPERTIES$1;
type DECLARE_TXN_RECEIPT$2 = {
    type: 'DECLARE';
} & COMMON_RECEIPT_PROPERTIES$1;
type DEPLOY_ACCOUNT_TXN_RECEIPT$2 = {
    type: 'DEPLOY_ACCOUNT';
    contract_address: FELT$2;
} & COMMON_RECEIPT_PROPERTIES$1;
type DEPLOY_TXN_RECEIPT$1 = {
    type: 'DEPLOY';
    contract_address: FELT$2;
} & COMMON_RECEIPT_PROPERTIES$1;
type L1_HANDLER_TXN_RECEIPT$2 = {
    type: 'L1_HANDLER';
    message_hash: NUM_AS_HEX$1;
} & COMMON_RECEIPT_PROPERTIES$1;
type TXN_RECEIPT$1 = INVOKE_TXN_RECEIPT$2 | L1_HANDLER_TXN_RECEIPT$2 | DECLARE_TXN_RECEIPT$2 | DEPLOY_TXN_RECEIPT$1 | DEPLOY_ACCOUNT_TXN_RECEIPT$2;
type TXN_RECEIPT_WITH_BLOCK_INFO = TXN_RECEIPT$1 & {
    block_hash?: BLOCK_HASH$2;
    block_number?: BLOCK_NUMBER$2;
};
type MSG_TO_L1$1 = {
    from_address: FELT$2;
    to_address: FELT$2;
    payload: FELT$2[];
};
type MSG_FROM_L1$1 = {
    from_address: ETH_ADDRESS$1;
    to_address: ADDRESS$1;
    entry_point_selector: FELT$2;
    payload: FELT$2[];
};
type FUNCTION_CALL$1 = {
    contract_address: ADDRESS$1;
    entry_point_selector: FELT$2;
    calldata: FELT$2[];
};
type CONTRACT_CLASS$1 = {
    sierra_program: FELT$2[];
    contract_class_version: string;
    entry_points_by_type: {
        CONSTRUCTOR: SIERRA_ENTRY_POINT$1[];
        EXTERNAL: SIERRA_ENTRY_POINT$1[];
        L1_HANDLER: SIERRA_ENTRY_POINT$1[];
    };
    abi: string;
};
type DEPRECATED_CONTRACT_CLASS$1 = {
    program: string;
    entry_points_by_type: {
        CONSTRUCTOR: DEPRECATED_CAIRO_ENTRY_POINT$1[];
        EXTERNAL: DEPRECATED_CAIRO_ENTRY_POINT$1[];
        L1_HANDLER: DEPRECATED_CAIRO_ENTRY_POINT$1[];
    };
    abi: CONTRACT_ABI$1;
};
type DEPRECATED_CAIRO_ENTRY_POINT$1 = {
    offset: NUM_AS_HEX$1 | number;
    selector: FELT$2;
};
type SIERRA_ENTRY_POINT$1 = {
    selector: FELT$2;
    function_idx: number;
};
type CONTRACT_ABI$1 = readonly CONTRACT_ABI_ENTRY$1[];
type CONTRACT_ABI_ENTRY$1 = {
    selector: FELT$2;
    input: string;
    output: string;
};
type STRUCT_ABI_ENTRY$1 = {
    type: STRUCT_ABI_TYPE$1;
    name: string;
    size: number;
    members: STRUCT_MEMBER$1[];
};
type STRUCT_MEMBER$1 = TYPED_PARAMETER$1 & {
    offset: number;
};
type EVENT_ABI_ENTRY$1 = {
    type: EVENT_ABI_TYPE$1;
    name: string;
    keys: TYPED_PARAMETER$1[];
    data: TYPED_PARAMETER$1[];
};
type FUNCTION_STATE_MUTABILITY$1 = 'view';
type FUNCTION_ABI_ENTRY$1 = {
    type: FUNCTION_ABI_TYPE$1;
    name: string;
    inputs: TYPED_PARAMETER$1[];
    outputs: TYPED_PARAMETER$1[];
    stateMutability: FUNCTION_STATE_MUTABILITY$1;
};
type TYPED_PARAMETER$1 = {
    name: string;
    type: string;
};
type SIMULATION_FLAG_FOR_ESTIMATE_FEE$1 = 'SKIP_VALIDATE';
type PRICE_UNIT$2 = 'WEI' | 'FRI';
type FEE_ESTIMATE$1 = {
    gas_consumed: FELT$2;
    gas_price: FELT$2;
    data_gas_consumed: FELT$2;
    data_gas_price: FELT$2;
    overall_fee: FELT$2;
    unit: PRICE_UNIT$2;
};
type FEE_PAYMENT$1 = {
    amount: FELT$2;
    unit: PRICE_UNIT$2;
};
type RESOURCE_BOUNDS_MAPPING$1 = {
    l1_gas: RESOURCE_BOUNDS$1;
    l2_gas: RESOURCE_BOUNDS$1;
};
type RESOURCE_BOUNDS$1 = {
    max_amount: u64$1;
    max_price_per_unit: u128$1;
};
type RESOURCE_PRICE$2 = {
    price_in_fri: FELT$2;
    price_in_wei: FELT$2;
};
type COMPUTATION_RESOURCES = {
    steps: number;
    memory_holes?: number;
    range_check_builtin_applications?: number;
    pedersen_builtin_applications?: number;
    poseidon_builtin_applications?: number;
    ec_op_builtin_applications?: number;
    ecdsa_builtin_applications?: number;
    bitwise_builtin_applications?: number;
    keccak_builtin_applications?: number;
    segment_arena_builtin?: number;
};
type EXECUTION_RESOURCES$1 = COMPUTATION_RESOURCES & {
    data_availability: {
        l1_gas: number;
        l1_data_gas: number;
    };
};
/**
 * TRACE API
 */
type TRANSACTION_TRACE$1 = {
    invoke_tx_trace?: INVOKE_TXN_TRACE$1;
    declare_tx_trace?: DECLARE_TXN_TRACE$1;
    deploy_account_tx_trace?: DEPLOY_ACCOUNT_TXN_TRACE$1;
    l1_handler_tx_trace?: L1_HANDLER_TXN_TRACE$1;
};
type INVOKE_TXN_TRACE$1 = {
    type: 'INVOKE';
    execute_invocation: FUNCTION_INVOCATION$1 | {
        revert_reason: string;
    };
    validate_invocation?: FUNCTION_INVOCATION$1;
    fee_transfer_invocation?: FUNCTION_INVOCATION$1;
    state_diff?: STATE_DIFF$1;
    execution_resources: EXECUTION_RESOURCES$1;
};
type DECLARE_TXN_TRACE$1 = {
    type: 'DECLARE';
    validate_invocation?: FUNCTION_INVOCATION$1;
    fee_transfer_invocation?: FUNCTION_INVOCATION$1;
    state_diff?: STATE_DIFF$1;
    execution_resources: EXECUTION_RESOURCES$1;
};
type DEPLOY_ACCOUNT_TXN_TRACE$1 = {
    type: 'DEPLOY_ACCOUNT';
    constructor_invocation: FUNCTION_INVOCATION$1;
    validate_invocation?: FUNCTION_INVOCATION$1;
    fee_transfer_invocation?: FUNCTION_INVOCATION$1;
    state_diff?: STATE_DIFF$1;
    execution_resources: EXECUTION_RESOURCES$1;
};
type L1_HANDLER_TXN_TRACE$1 = {
    type: 'L1_HANDLER';
    function_invocation: FUNCTION_INVOCATION$1;
    state_diff?: STATE_DIFF$1;
};
type NESTED_CALL$1 = FUNCTION_INVOCATION$1;
type FUNCTION_INVOCATION$1 = FUNCTION_CALL$1 & {
    caller_address: string;
    class_hash: string;
    entry_point_type: ENTRY_POINT_TYPE$1;
    call_type: CALL_TYPE$1;
    result: string[];
    calls: NESTED_CALL$1[];
    events: ORDERED_EVENT$1[];
    messages: ORDERED_MESSAGE$1[];
    execution_resources: COMPUTATION_RESOURCES;
};
type ORDERED_EVENT$1 = {
    order: number;
    event: EVENT$2;
};
type ORDERED_MESSAGE$1 = {
    order: number;
    message: MSG_TO_L1$1;
};

type components$1_BLOCK_BODY_WITH_RECEIPTS = BLOCK_BODY_WITH_RECEIPTS;
type components$1_BLOCK_WITH_RECEIPTS = BLOCK_WITH_RECEIPTS;
type components$1_COMPUTATION_RESOURCES = COMPUTATION_RESOURCES;
type components$1_PENDING_BLOCK_WITH_RECEIPTS = PENDING_BLOCK_WITH_RECEIPTS;
type components$1_TXN_RECEIPT_WITH_BLOCK_INFO = TXN_RECEIPT_WITH_BLOCK_INFO;
declare namespace components$1 {
  export type { ADDRESS$1 as ADDRESS, components$1_BLOCK_BODY_WITH_RECEIPTS as BLOCK_BODY_WITH_RECEIPTS, BLOCK_BODY_WITH_TXS$1 as BLOCK_BODY_WITH_TXS, BLOCK_BODY_WITH_TX_HASHES$1 as BLOCK_BODY_WITH_TX_HASHES, BLOCK_HASH$2 as BLOCK_HASH, BLOCK_HEADER$1 as BLOCK_HEADER, BLOCK_ID$1 as BLOCK_ID, BLOCK_NUMBER$2 as BLOCK_NUMBER, BLOCK_STATUS$1 as BLOCK_STATUS, BLOCK_TAG$1 as BLOCK_TAG, components$1_BLOCK_WITH_RECEIPTS as BLOCK_WITH_RECEIPTS, BLOCK_WITH_TXS$1 as BLOCK_WITH_TXS, BLOCK_WITH_TX_HASHES$1 as BLOCK_WITH_TX_HASHES, BROADCASTED_DECLARE_TXN$1 as BROADCASTED_DECLARE_TXN, BROADCASTED_DECLARE_TXN_V1$1 as BROADCASTED_DECLARE_TXN_V1, BROADCASTED_DECLARE_TXN_V2$1 as BROADCASTED_DECLARE_TXN_V2, BROADCASTED_DECLARE_TXN_V3$1 as BROADCASTED_DECLARE_TXN_V3, BROADCASTED_DEPLOY_ACCOUNT_TXN$1 as BROADCASTED_DEPLOY_ACCOUNT_TXN, BROADCASTED_INVOKE_TXN$1 as BROADCASTED_INVOKE_TXN, BROADCASTED_TXN$1 as BROADCASTED_TXN, CALL_TYPE$1 as CALL_TYPE, CHAIN_ID$1 as CHAIN_ID, COMMON_RECEIPT_PROPERTIES$1 as COMMON_RECEIPT_PROPERTIES, components$1_COMPUTATION_RESOURCES as COMPUTATION_RESOURCES, CONTRACT_ABI$1 as CONTRACT_ABI, CONTRACT_ABI_ENTRY$1 as CONTRACT_ABI_ENTRY, CONTRACT_CLASS$1 as CONTRACT_CLASS, CONTRACT_STORAGE_DIFF_ITEM$1 as CONTRACT_STORAGE_DIFF_ITEM, DA_MODE$1 as DA_MODE, DECLARE_TXN$1 as DECLARE_TXN, DECLARE_TXN_RECEIPT$2 as DECLARE_TXN_RECEIPT, DECLARE_TXN_TRACE$1 as DECLARE_TXN_TRACE, DECLARE_TXN_V0$1 as DECLARE_TXN_V0, DECLARE_TXN_V1$1 as DECLARE_TXN_V1, DECLARE_TXN_V2$1 as DECLARE_TXN_V2, DECLARE_TXN_V3$1 as DECLARE_TXN_V3, DEPLOYED_CONTRACT_ITEM$1 as DEPLOYED_CONTRACT_ITEM, DEPLOY_ACCOUNT_TXN$1 as DEPLOY_ACCOUNT_TXN, DEPLOY_ACCOUNT_TXN_RECEIPT$2 as DEPLOY_ACCOUNT_TXN_RECEIPT, DEPLOY_ACCOUNT_TXN_TRACE$1 as DEPLOY_ACCOUNT_TXN_TRACE, DEPLOY_ACCOUNT_TXN_V1$1 as DEPLOY_ACCOUNT_TXN_V1, DEPLOY_ACCOUNT_TXN_V3$1 as DEPLOY_ACCOUNT_TXN_V3, DEPLOY_TXN$1 as DEPLOY_TXN, DEPLOY_TXN_RECEIPT$1 as DEPLOY_TXN_RECEIPT, DEPRECATED_CAIRO_ENTRY_POINT$1 as DEPRECATED_CAIRO_ENTRY_POINT, DEPRECATED_CONTRACT_CLASS$1 as DEPRECATED_CONTRACT_CLASS, EMITTED_EVENT$1 as EMITTED_EVENT, ENTRY_POINT_TYPE$1 as ENTRY_POINT_TYPE, ETH_ADDRESS$1 as ETH_ADDRESS, EVENT$2 as EVENT, EVENTS_CHUNK$1 as EVENTS_CHUNK, EVENT_ABI_ENTRY$1 as EVENT_ABI_ENTRY, EVENT_ABI_TYPE$1 as EVENT_ABI_TYPE, EVENT_CONTENT$1 as EVENT_CONTENT, EVENT_FILTER$1 as EVENT_FILTER, EXECUTION_RESOURCES$1 as EXECUTION_RESOURCES, FEE_ESTIMATE$1 as FEE_ESTIMATE, FEE_PAYMENT$1 as FEE_PAYMENT, FELT$2 as FELT, FUNCTION_ABI_ENTRY$1 as FUNCTION_ABI_ENTRY, FUNCTION_ABI_TYPE$1 as FUNCTION_ABI_TYPE, FUNCTION_CALL$1 as FUNCTION_CALL, FUNCTION_INVOCATION$1 as FUNCTION_INVOCATION, FUNCTION_STATE_MUTABILITY$1 as FUNCTION_STATE_MUTABILITY, INVOKE_TXN$1 as INVOKE_TXN, INVOKE_TXN_RECEIPT$2 as INVOKE_TXN_RECEIPT, INVOKE_TXN_TRACE$1 as INVOKE_TXN_TRACE, INVOKE_TXN_V0$1 as INVOKE_TXN_V0, INVOKE_TXN_V1$1 as INVOKE_TXN_V1, INVOKE_TXN_V3$1 as INVOKE_TXN_V3, L1_HANDLER_TXN$1 as L1_HANDLER_TXN, L1_HANDLER_TXN_RECEIPT$2 as L1_HANDLER_TXN_RECEIPT, L1_HANDLER_TXN_TRACE$1 as L1_HANDLER_TXN_TRACE, MSG_FROM_L1$1 as MSG_FROM_L1, MSG_TO_L1$1 as MSG_TO_L1, NESTED_CALL$1 as NESTED_CALL, NEW_CLASSES$1 as NEW_CLASSES, NONCE_UPDATE$1 as NONCE_UPDATE, NUM_AS_HEX$1 as NUM_AS_HEX, ORDERED_EVENT$1 as ORDERED_EVENT, ORDERED_MESSAGE$1 as ORDERED_MESSAGE, PENDING_BLOCK_HEADER$1 as PENDING_BLOCK_HEADER, components$1_PENDING_BLOCK_WITH_RECEIPTS as PENDING_BLOCK_WITH_RECEIPTS, PENDING_BLOCK_WITH_TXS$1 as PENDING_BLOCK_WITH_TXS, PENDING_BLOCK_WITH_TX_HASHES$1 as PENDING_BLOCK_WITH_TX_HASHES, PENDING_STATE_UPDATE$2 as PENDING_STATE_UPDATE, PRICE_UNIT$2 as PRICE_UNIT, REPLACED_CLASS$1 as REPLACED_CLASS, RESOURCE_BOUNDS$1 as RESOURCE_BOUNDS, RESOURCE_BOUNDS_MAPPING$1 as RESOURCE_BOUNDS_MAPPING, RESOURCE_PRICE$2 as RESOURCE_PRICE, RESULT_PAGE_REQUEST$1 as RESULT_PAGE_REQUEST, SIERRA_ENTRY_POINT$1 as SIERRA_ENTRY_POINT, SIGNATURE$1 as SIGNATURE, SIMULATION_FLAG$3 as SIMULATION_FLAG, SIMULATION_FLAG_FOR_ESTIMATE_FEE$1 as SIMULATION_FLAG_FOR_ESTIMATE_FEE, STATE_DIFF$1 as STATE_DIFF, STATE_UPDATE$2 as STATE_UPDATE, STORAGE_KEY$1 as STORAGE_KEY, STRUCT_ABI_ENTRY$1 as STRUCT_ABI_ENTRY, STRUCT_ABI_TYPE$1 as STRUCT_ABI_TYPE, STRUCT_MEMBER$1 as STRUCT_MEMBER, SYNC_STATUS$1 as SYNC_STATUS, StorageDiffItem$1 as StorageDiffItem, TRANSACTION_TRACE$1 as TRANSACTION_TRACE, TXN$1 as TXN, TXN_EXECUTION_STATUS$1 as TXN_EXECUTION_STATUS, TXN_FINALITY_STATUS$1 as TXN_FINALITY_STATUS, TXN_HASH$2 as TXN_HASH, TXN_RECEIPT$1 as TXN_RECEIPT, components$1_TXN_RECEIPT_WITH_BLOCK_INFO as TXN_RECEIPT_WITH_BLOCK_INFO, TXN_STATUS$1 as TXN_STATUS, TXN_TYPE$1 as TXN_TYPE, TYPED_PARAMETER$1 as TYPED_PARAMETER, u128$1 as u128, u64$1 as u64 };
}

type RequestBody = {
    id: number | string;
    jsonrpc: '2.0';
    method: string;
    params?: {};
};
type ResponseBody = {
    id: number | string;
    jsonrpc: '2.0';
} & (SuccessResponseBody | ErrorResponseBody);
type SuccessResponseBody = {
    result: unknown;
};
type ErrorResponseBody = {
    error: Error$1;
};
type Error$1 = {
    code: number;
    message: string;
    data?: unknown;
};

type index$6_ErrorResponseBody = ErrorResponseBody;
type index$6_RequestBody = RequestBody;
type index$6_ResponseBody = ResponseBody;
type index$6_SuccessResponseBody = SuccessResponseBody;
declare namespace index$6 {
  export type { Error$1 as Error, index$6_ErrorResponseBody as ErrorResponseBody, index$6_RequestBody as RequestBody, index$6_ResponseBody as ResponseBody, index$6_SuccessResponseBody as SuccessResponseBody };
}

/**
 * PRIMITIVES
 */
/**
 * A field element. represented by at most 63 hex digits
 * @pattern ^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,62})$
 */
type FELT$1 = string;
/**
 * an ethereum address represented as 40 hex digits
 * @pattern ^0x[a-fA-F0-9]{40}$
 */
type ETH_ADDRESS = string;
/**
 * A storage key. Represented as up to 62 hex digits, 3 bits, and 5 leading zeroes.
 * @pattern ^0x0[0-7]{1}[a-fA-F0-9]{0,62}$
 */
type STORAGE_KEY = string;
type ADDRESS = FELT$1;
type NUM_AS_HEX = string;
/**
 * 64 bit integers, represented by hex string of length at most 16
 * "pattern": "^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,15})$"
 */
type u64 = string;
/**
 * 64 bit integers, represented by hex string of length at most 32
 * "pattern": "^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,31})$"
 */
type u128 = string;
type SIGNATURE = Array<FELT$1>;
type BLOCK_NUMBER$1 = number;
type BLOCK_HASH$1 = FELT$1;
type TXN_HASH$1 = FELT$1;
type CHAIN_ID = NUM_AS_HEX;
type STRUCT_ABI_TYPE = 'struct';
type EVENT_ABI_TYPE = 'event';
type FUNCTION_ABI_TYPE = 'function' | 'l1_handler' | 'constructor';
type ENTRY_POINT_TYPE = 'EXTERNAL' | 'L1_HANDLER' | 'CONSTRUCTOR';
type CALL_TYPE = 'DELEGATE' | 'LIBRARY_CALL' | 'CALL';
type TXN_STATUS = 'RECEIVED' | 'REJECTED' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';
type SIMULATION_FLAG$2 = 'SKIP_VALIDATE' | 'SKIP_FEE_CHARGE';
type DA_MODE = 'L1' | 'L2';
type TXN_TYPE = 'DECLARE' | 'DEPLOY' | 'DEPLOY_ACCOUNT' | 'INVOKE' | 'L1_HANDLER';
type TXN_FINALITY_STATUS = 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';
type TXN_EXECUTION_STATUS = 'SUCCEEDED' | 'REVERTED';
type BLOCK_STATUS = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';
type BLOCK_TAG = 'latest' | 'pending';
/**
 * READ API
 */
type EVENTS_CHUNK = {
    events: EMITTED_EVENT[];
    continuation_token?: string;
};
type RESULT_PAGE_REQUEST = {
    continuation_token?: string;
    chunk_size: number;
};
type EMITTED_EVENT = EVENT$1 & {
    block_hash: BLOCK_HASH$1;
    block_number: BLOCK_NUMBER$1;
    transaction_hash: TXN_HASH$1;
};
type EVENT$1 = {
    from_address: ADDRESS;
} & EVENT_CONTENT;
type EVENT_CONTENT = {
    keys: FELT$1[];
    data: FELT$1[];
};
type EVENT_FILTER = {
    from_block?: BLOCK_ID;
    to_block?: BLOCK_ID;
    address?: ADDRESS;
    keys?: FELT$1[][];
};
type BLOCK_ID = {
    block_hash?: BLOCK_HASH$1;
    block_number?: BLOCK_NUMBER$1;
} | BLOCK_TAG;
type SYNC_STATUS = {
    starting_block_hash: BLOCK_HASH$1;
    starting_block_num: BLOCK_NUMBER$1;
    current_block_hash: BLOCK_HASH$1;
    current_block_num: BLOCK_NUMBER$1;
    highest_block_hash: BLOCK_HASH$1;
    highest_block_num: BLOCK_NUMBER$1;
};
type NEW_CLASSES = {
    class_hash: FELT$1;
    compiled_class_hash: FELT$1;
};
type REPLACED_CLASS = {
    class_hash: FELT$1;
    contract_address: FELT$1;
};
type NONCE_UPDATE = {
    contract_address: ADDRESS;
    nonce: FELT$1;
};
type STATE_DIFF = {
    storage_diffs: CONTRACT_STORAGE_DIFF_ITEM[];
    deprecated_declared_classes: FELT$1[];
    declared_classes: NEW_CLASSES[];
    deployed_contracts: DEPLOYED_CONTRACT_ITEM[];
    replaced_classes: REPLACED_CLASS[];
    nonces: NONCE_UPDATE[];
};
type PENDING_STATE_UPDATE$1 = {
    old_root: FELT$1;
    state_diff: STATE_DIFF;
    block_hash: never;
};
type STATE_UPDATE$1 = {
    block_hash: BLOCK_HASH$1;
    old_root: FELT$1;
    new_root: FELT$1;
    state_diff: STATE_DIFF;
};
type BLOCK_BODY_WITH_TX_HASHES = {
    transactions: TXN_HASH$1[];
};
type BLOCK_BODY_WITH_TXS = {
    transactions: (TXN & {
        transaction_hash: TXN_HASH$1;
    })[];
};
type BLOCK_HEADER = {
    block_hash: BLOCK_HASH$1;
    parent_hash: BLOCK_HASH$1;
    block_number: BLOCK_NUMBER$1;
    new_root: FELT$1;
    timestamp: number;
    sequencer_address: FELT$1;
    l1_gas_price: RESOURCE_PRICE$1;
    starknet_version: string;
};
type PENDING_BLOCK_HEADER = {
    parent_hash: BLOCK_HASH$1;
    timestamp: number;
    sequencer_address: FELT$1;
    l1_gas_price: RESOURCE_PRICE$1;
    starknet_version: string;
};
type BLOCK_WITH_TX_HASHES = {
    status: BLOCK_STATUS;
} & BLOCK_HEADER & BLOCK_BODY_WITH_TX_HASHES;
type BLOCK_WITH_TXS = {
    status: BLOCK_STATUS;
} & BLOCK_HEADER & BLOCK_BODY_WITH_TXS;
type PENDING_BLOCK_WITH_TX_HASHES = BLOCK_BODY_WITH_TX_HASHES & PENDING_BLOCK_HEADER;
type PENDING_BLOCK_WITH_TXS = BLOCK_BODY_WITH_TXS & PENDING_BLOCK_HEADER;
type DEPLOYED_CONTRACT_ITEM = {
    address: FELT$1;
    class_hash: FELT$1;
};
type CONTRACT_STORAGE_DIFF_ITEM = {
    address: string;
    storage_entries: StorageDiffItem[];
};
type StorageDiffItem = {
    key: string;
    value: string;
};
type TXN = INVOKE_TXN | L1_HANDLER_TXN | DECLARE_TXN | DEPLOY_TXN | DEPLOY_ACCOUNT_TXN;
type DECLARE_TXN = DECLARE_TXN_V0 | DECLARE_TXN_V1 | DECLARE_TXN_V2 | DECLARE_TXN_V3;
type DECLARE_TXN_V0 = {
    type: 'DECLARE';
    sender_address: ADDRESS;
    max_fee: FELT$1;
    version: '0x0' | '0x100000000000000000000000000000000';
    signature: SIGNATURE;
    class_hash: FELT$1;
};
type DECLARE_TXN_V1 = {
    type: 'DECLARE';
    sender_address: ADDRESS;
    max_fee: FELT$1;
    version: '0x1' | '0x100000000000000000000000000000001';
    signature: SIGNATURE;
    nonce: FELT$1;
    class_hash: FELT$1;
};
type DECLARE_TXN_V2 = {
    type: 'DECLARE';
    sender_address: ADDRESS;
    compiled_class_hash: FELT$1;
    max_fee: FELT$1;
    version: '0x2' | '0x100000000000000000000000000000002';
    signature: SIGNATURE;
    nonce: FELT$1;
    class_hash: FELT$1;
};
type DECLARE_TXN_V3 = {
    type: 'DECLARE';
    sender_address: ADDRESS;
    compiled_class_hash: FELT$1;
    version: '0x3' | '0x100000000000000000000000000000003';
    signature: SIGNATURE;
    nonce: FELT$1;
    class_hash: FELT$1;
    resource_bounds: RESOURCE_BOUNDS_MAPPING;
    tip: u64;
    paymaster_data: FELT$1[];
    account_deployment_data: FELT$1[];
    nonce_data_availability_mode: DA_MODE;
    fee_data_availability_mode: DA_MODE;
};
type BROADCASTED_TXN = BROADCASTED_INVOKE_TXN | BROADCASTED_DECLARE_TXN | BROADCASTED_DEPLOY_ACCOUNT_TXN;
type BROADCASTED_INVOKE_TXN = INVOKE_TXN;
type BROADCASTED_DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN;
type BROADCASTED_DECLARE_TXN = BROADCASTED_DECLARE_TXN_V1 | BROADCASTED_DECLARE_TXN_V2 | BROADCASTED_DECLARE_TXN_V3;
type BROADCASTED_DECLARE_TXN_V1 = {
    type: 'DECLARE';
    sender_address: ADDRESS;
    max_fee: FELT$1;
    version: '0x1' | '0x100000000000000000000000000000001';
    signature: SIGNATURE;
    nonce: FELT$1;
    contract_class: DEPRECATED_CONTRACT_CLASS;
};
type BROADCASTED_DECLARE_TXN_V2 = {
    type: 'DECLARE';
    sender_address: ADDRESS;
    compiled_class_hash: FELT$1;
    max_fee: FELT$1;
    version: '0x2' | '0x100000000000000000000000000000002';
    signature: SIGNATURE;
    nonce: FELT$1;
    contract_class: CONTRACT_CLASS;
};
type BROADCASTED_DECLARE_TXN_V3 = {
    type: 'DECLARE';
    sender_address: ADDRESS;
    compiled_class_hash: FELT$1;
    version: '0x3' | '0x100000000000000000000000000000003';
    signature: SIGNATURE;
    nonce: FELT$1;
    contract_class: CONTRACT_CLASS;
    resource_bounds: RESOURCE_BOUNDS_MAPPING;
    tip: u64;
    paymaster_data: FELT$1[];
    account_deployment_data: FELT$1[];
    nonce_data_availability_mode: DA_MODE;
    fee_data_availability_mode: DA_MODE;
};
type DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN_V1 | DEPLOY_ACCOUNT_TXN_V3;
type DEPLOY_ACCOUNT_TXN_V1 = {
    type: 'DEPLOY_ACCOUNT';
    max_fee: FELT$1;
    version: '0x1' | '0x100000000000000000000000000000001';
    signature: SIGNATURE;
    nonce: FELT$1;
    contract_address_salt: FELT$1;
    constructor_calldata: FELT$1[];
    class_hash: FELT$1;
};
type DEPLOY_ACCOUNT_TXN_V3 = {
    type: 'DEPLOY_ACCOUNT';
    version: '0x3' | '0x100000000000000000000000000000003';
    signature: SIGNATURE;
    nonce: FELT$1;
    contract_address_salt: FELT$1;
    constructor_calldata: FELT$1[];
    class_hash: FELT$1;
    resource_bounds: RESOURCE_BOUNDS_MAPPING;
    tip: u64;
    paymaster_data: FELT$1[];
    nonce_data_availability_mode: DA_MODE;
    fee_data_availability_mode: DA_MODE;
};
type DEPLOY_TXN = {
    type: 'DEPLOY';
    version: FELT$1;
    contract_address_salt: FELT$1;
    constructor_calldata: FELT$1[];
    class_hash: FELT$1;
};
type INVOKE_TXN = INVOKE_TXN_V0 | INVOKE_TXN_V1 | INVOKE_TXN_V3;
type INVOKE_TXN_V0 = {
    type: 'INVOKE';
    max_fee: FELT$1;
    version: '0x0' | '0x100000000000000000000000000000000';
    signature: SIGNATURE;
    contract_address: ADDRESS;
    entry_point_selector: FELT$1;
    calldata: FELT$1[];
};
type INVOKE_TXN_V1 = {
    type: 'INVOKE';
    sender_address: ADDRESS;
    calldata: FELT$1[];
    max_fee: FELT$1;
    version: '0x1' | '0x100000000000000000000000000000001';
    signature: SIGNATURE;
    nonce: FELT$1;
};
type INVOKE_TXN_V3 = {
    type: 'INVOKE';
    sender_address: ADDRESS;
    calldata: FELT$1[];
    version: '0x3' | '0x100000000000000000000000000000003';
    signature: SIGNATURE;
    nonce: FELT$1;
    resource_bounds: RESOURCE_BOUNDS_MAPPING;
    tip: u64;
    paymaster_data: FELT$1[];
    account_deployment_data: FELT$1[];
    nonce_data_availability_mode: DA_MODE;
    fee_data_availability_mode: DA_MODE;
};
type L1_HANDLER_TXN = {
    version: FELT$1;
    type: 'L1_HANDLER';
    nonce: NUM_AS_HEX;
} & FUNCTION_CALL;
type COMMON_RECEIPT_PROPERTIES = {
    transaction_hash: TXN_HASH$1;
    actual_fee: FEE_PAYMENT;
    execution_status: TXN_EXECUTION_STATUS;
    finality_status: TXN_FINALITY_STATUS;
    block_hash: BLOCK_HASH$1;
    block_number: BLOCK_NUMBER$1;
    messages_sent: MSG_TO_L1[];
    revert_reason?: string;
    events: EVENT$1[];
    execution_resources: EXECUTION_RESOURCES;
};
type PENDING_COMMON_RECEIPT_PROPERTIES = {
    transaction_hash: TXN_HASH$1;
    actual_fee: FEE_PAYMENT;
    messages_sent: MSG_TO_L1[];
    events: EVENT$1[];
    revert_reason?: string;
    finality_status: 'ACCEPTED_ON_L2';
    execution_status: TXN_EXECUTION_STATUS;
    execution_resources: EXECUTION_RESOURCES;
};
type INVOKE_TXN_RECEIPT$1 = {
    type: 'INVOKE';
} & COMMON_RECEIPT_PROPERTIES;
type PENDING_INVOKE_TXN_RECEIPT$1 = {
    type: 'INVOKE';
} & PENDING_COMMON_RECEIPT_PROPERTIES;
type DECLARE_TXN_RECEIPT$1 = {
    type: 'DECLARE';
} & COMMON_RECEIPT_PROPERTIES;
type PENDING_DECLARE_TXN_RECEIPT$1 = {
    type: 'DECLARE';
} & PENDING_COMMON_RECEIPT_PROPERTIES;
type DEPLOY_ACCOUNT_TXN_RECEIPT$1 = {
    type: 'DEPLOY_ACCOUNT';
    contract_address: FELT$1;
} & COMMON_RECEIPT_PROPERTIES;
type PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT$1 = {
    type: 'DEPLOY_ACCOUNT';
    contract_address: FELT$1;
} & PENDING_COMMON_RECEIPT_PROPERTIES;
type DEPLOY_TXN_RECEIPT = {
    type: 'DEPLOY';
    contract_address: FELT$1;
} & COMMON_RECEIPT_PROPERTIES;
type L1_HANDLER_TXN_RECEIPT$1 = {
    type: 'L1_HANDLER';
    message_hash: NUM_AS_HEX;
} & COMMON_RECEIPT_PROPERTIES;
type PENDING_L1_HANDLER_TXN_RECEIPT$1 = {
    type: 'L1_HANDLER';
    message_hash: NUM_AS_HEX;
} & PENDING_COMMON_RECEIPT_PROPERTIES;
type TXN_RECEIPT = INVOKE_TXN_RECEIPT$1 | L1_HANDLER_TXN_RECEIPT$1 | DECLARE_TXN_RECEIPT$1 | DEPLOY_TXN_RECEIPT | DEPLOY_ACCOUNT_TXN_RECEIPT$1;
type PENDING_TXN_RECEIPT = PENDING_INVOKE_TXN_RECEIPT$1 | PENDING_L1_HANDLER_TXN_RECEIPT$1 | PENDING_DECLARE_TXN_RECEIPT$1 | PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT$1;
type MSG_TO_L1 = {
    from_address: FELT$1;
    to_address: FELT$1;
    payload: FELT$1[];
};
type MSG_FROM_L1 = {
    from_address: ETH_ADDRESS;
    to_address: ADDRESS;
    entry_point_selector: FELT$1;
    payload: FELT$1[];
};
type FUNCTION_CALL = {
    contract_address: ADDRESS;
    entry_point_selector: FELT$1;
    calldata: FELT$1[];
};
type CONTRACT_CLASS = {
    sierra_program: FELT$1[];
    contract_class_version: string;
    entry_points_by_type: {
        CONSTRUCTOR: SIERRA_ENTRY_POINT[];
        EXTERNAL: SIERRA_ENTRY_POINT[];
        L1_HANDLER: SIERRA_ENTRY_POINT[];
    };
    abi: string;
};
type DEPRECATED_CONTRACT_CLASS = {
    program: string;
    entry_points_by_type: {
        CONSTRUCTOR: DEPRECATED_CAIRO_ENTRY_POINT[];
        EXTERNAL: DEPRECATED_CAIRO_ENTRY_POINT[];
        L1_HANDLER: DEPRECATED_CAIRO_ENTRY_POINT[];
    };
    abi: CONTRACT_ABI;
};
type DEPRECATED_CAIRO_ENTRY_POINT = {
    offset: NUM_AS_HEX | number;
    selector: FELT$1;
};
type SIERRA_ENTRY_POINT = {
    selector: FELT$1;
    function_idx: number;
};
type CONTRACT_ABI = readonly CONTRACT_ABI_ENTRY[];
type CONTRACT_ABI_ENTRY = {
    selector: FELT$1;
    input: string;
    output: string;
};
type STRUCT_ABI_ENTRY = {
    type: STRUCT_ABI_TYPE;
    name: string;
    size: number;
    members: STRUCT_MEMBER[];
};
type STRUCT_MEMBER = TYPED_PARAMETER & {
    offset: number;
};
type EVENT_ABI_ENTRY = {
    type: EVENT_ABI_TYPE;
    name: string;
    keys: TYPED_PARAMETER[];
    data: TYPED_PARAMETER[];
};
type FUNCTION_STATE_MUTABILITY = 'view';
type FUNCTION_ABI_ENTRY = {
    type: FUNCTION_ABI_TYPE;
    name: string;
    inputs: TYPED_PARAMETER[];
    outputs: TYPED_PARAMETER[];
    stateMutability: FUNCTION_STATE_MUTABILITY;
};
type TYPED_PARAMETER = {
    name: string;
    type: string;
};
type SIMULATION_FLAG_FOR_ESTIMATE_FEE = 'SKIP_VALIDATE';
type PRICE_UNIT$1 = 'WEI' | 'FRI';
type FEE_ESTIMATE = {
    gas_consumed: FELT$1;
    gas_price: FELT$1;
    overall_fee: FELT$1;
    unit: PRICE_UNIT$1;
};
type FEE_PAYMENT = {
    amount: FELT$1;
    unit: PRICE_UNIT$1;
};
type RESOURCE_BOUNDS_MAPPING = {
    l1_gas: RESOURCE_BOUNDS;
    l2_gas: RESOURCE_BOUNDS;
};
type RESOURCE_BOUNDS = {
    max_amount: u64;
    max_price_per_unit: u128;
};
type RESOURCE_PRICE$1 = {
    price_in_fri: FELT$1;
    price_in_wei: FELT$1;
};
type EXECUTION_RESOURCES = {
    steps: number;
    memory_holes?: number;
    range_check_builtin_applications?: number;
    pedersen_builtin_applications?: number;
    poseidon_builtin_applications?: number;
    ec_op_builtin_applications?: number;
    ecdsa_builtin_applications?: number;
    bitwise_builtin_applications?: number;
    keccak_builtin_applications?: number;
    segment_arena_builtin?: number;
};
/**
 * TRACE API
 */
type TRANSACTION_TRACE = {
    invoke_tx_trace?: INVOKE_TXN_TRACE;
    declare_tx_trace?: DECLARE_TXN_TRACE;
    deploy_account_tx_trace?: DEPLOY_ACCOUNT_TXN_TRACE;
    l1_handler_tx_trace?: L1_HANDLER_TXN_TRACE;
};
type INVOKE_TXN_TRACE = {
    type: 'INVOKE';
    execute_invocation: FUNCTION_INVOCATION | {
        revert_reason: string;
    };
    validate_invocation?: FUNCTION_INVOCATION;
    fee_transfer_invocation?: FUNCTION_INVOCATION;
    state_diff?: STATE_DIFF;
};
type DECLARE_TXN_TRACE = {
    type: 'DECLARE';
    validate_invocation?: FUNCTION_INVOCATION;
    fee_transfer_invocation?: FUNCTION_INVOCATION;
    state_diff?: STATE_DIFF;
};
type DEPLOY_ACCOUNT_TXN_TRACE = {
    type: 'DEPLOY_ACCOUNT';
    constructor_invocation: FUNCTION_INVOCATION;
    validate_invocation?: FUNCTION_INVOCATION;
    fee_transfer_invocation?: FUNCTION_INVOCATION;
    state_diff?: STATE_DIFF;
};
type L1_HANDLER_TXN_TRACE = {
    type: 'L1_HANDLER';
    function_invocation: FUNCTION_INVOCATION;
    state_diff?: STATE_DIFF;
};
type NESTED_CALL = FUNCTION_INVOCATION;
type FUNCTION_INVOCATION = FUNCTION_CALL & {
    caller_address: string;
    class_hash: string;
    entry_point_type: ENTRY_POINT_TYPE;
    call_type: CALL_TYPE;
    result: string[];
    calls: NESTED_CALL[];
    events: ORDERED_EVENT[];
    messages: ORDERED_MESSAGE[];
    execution_resources: EXECUTION_RESOURCES;
};
type ORDERED_EVENT = {
    order: number;
    event: EVENT$1;
};
type ORDERED_MESSAGE = {
    order: number;
    message: MSG_TO_L1;
};

type components_ADDRESS = ADDRESS;
type components_BLOCK_BODY_WITH_TXS = BLOCK_BODY_WITH_TXS;
type components_BLOCK_BODY_WITH_TX_HASHES = BLOCK_BODY_WITH_TX_HASHES;
type components_BLOCK_HEADER = BLOCK_HEADER;
type components_BLOCK_ID = BLOCK_ID;
type components_BLOCK_STATUS = BLOCK_STATUS;
type components_BLOCK_TAG = BLOCK_TAG;
type components_BLOCK_WITH_TXS = BLOCK_WITH_TXS;
type components_BLOCK_WITH_TX_HASHES = BLOCK_WITH_TX_HASHES;
type components_BROADCASTED_DECLARE_TXN = BROADCASTED_DECLARE_TXN;
type components_BROADCASTED_DECLARE_TXN_V1 = BROADCASTED_DECLARE_TXN_V1;
type components_BROADCASTED_DECLARE_TXN_V2 = BROADCASTED_DECLARE_TXN_V2;
type components_BROADCASTED_DECLARE_TXN_V3 = BROADCASTED_DECLARE_TXN_V3;
type components_BROADCASTED_DEPLOY_ACCOUNT_TXN = BROADCASTED_DEPLOY_ACCOUNT_TXN;
type components_BROADCASTED_INVOKE_TXN = BROADCASTED_INVOKE_TXN;
type components_BROADCASTED_TXN = BROADCASTED_TXN;
type components_CALL_TYPE = CALL_TYPE;
type components_CHAIN_ID = CHAIN_ID;
type components_COMMON_RECEIPT_PROPERTIES = COMMON_RECEIPT_PROPERTIES;
type components_CONTRACT_ABI = CONTRACT_ABI;
type components_CONTRACT_ABI_ENTRY = CONTRACT_ABI_ENTRY;
type components_CONTRACT_CLASS = CONTRACT_CLASS;
type components_CONTRACT_STORAGE_DIFF_ITEM = CONTRACT_STORAGE_DIFF_ITEM;
type components_DA_MODE = DA_MODE;
type components_DECLARE_TXN = DECLARE_TXN;
type components_DECLARE_TXN_TRACE = DECLARE_TXN_TRACE;
type components_DECLARE_TXN_V0 = DECLARE_TXN_V0;
type components_DECLARE_TXN_V1 = DECLARE_TXN_V1;
type components_DECLARE_TXN_V2 = DECLARE_TXN_V2;
type components_DECLARE_TXN_V3 = DECLARE_TXN_V3;
type components_DEPLOYED_CONTRACT_ITEM = DEPLOYED_CONTRACT_ITEM;
type components_DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN;
type components_DEPLOY_ACCOUNT_TXN_TRACE = DEPLOY_ACCOUNT_TXN_TRACE;
type components_DEPLOY_ACCOUNT_TXN_V1 = DEPLOY_ACCOUNT_TXN_V1;
type components_DEPLOY_ACCOUNT_TXN_V3 = DEPLOY_ACCOUNT_TXN_V3;
type components_DEPLOY_TXN = DEPLOY_TXN;
type components_DEPLOY_TXN_RECEIPT = DEPLOY_TXN_RECEIPT;
type components_DEPRECATED_CAIRO_ENTRY_POINT = DEPRECATED_CAIRO_ENTRY_POINT;
type components_DEPRECATED_CONTRACT_CLASS = DEPRECATED_CONTRACT_CLASS;
type components_EMITTED_EVENT = EMITTED_EVENT;
type components_ENTRY_POINT_TYPE = ENTRY_POINT_TYPE;
type components_ETH_ADDRESS = ETH_ADDRESS;
type components_EVENTS_CHUNK = EVENTS_CHUNK;
type components_EVENT_ABI_ENTRY = EVENT_ABI_ENTRY;
type components_EVENT_ABI_TYPE = EVENT_ABI_TYPE;
type components_EVENT_CONTENT = EVENT_CONTENT;
type components_EVENT_FILTER = EVENT_FILTER;
type components_EXECUTION_RESOURCES = EXECUTION_RESOURCES;
type components_FEE_ESTIMATE = FEE_ESTIMATE;
type components_FEE_PAYMENT = FEE_PAYMENT;
type components_FUNCTION_ABI_ENTRY = FUNCTION_ABI_ENTRY;
type components_FUNCTION_ABI_TYPE = FUNCTION_ABI_TYPE;
type components_FUNCTION_CALL = FUNCTION_CALL;
type components_FUNCTION_INVOCATION = FUNCTION_INVOCATION;
type components_FUNCTION_STATE_MUTABILITY = FUNCTION_STATE_MUTABILITY;
type components_INVOKE_TXN = INVOKE_TXN;
type components_INVOKE_TXN_TRACE = INVOKE_TXN_TRACE;
type components_INVOKE_TXN_V0 = INVOKE_TXN_V0;
type components_INVOKE_TXN_V1 = INVOKE_TXN_V1;
type components_INVOKE_TXN_V3 = INVOKE_TXN_V3;
type components_L1_HANDLER_TXN = L1_HANDLER_TXN;
type components_L1_HANDLER_TXN_TRACE = L1_HANDLER_TXN_TRACE;
type components_MSG_FROM_L1 = MSG_FROM_L1;
type components_MSG_TO_L1 = MSG_TO_L1;
type components_NESTED_CALL = NESTED_CALL;
type components_NEW_CLASSES = NEW_CLASSES;
type components_NONCE_UPDATE = NONCE_UPDATE;
type components_NUM_AS_HEX = NUM_AS_HEX;
type components_ORDERED_EVENT = ORDERED_EVENT;
type components_ORDERED_MESSAGE = ORDERED_MESSAGE;
type components_PENDING_BLOCK_HEADER = PENDING_BLOCK_HEADER;
type components_PENDING_BLOCK_WITH_TXS = PENDING_BLOCK_WITH_TXS;
type components_PENDING_BLOCK_WITH_TX_HASHES = PENDING_BLOCK_WITH_TX_HASHES;
type components_PENDING_COMMON_RECEIPT_PROPERTIES = PENDING_COMMON_RECEIPT_PROPERTIES;
type components_PENDING_TXN_RECEIPT = PENDING_TXN_RECEIPT;
type components_REPLACED_CLASS = REPLACED_CLASS;
type components_RESOURCE_BOUNDS = RESOURCE_BOUNDS;
type components_RESOURCE_BOUNDS_MAPPING = RESOURCE_BOUNDS_MAPPING;
type components_RESULT_PAGE_REQUEST = RESULT_PAGE_REQUEST;
type components_SIERRA_ENTRY_POINT = SIERRA_ENTRY_POINT;
type components_SIGNATURE = SIGNATURE;
type components_SIMULATION_FLAG_FOR_ESTIMATE_FEE = SIMULATION_FLAG_FOR_ESTIMATE_FEE;
type components_STATE_DIFF = STATE_DIFF;
type components_STORAGE_KEY = STORAGE_KEY;
type components_STRUCT_ABI_ENTRY = STRUCT_ABI_ENTRY;
type components_STRUCT_ABI_TYPE = STRUCT_ABI_TYPE;
type components_STRUCT_MEMBER = STRUCT_MEMBER;
type components_SYNC_STATUS = SYNC_STATUS;
type components_StorageDiffItem = StorageDiffItem;
type components_TRANSACTION_TRACE = TRANSACTION_TRACE;
type components_TXN = TXN;
type components_TXN_EXECUTION_STATUS = TXN_EXECUTION_STATUS;
type components_TXN_FINALITY_STATUS = TXN_FINALITY_STATUS;
type components_TXN_RECEIPT = TXN_RECEIPT;
type components_TXN_STATUS = TXN_STATUS;
type components_TXN_TYPE = TXN_TYPE;
type components_TYPED_PARAMETER = TYPED_PARAMETER;
type components_u128 = u128;
type components_u64 = u64;
declare namespace components {
  export type { components_ADDRESS as ADDRESS, components_BLOCK_BODY_WITH_TXS as BLOCK_BODY_WITH_TXS, components_BLOCK_BODY_WITH_TX_HASHES as BLOCK_BODY_WITH_TX_HASHES, BLOCK_HASH$1 as BLOCK_HASH, components_BLOCK_HEADER as BLOCK_HEADER, components_BLOCK_ID as BLOCK_ID, BLOCK_NUMBER$1 as BLOCK_NUMBER, components_BLOCK_STATUS as BLOCK_STATUS, components_BLOCK_TAG as BLOCK_TAG, components_BLOCK_WITH_TXS as BLOCK_WITH_TXS, components_BLOCK_WITH_TX_HASHES as BLOCK_WITH_TX_HASHES, components_BROADCASTED_DECLARE_TXN as BROADCASTED_DECLARE_TXN, components_BROADCASTED_DECLARE_TXN_V1 as BROADCASTED_DECLARE_TXN_V1, components_BROADCASTED_DECLARE_TXN_V2 as BROADCASTED_DECLARE_TXN_V2, components_BROADCASTED_DECLARE_TXN_V3 as BROADCASTED_DECLARE_TXN_V3, components_BROADCASTED_DEPLOY_ACCOUNT_TXN as BROADCASTED_DEPLOY_ACCOUNT_TXN, components_BROADCASTED_INVOKE_TXN as BROADCASTED_INVOKE_TXN, components_BROADCASTED_TXN as BROADCASTED_TXN, components_CALL_TYPE as CALL_TYPE, components_CHAIN_ID as CHAIN_ID, components_COMMON_RECEIPT_PROPERTIES as COMMON_RECEIPT_PROPERTIES, components_CONTRACT_ABI as CONTRACT_ABI, components_CONTRACT_ABI_ENTRY as CONTRACT_ABI_ENTRY, components_CONTRACT_CLASS as CONTRACT_CLASS, components_CONTRACT_STORAGE_DIFF_ITEM as CONTRACT_STORAGE_DIFF_ITEM, components_DA_MODE as DA_MODE, components_DECLARE_TXN as DECLARE_TXN, DECLARE_TXN_RECEIPT$1 as DECLARE_TXN_RECEIPT, components_DECLARE_TXN_TRACE as DECLARE_TXN_TRACE, components_DECLARE_TXN_V0 as DECLARE_TXN_V0, components_DECLARE_TXN_V1 as DECLARE_TXN_V1, components_DECLARE_TXN_V2 as DECLARE_TXN_V2, components_DECLARE_TXN_V3 as DECLARE_TXN_V3, components_DEPLOYED_CONTRACT_ITEM as DEPLOYED_CONTRACT_ITEM, components_DEPLOY_ACCOUNT_TXN as DEPLOY_ACCOUNT_TXN, DEPLOY_ACCOUNT_TXN_RECEIPT$1 as DEPLOY_ACCOUNT_TXN_RECEIPT, components_DEPLOY_ACCOUNT_TXN_TRACE as DEPLOY_ACCOUNT_TXN_TRACE, components_DEPLOY_ACCOUNT_TXN_V1 as DEPLOY_ACCOUNT_TXN_V1, components_DEPLOY_ACCOUNT_TXN_V3 as DEPLOY_ACCOUNT_TXN_V3, components_DEPLOY_TXN as DEPLOY_TXN, components_DEPLOY_TXN_RECEIPT as DEPLOY_TXN_RECEIPT, components_DEPRECATED_CAIRO_ENTRY_POINT as DEPRECATED_CAIRO_ENTRY_POINT, components_DEPRECATED_CONTRACT_CLASS as DEPRECATED_CONTRACT_CLASS, components_EMITTED_EVENT as EMITTED_EVENT, components_ENTRY_POINT_TYPE as ENTRY_POINT_TYPE, components_ETH_ADDRESS as ETH_ADDRESS, EVENT$1 as EVENT, components_EVENTS_CHUNK as EVENTS_CHUNK, components_EVENT_ABI_ENTRY as EVENT_ABI_ENTRY, components_EVENT_ABI_TYPE as EVENT_ABI_TYPE, components_EVENT_CONTENT as EVENT_CONTENT, components_EVENT_FILTER as EVENT_FILTER, components_EXECUTION_RESOURCES as EXECUTION_RESOURCES, components_FEE_ESTIMATE as FEE_ESTIMATE, components_FEE_PAYMENT as FEE_PAYMENT, FELT$1 as FELT, components_FUNCTION_ABI_ENTRY as FUNCTION_ABI_ENTRY, components_FUNCTION_ABI_TYPE as FUNCTION_ABI_TYPE, components_FUNCTION_CALL as FUNCTION_CALL, components_FUNCTION_INVOCATION as FUNCTION_INVOCATION, components_FUNCTION_STATE_MUTABILITY as FUNCTION_STATE_MUTABILITY, components_INVOKE_TXN as INVOKE_TXN, INVOKE_TXN_RECEIPT$1 as INVOKE_TXN_RECEIPT, components_INVOKE_TXN_TRACE as INVOKE_TXN_TRACE, components_INVOKE_TXN_V0 as INVOKE_TXN_V0, components_INVOKE_TXN_V1 as INVOKE_TXN_V1, components_INVOKE_TXN_V3 as INVOKE_TXN_V3, components_L1_HANDLER_TXN as L1_HANDLER_TXN, L1_HANDLER_TXN_RECEIPT$1 as L1_HANDLER_TXN_RECEIPT, components_L1_HANDLER_TXN_TRACE as L1_HANDLER_TXN_TRACE, components_MSG_FROM_L1 as MSG_FROM_L1, components_MSG_TO_L1 as MSG_TO_L1, components_NESTED_CALL as NESTED_CALL, components_NEW_CLASSES as NEW_CLASSES, components_NONCE_UPDATE as NONCE_UPDATE, components_NUM_AS_HEX as NUM_AS_HEX, components_ORDERED_EVENT as ORDERED_EVENT, components_ORDERED_MESSAGE as ORDERED_MESSAGE, components_PENDING_BLOCK_HEADER as PENDING_BLOCK_HEADER, components_PENDING_BLOCK_WITH_TXS as PENDING_BLOCK_WITH_TXS, components_PENDING_BLOCK_WITH_TX_HASHES as PENDING_BLOCK_WITH_TX_HASHES, components_PENDING_COMMON_RECEIPT_PROPERTIES as PENDING_COMMON_RECEIPT_PROPERTIES, PENDING_DECLARE_TXN_RECEIPT$1 as PENDING_DECLARE_TXN_RECEIPT, PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT$1 as PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT, PENDING_INVOKE_TXN_RECEIPT$1 as PENDING_INVOKE_TXN_RECEIPT, PENDING_L1_HANDLER_TXN_RECEIPT$1 as PENDING_L1_HANDLER_TXN_RECEIPT, PENDING_STATE_UPDATE$1 as PENDING_STATE_UPDATE, components_PENDING_TXN_RECEIPT as PENDING_TXN_RECEIPT, PRICE_UNIT$1 as PRICE_UNIT, components_REPLACED_CLASS as REPLACED_CLASS, components_RESOURCE_BOUNDS as RESOURCE_BOUNDS, components_RESOURCE_BOUNDS_MAPPING as RESOURCE_BOUNDS_MAPPING, RESOURCE_PRICE$1 as RESOURCE_PRICE, components_RESULT_PAGE_REQUEST as RESULT_PAGE_REQUEST, components_SIERRA_ENTRY_POINT as SIERRA_ENTRY_POINT, components_SIGNATURE as SIGNATURE, SIMULATION_FLAG$2 as SIMULATION_FLAG, components_SIMULATION_FLAG_FOR_ESTIMATE_FEE as SIMULATION_FLAG_FOR_ESTIMATE_FEE, components_STATE_DIFF as STATE_DIFF, STATE_UPDATE$1 as STATE_UPDATE, components_STORAGE_KEY as STORAGE_KEY, components_STRUCT_ABI_ENTRY as STRUCT_ABI_ENTRY, components_STRUCT_ABI_TYPE as STRUCT_ABI_TYPE, components_STRUCT_MEMBER as STRUCT_MEMBER, components_SYNC_STATUS as SYNC_STATUS, components_StorageDiffItem as StorageDiffItem, components_TRANSACTION_TRACE as TRANSACTION_TRACE, components_TXN as TXN, components_TXN_EXECUTION_STATUS as TXN_EXECUTION_STATUS, components_TXN_FINALITY_STATUS as TXN_FINALITY_STATUS, TXN_HASH$1 as TXN_HASH, components_TXN_RECEIPT as TXN_RECEIPT, components_TXN_STATUS as TXN_STATUS, components_TXN_TYPE as TXN_TYPE, components_TYPED_PARAMETER as TYPED_PARAMETER, components_u128 as u128, components_u64 as u64 };
}

interface FAILED_TO_RECEIVE_TXN {
    code: 1;
    message: 'Failed to write transaction';
}
interface NO_TRACE_AVAILABLE {
    code: 10;
    message: 'No trace available for transaction';
    data: {
        status: 'RECEIVED' | 'REJECTED';
    };
}
interface CONTRACT_NOT_FOUND {
    code: 20;
    message: 'Contract not found';
}
interface INVALID_MESSAGE_SELECTOR {
    code: 21;
    message: 'Invalid message selector';
}
interface INVALID_CALL_DATA {
    code: 22;
    message: 'Invalid call data';
}
interface BLOCK_NOT_FOUND {
    code: 24;
    message: 'Block not found';
}
interface INVALID_BLOCK_HASH {
    code: 26;
    message: 'Invalid block hash';
}
interface INVALID_TXN_INDEX {
    code: 27;
    message: 'Invalid transaction index in a block';
}
interface CLASS_HASH_NOT_FOUND {
    code: 28;
    message: 'Class hash not found';
}
interface TXN_HASH_NOT_FOUND {
    code: 29;
    message: 'Transaction hash not found';
}
interface PAGE_SIZE_TOO_BIG {
    code: 31;
    message: 'Requested page size is too big';
}
interface NO_BLOCKS {
    code: 32;
    message: 'There are no blocks';
}
interface INVALID_CONTINUATION_TOKEN {
    code: 33;
    message: 'The supplied continuation token is invalid or unknown';
}
interface TOO_MANY_KEYS_IN_FILTER {
    code: 34;
    message: 'Too many keys provided in a filter';
}
interface CONTRACT_ERROR {
    code: 40;
    message: 'Contract error';
    data: {
        revert_error: string;
    };
}
interface TRANSACTION_EXECUTION_ERROR {
    code: 41;
    message: 'Transaction execution error';
    data: {
        transaction_index: number;
        execution_error: string;
    };
}
interface CLASS_ALREADY_DECLARED {
    code: 51;
    message: 'Class already declared';
}
interface INVALID_TRANSACTION_NONCE {
    code: 52;
    message: 'Invalid transaction nonce';
}
interface INSUFFICIENT_MAX_FEE {
    code: 53;
    message: 'Max fee is smaller than the minimal transaction cost (validation plus fee transfer)';
}
interface INSUFFICIENT_ACCOUNT_BALANCE {
    code: 54;
    message: "Account balance is smaller than the transaction's max_fee";
}
interface VALIDATION_FAILURE {
    code: 55;
    message: 'Account validation failed';
    data: string;
}
interface COMPILATION_FAILED {
    code: 56;
    message: 'Compilation failed';
}
interface CONTRACT_CLASS_SIZE_IS_TOO_LARGE {
    code: 57;
    message: 'Contract class size it too large';
}
interface NON_ACCOUNT {
    code: 58;
    message: 'Sender address in not an account contract';
}
interface DUPLICATE_TX {
    code: 59;
    message: 'A transaction with the same hash already exists in the mempool';
}
interface COMPILED_CLASS_HASH_MISMATCH {
    code: 60;
    message: 'the compiled class hash did not match the one supplied in the transaction';
}
interface UNSUPPORTED_TX_VERSION {
    code: 61;
    message: 'the transaction version is not supported';
}
interface UNSUPPORTED_CONTRACT_CLASS_VERSION {
    code: 62;
    message: 'the contract class version is not supported';
}
interface UNEXPECTED_ERROR {
    code: 63;
    message: 'An unexpected error occurred';
    data: string;
}

type errors$1_BLOCK_NOT_FOUND = BLOCK_NOT_FOUND;
type errors$1_CLASS_ALREADY_DECLARED = CLASS_ALREADY_DECLARED;
type errors$1_CLASS_HASH_NOT_FOUND = CLASS_HASH_NOT_FOUND;
type errors$1_COMPILATION_FAILED = COMPILATION_FAILED;
type errors$1_COMPILED_CLASS_HASH_MISMATCH = COMPILED_CLASS_HASH_MISMATCH;
type errors$1_CONTRACT_CLASS_SIZE_IS_TOO_LARGE = CONTRACT_CLASS_SIZE_IS_TOO_LARGE;
type errors$1_CONTRACT_ERROR = CONTRACT_ERROR;
type errors$1_CONTRACT_NOT_FOUND = CONTRACT_NOT_FOUND;
type errors$1_DUPLICATE_TX = DUPLICATE_TX;
type errors$1_FAILED_TO_RECEIVE_TXN = FAILED_TO_RECEIVE_TXN;
type errors$1_INSUFFICIENT_ACCOUNT_BALANCE = INSUFFICIENT_ACCOUNT_BALANCE;
type errors$1_INSUFFICIENT_MAX_FEE = INSUFFICIENT_MAX_FEE;
type errors$1_INVALID_BLOCK_HASH = INVALID_BLOCK_HASH;
type errors$1_INVALID_CALL_DATA = INVALID_CALL_DATA;
type errors$1_INVALID_CONTINUATION_TOKEN = INVALID_CONTINUATION_TOKEN;
type errors$1_INVALID_MESSAGE_SELECTOR = INVALID_MESSAGE_SELECTOR;
type errors$1_INVALID_TRANSACTION_NONCE = INVALID_TRANSACTION_NONCE;
type errors$1_INVALID_TXN_INDEX = INVALID_TXN_INDEX;
type errors$1_NON_ACCOUNT = NON_ACCOUNT;
type errors$1_NO_BLOCKS = NO_BLOCKS;
type errors$1_NO_TRACE_AVAILABLE = NO_TRACE_AVAILABLE;
type errors$1_PAGE_SIZE_TOO_BIG = PAGE_SIZE_TOO_BIG;
type errors$1_TOO_MANY_KEYS_IN_FILTER = TOO_MANY_KEYS_IN_FILTER;
type errors$1_TRANSACTION_EXECUTION_ERROR = TRANSACTION_EXECUTION_ERROR;
type errors$1_TXN_HASH_NOT_FOUND = TXN_HASH_NOT_FOUND;
type errors$1_UNEXPECTED_ERROR = UNEXPECTED_ERROR;
type errors$1_UNSUPPORTED_CONTRACT_CLASS_VERSION = UNSUPPORTED_CONTRACT_CLASS_VERSION;
type errors$1_UNSUPPORTED_TX_VERSION = UNSUPPORTED_TX_VERSION;
type errors$1_VALIDATION_FAILURE = VALIDATION_FAILURE;
declare namespace errors$1 {
  export type { errors$1_BLOCK_NOT_FOUND as BLOCK_NOT_FOUND, errors$1_CLASS_ALREADY_DECLARED as CLASS_ALREADY_DECLARED, errors$1_CLASS_HASH_NOT_FOUND as CLASS_HASH_NOT_FOUND, errors$1_COMPILATION_FAILED as COMPILATION_FAILED, errors$1_COMPILED_CLASS_HASH_MISMATCH as COMPILED_CLASS_HASH_MISMATCH, errors$1_CONTRACT_CLASS_SIZE_IS_TOO_LARGE as CONTRACT_CLASS_SIZE_IS_TOO_LARGE, errors$1_CONTRACT_ERROR as CONTRACT_ERROR, errors$1_CONTRACT_NOT_FOUND as CONTRACT_NOT_FOUND, errors$1_DUPLICATE_TX as DUPLICATE_TX, errors$1_FAILED_TO_RECEIVE_TXN as FAILED_TO_RECEIVE_TXN, errors$1_INSUFFICIENT_ACCOUNT_BALANCE as INSUFFICIENT_ACCOUNT_BALANCE, errors$1_INSUFFICIENT_MAX_FEE as INSUFFICIENT_MAX_FEE, errors$1_INVALID_BLOCK_HASH as INVALID_BLOCK_HASH, errors$1_INVALID_CALL_DATA as INVALID_CALL_DATA, errors$1_INVALID_CONTINUATION_TOKEN as INVALID_CONTINUATION_TOKEN, errors$1_INVALID_MESSAGE_SELECTOR as INVALID_MESSAGE_SELECTOR, errors$1_INVALID_TRANSACTION_NONCE as INVALID_TRANSACTION_NONCE, errors$1_INVALID_TXN_INDEX as INVALID_TXN_INDEX, errors$1_NON_ACCOUNT as NON_ACCOUNT, errors$1_NO_BLOCKS as NO_BLOCKS, errors$1_NO_TRACE_AVAILABLE as NO_TRACE_AVAILABLE, errors$1_PAGE_SIZE_TOO_BIG as PAGE_SIZE_TOO_BIG, errors$1_TOO_MANY_KEYS_IN_FILTER as TOO_MANY_KEYS_IN_FILTER, errors$1_TRANSACTION_EXECUTION_ERROR as TRANSACTION_EXECUTION_ERROR, errors$1_TXN_HASH_NOT_FOUND as TXN_HASH_NOT_FOUND, errors$1_UNEXPECTED_ERROR as UNEXPECTED_ERROR, errors$1_UNSUPPORTED_CONTRACT_CLASS_VERSION as UNSUPPORTED_CONTRACT_CLASS_VERSION, errors$1_UNSUPPORTED_TX_VERSION as UNSUPPORTED_TX_VERSION, errors$1_VALIDATION_FAILURE as VALIDATION_FAILURE };
}

/**
 * Types that are not in spec but required for UX
 */

type ContractClass$2 = CONTRACT_CLASS | DEPRECATED_CONTRACT_CLASS;
type SimulateTransaction$2 = {
    transaction_trace: TRANSACTION_TRACE;
    fee_estimation: FEE_ESTIMATE;
};
type SimulateTransactionResponse$2 = SimulateTransaction$2[];
type FeeEstimate$2 = FEE_ESTIMATE;
type TransactionWithHash$2 = TXN & {
    transaction_hash: TXN_HASH$1;
};
type BlockHashAndNumber$1 = {
    block_hash: BLOCK_HASH$1;
    block_number: BLOCK_NUMBER$1;
};
type BlockWithTxs$1 = BLOCK_WITH_TXS | PENDING_BLOCK_WITH_TXS;
type BlockWithTxHashes$2 = BLOCK_WITH_TX_HASHES | PENDING_BLOCK_WITH_TX_HASHES;
type StateUpdate$2 = STATE_UPDATE$1 | PENDING_STATE_UPDATE$1;
type BlockTransactionsTraces$1 = {
    transaction_hash: FELT$1;
    trace_root: TRANSACTION_TRACE;
}[];
type Syncing$1 = false | SYNC_STATUS;
type Events$1 = EVENTS_CHUNK;
type EmittedEvent$1 = EMITTED_EVENT;
type Event$1 = EVENT$1;
type InvokedTransaction$2 = {
    transaction_hash: TXN_HASH$1;
};
type DeclaredTransaction$2 = {
    transaction_hash: TXN_HASH$1;
    class_hash: FELT$1;
};
type DeployedAccountTransaction$1 = {
    transaction_hash: TXN_HASH$1;
    contract_address: FELT$1;
};
type ContractAddress$1 = ADDRESS;
type Felt$1 = FELT$1;
type Nonce$2 = FELT$1;
type TransactionHash$1 = TXN_HASH$1;
type TransactionTrace$1 = TRANSACTION_TRACE;
type BlockHash$1 = BLOCK_HASH$1;
type TransactionReceipt$2 = TXN_RECEIPT | PENDING_TXN_RECEIPT;
type Receipt$1 = TXN_RECEIPT;
type PendingReceipt$1 = PENDING_TXN_RECEIPT;
type EventFilter$1 = EVENT_FILTER & RESULT_PAGE_REQUEST;
type SimulationFlags$2 = Array<SIMULATION_FLAG$2>;
type L1Message$1 = MSG_FROM_L1;
type BaseTransaction$1 = BROADCASTED_TXN;
type ChainId$1 = CHAIN_ID;
type Transaction$1 = TXN;
type TransactionStatus$2 = {
    finality_status: TXN_STATUS;
    execution_status?: TXN_EXECUTION_STATUS;
};
type ResourceBounds$2 = RESOURCE_BOUNDS_MAPPING;
type FeePayment$1 = FEE_PAYMENT;
type PriceUnit$1 = PRICE_UNIT$1;
type StorageDiffs$1 = Array<CONTRACT_STORAGE_DIFF_ITEM>;
type DeprecatedDeclaredClasses$1 = Array<FELT$1>;
type NonceUpdates$1 = NONCE_UPDATE[];
type ReplacedClasses$1 = REPLACED_CLASS[];
declare enum ETransactionType$1 {
    DECLARE = "DECLARE",
    DEPLOY = "DEPLOY",
    DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT",
    INVOKE = "INVOKE",
    L1_HANDLER = "L1_HANDLER"
}
declare enum ESimulationFlag$1 {
    SKIP_VALIDATE = "SKIP_VALIDATE",
    SKIP_FEE_CHARGE = "SKIP_FEE_CHARGE"
}
declare enum ETransactionStatus$1 {
    RECEIVED = "RECEIVED",
    REJECTED = "REJECTED",
    ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
    ACCEPTED_ON_L1 = "ACCEPTED_ON_L1"
}
declare enum ETransactionFinalityStatus$1 {
    ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
    ACCEPTED_ON_L1 = "ACCEPTED_ON_L1"
}
declare enum ETransactionExecutionStatus$1 {
    SUCCEEDED = "SUCCEEDED",
    REVERTED = "REVERTED"
}
declare enum EBlockTag$1 {
    LATEST = "latest",
    PENDING = "pending"
}
declare enum EDataAvailabilityMode$1 {
    L1 = "L1",
    L2 = "L2"
}
declare enum EDAMode$1 {
    L1 = 0,
    L2 = 1
}
/**
 * V_ Transaction versions HexString
 * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)
 */
declare enum ETransactionVersion$1 {
    V0 = "0x0",
    V1 = "0x1",
    V2 = "0x2",
    V3 = "0x3",
    F0 = "0x100000000000000000000000000000000",
    F1 = "0x100000000000000000000000000000001",
    F2 = "0x100000000000000000000000000000002",
    F3 = "0x100000000000000000000000000000003"
}
/**
 * Old Transaction Versions
 */
declare enum ETransactionVersion2$1 {
    V0 = "0x0",
    V1 = "0x1",
    V2 = "0x2",
    F0 = "0x100000000000000000000000000000000",
    F1 = "0x100000000000000000000000000000001",
    F2 = "0x100000000000000000000000000000002"
}
/**
 * V3 Transaction Versions
 */
declare enum ETransactionVersion3$1 {
    V3 = "0x3",
    F3 = "0x100000000000000000000000000000003"
}

type Methods$1 = ReadMethods$1 & WriteMethods$1 & TraceMethods$1;
type ReadMethods$1 = {
    starknet_specVersion: {
        params: [];
        result: string;
    };
    starknet_getBlockWithTxHashes: {
        params: {
            block_id: BLOCK_ID;
        };
        result: BlockWithTxHashes$2;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_getBlockWithTxs: {
        params: {
            block_id: BLOCK_ID;
        };
        result: BlockWithTxs$1;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_getStateUpdate: {
        params: {
            block_id: BLOCK_ID;
        };
        result: StateUpdate$2;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_getStorageAt: {
        params: {
            contract_address: ADDRESS;
            key: STORAGE_KEY;
            block_id: BLOCK_ID;
        };
        result: FELT$1;
        errors: CONTRACT_NOT_FOUND | BLOCK_NOT_FOUND;
    };
    starknet_getTransactionStatus: {
        params: {
            transaction_hash: TXN_HASH$1;
        };
        result: TransactionStatus$2;
        errors: TXN_HASH_NOT_FOUND;
    };
    starknet_getTransactionByHash: {
        params: {
            transaction_hash: TXN_HASH$1;
        };
        result: TransactionWithHash$2;
        errors: TXN_HASH_NOT_FOUND;
    };
    starknet_getTransactionByBlockIdAndIndex: {
        params: {
            block_id: BLOCK_ID;
            index: number;
        };
        result: TransactionWithHash$2;
        errors: BLOCK_NOT_FOUND | INVALID_TXN_INDEX;
    };
    starknet_getTransactionReceipt: {
        params: {
            transaction_hash: TXN_HASH$1;
        };
        result: TransactionReceipt$2;
        errors: TXN_HASH_NOT_FOUND;
    };
    starknet_getClass: {
        params: {
            block_id: BLOCK_ID;
            class_hash: FELT$1;
        };
        result: ContractClass$2;
        errors: BLOCK_NOT_FOUND | CLASS_HASH_NOT_FOUND;
    };
    starknet_getClassHashAt: {
        params: {
            block_id: BLOCK_ID;
            contract_address: ADDRESS;
        };
        result: FELT$1;
        errors: BLOCK_NOT_FOUND | CONTRACT_NOT_FOUND;
    };
    starknet_getClassAt: {
        params: {
            block_id: BLOCK_ID;
            contract_address: ADDRESS;
        };
        result: ContractClass$2;
        errors: BLOCK_NOT_FOUND | CONTRACT_NOT_FOUND;
    };
    starknet_getBlockTransactionCount: {
        params: {
            block_id: BLOCK_ID;
        };
        result: number;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_call: {
        params: {
            request: FUNCTION_CALL;
            block_id: BLOCK_ID;
        };
        result: FELT$1[];
        errors: CONTRACT_NOT_FOUND | CONTRACT_ERROR | BLOCK_NOT_FOUND;
    };
    starknet_estimateFee: {
        params: {
            request: BROADCASTED_TXN[];
            simulation_flags?: [SIMULATION_FLAG_FOR_ESTIMATE_FEE] | [];
            block_id: BLOCK_ID;
        };
        result: FeeEstimate$2[];
        errors: TRANSACTION_EXECUTION_ERROR | BLOCK_NOT_FOUND;
    };
    starknet_estimateMessageFee: {
        params: {
            message: MSG_FROM_L1;
            block_id: BLOCK_ID;
        };
        result: FeeEstimate$2;
        errors: CONTRACT_ERROR | BLOCK_NOT_FOUND;
    };
    starknet_blockNumber: {
        params: [];
        result: BLOCK_NUMBER$1;
        errors: NO_BLOCKS;
    };
    starknet_blockHashAndNumber: {
        params: [];
        result: BlockHashAndNumber$1;
        errors: NO_BLOCKS;
    };
    starknet_chainId: {
        params: [];
        result: CHAIN_ID;
    };
    starknet_syncing: {
        params: [];
        result: Syncing$1;
    };
    starknet_getEvents: {
        params: {
            filter: EVENT_FILTER & RESULT_PAGE_REQUEST;
        };
        result: Events$1;
        errors: PAGE_SIZE_TOO_BIG | INVALID_CONTINUATION_TOKEN | BLOCK_NOT_FOUND | TOO_MANY_KEYS_IN_FILTER;
    };
    starknet_getNonce: {
        params: {
            block_id: BLOCK_ID;
            contract_address: ADDRESS;
        };
        result: Nonce$2;
        errors: BLOCK_NOT_FOUND | CONTRACT_NOT_FOUND;
    };
};
type WriteMethods$1 = {
    starknet_addInvokeTransaction: {
        params: {
            invoke_transaction: BROADCASTED_INVOKE_TXN;
        };
        result: InvokedTransaction$2;
        errors: INSUFFICIENT_ACCOUNT_BALANCE | INSUFFICIENT_MAX_FEE | INVALID_TRANSACTION_NONCE | VALIDATION_FAILURE | NON_ACCOUNT | DUPLICATE_TX | UNSUPPORTED_TX_VERSION | UNEXPECTED_ERROR;
    };
    starknet_addDeclareTransaction: {
        params: {
            declare_transaction: BROADCASTED_DECLARE_TXN;
        };
        result: DeclaredTransaction$2;
        errors: CLASS_ALREADY_DECLARED | COMPILATION_FAILED | COMPILED_CLASS_HASH_MISMATCH | INSUFFICIENT_ACCOUNT_BALANCE | INSUFFICIENT_MAX_FEE | INVALID_TRANSACTION_NONCE | VALIDATION_FAILURE | NON_ACCOUNT | DUPLICATE_TX | CONTRACT_CLASS_SIZE_IS_TOO_LARGE | UNSUPPORTED_TX_VERSION | UNSUPPORTED_CONTRACT_CLASS_VERSION | UNEXPECTED_ERROR;
    };
    starknet_addDeployAccountTransaction: {
        params: {
            deploy_account_transaction: BROADCASTED_DEPLOY_ACCOUNT_TXN;
        };
        result: DeployedAccountTransaction$1;
        errors: INSUFFICIENT_ACCOUNT_BALANCE | INSUFFICIENT_MAX_FEE | INVALID_TRANSACTION_NONCE | VALIDATION_FAILURE | NON_ACCOUNT | CLASS_HASH_NOT_FOUND | DUPLICATE_TX | UNSUPPORTED_TX_VERSION | UNEXPECTED_ERROR;
    };
};
type TraceMethods$1 = {
    starknet_traceTransaction: {
        params: {
            transaction_hash: TXN_HASH$1;
        };
        result: TransactionTrace$1;
        errors: TXN_HASH_NOT_FOUND | NO_TRACE_AVAILABLE;
    };
    starknet_traceBlockTransactions: {
        params: {
            block_id: BLOCK_ID;
        };
        result: BlockTransactionsTraces$1;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_simulateTransactions: {
        params: {
            block_id: BLOCK_ID;
            transactions: Array<BROADCASTED_TXN>;
            simulation_flags: Array<SIMULATION_FLAG$2>;
        };
        result: SimulateTransactionResponse$2;
        errors: BLOCK_NOT_FOUND | TRANSACTION_EXECUTION_ERROR;
    };
};

/**
 * TypeScript Representation of Cairo1 v2+ Starknet Contract ABI
 *
 * starknet_metadata.json - tags/v0.5.0
 *
 * 'starknet-specs' (OpenRpc protocol types)
 * https://github.com/starkware-libs/starknet-specs
 */
type ABI = Array<FUNCTION | CONSTRUCTOR | L1_HANDLER | EVENT | STRUCT | ENUM | INTERFACE | IMPL>;
type FUNCTION = {
    type: 'function';
    name: string;
    inputs: Array<{
        name: string;
        type: string;
    }>;
    outputs?: Array<{
        type: string;
    }>;
    state_mutability: 'view' | 'external';
};
type CONSTRUCTOR = {
    type: 'constructor';
    name: 'constructor';
    inputs: Array<{
        name: string;
        type: string;
    }>;
};
type L1_HANDLER = {
    type: 'l1_handler';
    name: string;
    inputs: Array<{
        name: string;
        type: string;
    }>;
    outputs?: Array<{
        type: string;
    }>;
    state_mutability: 'view' | 'external';
};
type EVENT = {
    type: 'event';
    name: string;
} & (ENUM_EVENT | STRUCT_EVENT);
type STRUCT_EVENT = {
    kind: 'struct';
    members: Array<EVENT_FIELD>;
};
type ENUM_EVENT = {
    kind: 'enum';
    variants: Array<EVENT_FIELD>;
};
type STRUCT = {
    type: 'struct';
    name: string;
    members: Array<{
        name: string;
        type: string;
    }>;
};
type ENUM = {
    type: 'enum';
    name: string;
    variants: Array<{
        name: string;
        type: string;
    }>;
};
type INTERFACE = {
    type: 'interface';
    name: string;
    items: Array<FUNCTION>;
};
type IMPL = {
    type: 'impl';
    name: string;
    interface_name: string;
};
type EVENT_FIELD = {
    name: string;
    type: string;
    kind: 'key' | 'data' | 'nested';
};

/**
 * version 0.6.0
 */

type index$5_ABI = ABI;
declare namespace index$5 {
  export { type index$5_ABI as ABI, type BaseTransaction$1 as BaseTransaction, type BlockHash$1 as BlockHash, type BlockHashAndNumber$1 as BlockHashAndNumber, type BlockTransactionsTraces$1 as BlockTransactionsTraces, type BlockWithTxHashes$2 as BlockWithTxHashes, type BlockWithTxs$1 as BlockWithTxs, type ChainId$1 as ChainId, type ContractAddress$1 as ContractAddress, type ContractClass$2 as ContractClass, type DeclaredTransaction$2 as DeclaredTransaction, type DeployedAccountTransaction$1 as DeployedAccountTransaction, type DeprecatedDeclaredClasses$1 as DeprecatedDeclaredClasses, EBlockTag$1 as EBlockTag, EDAMode$1 as EDAMode, EDataAvailabilityMode$1 as EDataAvailabilityMode, ESimulationFlag$1 as ESimulationFlag, ETransactionExecutionStatus$1 as ETransactionExecutionStatus, ETransactionFinalityStatus$1 as ETransactionFinalityStatus, ETransactionStatus$1 as ETransactionStatus, ETransactionType$1 as ETransactionType, ETransactionVersion$1 as ETransactionVersion, ETransactionVersion2$1 as ETransactionVersion2, ETransactionVersion3$1 as ETransactionVersion3, type EmittedEvent$1 as EmittedEvent, errors$1 as Errors, type Event$1 as Event, type EventFilter$1 as EventFilter, type Events$1 as Events, type FeeEstimate$2 as FeeEstimate, type FeePayment$1 as FeePayment, type Felt$1 as Felt, type InvokedTransaction$2 as InvokedTransaction, type L1Message$1 as L1Message, type Methods$1 as Methods, type Nonce$2 as Nonce, type NonceUpdates$1 as NonceUpdates, type PendingReceipt$1 as PendingReceipt, type PriceUnit$1 as PriceUnit, type Receipt$1 as Receipt, type ReplacedClasses$1 as ReplacedClasses, type ResourceBounds$2 as ResourceBounds, components as SPEC, type SimulateTransaction$2 as SimulateTransaction, type SimulateTransactionResponse$2 as SimulateTransactionResponse, type SimulationFlags$2 as SimulationFlags, type StateUpdate$2 as StateUpdate, type StorageDiffs$1 as StorageDiffs, type Syncing$1 as Syncing, type Transaction$1 as Transaction, type TransactionHash$1 as TransactionHash, type TransactionReceipt$2 as TransactionReceipt, type TransactionStatus$2 as TransactionStatus, type TransactionTrace$1 as TransactionTrace, type TransactionWithHash$2 as TransactionWithHash };
}

type errors_BLOCK_NOT_FOUND = BLOCK_NOT_FOUND;
type errors_CLASS_ALREADY_DECLARED = CLASS_ALREADY_DECLARED;
type errors_CLASS_HASH_NOT_FOUND = CLASS_HASH_NOT_FOUND;
type errors_COMPILATION_FAILED = COMPILATION_FAILED;
type errors_COMPILED_CLASS_HASH_MISMATCH = COMPILED_CLASS_HASH_MISMATCH;
type errors_CONTRACT_CLASS_SIZE_IS_TOO_LARGE = CONTRACT_CLASS_SIZE_IS_TOO_LARGE;
type errors_CONTRACT_ERROR = CONTRACT_ERROR;
type errors_CONTRACT_NOT_FOUND = CONTRACT_NOT_FOUND;
type errors_DUPLICATE_TX = DUPLICATE_TX;
type errors_FAILED_TO_RECEIVE_TXN = FAILED_TO_RECEIVE_TXN;
type errors_INSUFFICIENT_ACCOUNT_BALANCE = INSUFFICIENT_ACCOUNT_BALANCE;
type errors_INSUFFICIENT_MAX_FEE = INSUFFICIENT_MAX_FEE;
type errors_INVALID_BLOCK_HASH = INVALID_BLOCK_HASH;
type errors_INVALID_CALL_DATA = INVALID_CALL_DATA;
type errors_INVALID_CONTINUATION_TOKEN = INVALID_CONTINUATION_TOKEN;
type errors_INVALID_MESSAGE_SELECTOR = INVALID_MESSAGE_SELECTOR;
type errors_INVALID_TRANSACTION_NONCE = INVALID_TRANSACTION_NONCE;
type errors_INVALID_TXN_INDEX = INVALID_TXN_INDEX;
type errors_NON_ACCOUNT = NON_ACCOUNT;
type errors_NO_BLOCKS = NO_BLOCKS;
type errors_NO_TRACE_AVAILABLE = NO_TRACE_AVAILABLE;
type errors_PAGE_SIZE_TOO_BIG = PAGE_SIZE_TOO_BIG;
type errors_TOO_MANY_KEYS_IN_FILTER = TOO_MANY_KEYS_IN_FILTER;
type errors_TRANSACTION_EXECUTION_ERROR = TRANSACTION_EXECUTION_ERROR;
type errors_TXN_HASH_NOT_FOUND = TXN_HASH_NOT_FOUND;
type errors_UNEXPECTED_ERROR = UNEXPECTED_ERROR;
type errors_UNSUPPORTED_CONTRACT_CLASS_VERSION = UNSUPPORTED_CONTRACT_CLASS_VERSION;
type errors_UNSUPPORTED_TX_VERSION = UNSUPPORTED_TX_VERSION;
type errors_VALIDATION_FAILURE = VALIDATION_FAILURE;
declare namespace errors {
  export type { errors_BLOCK_NOT_FOUND as BLOCK_NOT_FOUND, errors_CLASS_ALREADY_DECLARED as CLASS_ALREADY_DECLARED, errors_CLASS_HASH_NOT_FOUND as CLASS_HASH_NOT_FOUND, errors_COMPILATION_FAILED as COMPILATION_FAILED, errors_COMPILED_CLASS_HASH_MISMATCH as COMPILED_CLASS_HASH_MISMATCH, errors_CONTRACT_CLASS_SIZE_IS_TOO_LARGE as CONTRACT_CLASS_SIZE_IS_TOO_LARGE, errors_CONTRACT_ERROR as CONTRACT_ERROR, errors_CONTRACT_NOT_FOUND as CONTRACT_NOT_FOUND, errors_DUPLICATE_TX as DUPLICATE_TX, errors_FAILED_TO_RECEIVE_TXN as FAILED_TO_RECEIVE_TXN, errors_INSUFFICIENT_ACCOUNT_BALANCE as INSUFFICIENT_ACCOUNT_BALANCE, errors_INSUFFICIENT_MAX_FEE as INSUFFICIENT_MAX_FEE, errors_INVALID_BLOCK_HASH as INVALID_BLOCK_HASH, errors_INVALID_CALL_DATA as INVALID_CALL_DATA, errors_INVALID_CONTINUATION_TOKEN as INVALID_CONTINUATION_TOKEN, errors_INVALID_MESSAGE_SELECTOR as INVALID_MESSAGE_SELECTOR, errors_INVALID_TRANSACTION_NONCE as INVALID_TRANSACTION_NONCE, errors_INVALID_TXN_INDEX as INVALID_TXN_INDEX, errors_NON_ACCOUNT as NON_ACCOUNT, errors_NO_BLOCKS as NO_BLOCKS, errors_NO_TRACE_AVAILABLE as NO_TRACE_AVAILABLE, errors_PAGE_SIZE_TOO_BIG as PAGE_SIZE_TOO_BIG, errors_TOO_MANY_KEYS_IN_FILTER as TOO_MANY_KEYS_IN_FILTER, errors_TRANSACTION_EXECUTION_ERROR as TRANSACTION_EXECUTION_ERROR, errors_TXN_HASH_NOT_FOUND as TXN_HASH_NOT_FOUND, errors_UNEXPECTED_ERROR as UNEXPECTED_ERROR, errors_UNSUPPORTED_CONTRACT_CLASS_VERSION as UNSUPPORTED_CONTRACT_CLASS_VERSION, errors_UNSUPPORTED_TX_VERSION as UNSUPPORTED_TX_VERSION, errors_VALIDATION_FAILURE as VALIDATION_FAILURE };
}

/**
 * Types that are not in spec but required for UX
 */

type ContractClass$1 = CONTRACT_CLASS$1 | DEPRECATED_CONTRACT_CLASS$1;
type SimulateTransaction$1 = {
    transaction_trace: TRANSACTION_TRACE$1;
    fee_estimation: FEE_ESTIMATE$1;
};
type SimulateTransactionResponse$1 = SimulateTransaction$1[];
type FeeEstimate$1 = FEE_ESTIMATE$1;
type TransactionWithHash$1 = TXN$1 & {
    transaction_hash: TXN_HASH$2;
};
type BlockHashAndNumber = {
    block_hash: BLOCK_HASH$2;
    block_number: BLOCK_NUMBER$2;
};
type BlockWithTxs = BLOCK_WITH_TXS$1 | PENDING_BLOCK_WITH_TXS$1;
type BlockWithTxHashes$1 = BLOCK_WITH_TX_HASHES$1 | PENDING_BLOCK_WITH_TX_HASHES$1;
type BlockWithTxReceipts = BLOCK_WITH_RECEIPTS | PENDING_BLOCK_WITH_RECEIPTS;
type StateUpdate$1 = STATE_UPDATE$2 | PENDING_STATE_UPDATE$2;
type BlockTransactionsTraces = {
    transaction_hash: FELT$2;
    trace_root: TRANSACTION_TRACE$1;
}[];
type Syncing = false | SYNC_STATUS$1;
type Events = EVENTS_CHUNK$1;
type EmittedEvent = EMITTED_EVENT$1;
type Event = EVENT$2;
type InvokedTransaction$1 = {
    transaction_hash: TXN_HASH$2;
};
type DeclaredTransaction$1 = {
    transaction_hash: TXN_HASH$2;
    class_hash: FELT$2;
};
type DeployedAccountTransaction = {
    transaction_hash: TXN_HASH$2;
    contract_address: FELT$2;
};
type ContractAddress = ADDRESS$1;
type Felt = FELT$2;
type Nonce$1 = FELT$2;
type TransactionHash = TXN_HASH$2;
type TransactionTrace = TRANSACTION_TRACE$1;
type BlockHash = BLOCK_HASH$2;
type TransactionReceipt$1 = TXN_RECEIPT_WITH_BLOCK_INFO;
type Receipt = TXN_RECEIPT_WITH_BLOCK_INFO & BlockHashAndNumber;
type PendingReceipt = TXN_RECEIPT$1;
type EventFilter = EVENT_FILTER$1 & RESULT_PAGE_REQUEST$1;
type SimulationFlags$1 = Array<SIMULATION_FLAG$3>;
type L1Message = MSG_FROM_L1$1;
type BaseTransaction = BROADCASTED_TXN$1;
type ChainId = CHAIN_ID$1;
type Transaction = TXN$1;
type TransactionStatus$1 = {
    finality_status: TXN_STATUS$1;
    execution_status?: TXN_EXECUTION_STATUS$1;
};
type ResourceBounds$1 = RESOURCE_BOUNDS_MAPPING$1;
type FeePayment = FEE_PAYMENT$1;
type PriceUnit = PRICE_UNIT$2;
type StorageDiffs = Array<CONTRACT_STORAGE_DIFF_ITEM$1>;
type DeprecatedDeclaredClasses = Array<FELT$2>;
type NonceUpdates = NONCE_UPDATE$1[];
type ReplacedClasses = REPLACED_CLASS$1[];
declare enum ETransactionType {
    DECLARE = "DECLARE",
    DEPLOY = "DEPLOY",
    DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT",
    INVOKE = "INVOKE",
    L1_HANDLER = "L1_HANDLER"
}
declare enum ESimulationFlag {
    SKIP_VALIDATE = "SKIP_VALIDATE",
    SKIP_FEE_CHARGE = "SKIP_FEE_CHARGE"
}
declare enum ETransactionStatus {
    RECEIVED = "RECEIVED",
    REJECTED = "REJECTED",
    ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
    ACCEPTED_ON_L1 = "ACCEPTED_ON_L1"
}
declare enum ETransactionFinalityStatus {
    ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
    ACCEPTED_ON_L1 = "ACCEPTED_ON_L1"
}
declare enum ETransactionExecutionStatus {
    SUCCEEDED = "SUCCEEDED",
    REVERTED = "REVERTED"
}
declare enum EBlockTag {
    LATEST = "latest",
    PENDING = "pending"
}
declare enum EDataAvailabilityMode {
    L1 = "L1",
    L2 = "L2"
}
declare enum EDAMode {
    L1 = 0,
    L2 = 1
}
/**
 * V_ Transaction versions HexString
 * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)
 */
declare enum ETransactionVersion {
    V0 = "0x0",
    V1 = "0x1",
    V2 = "0x2",
    V3 = "0x3",
    F0 = "0x100000000000000000000000000000000",
    F1 = "0x100000000000000000000000000000001",
    F2 = "0x100000000000000000000000000000002",
    F3 = "0x100000000000000000000000000000003"
}
/**
 * Old Transaction Versions
 */
declare enum ETransactionVersion2 {
    V0 = "0x0",
    V1 = "0x1",
    V2 = "0x2",
    F0 = "0x100000000000000000000000000000000",
    F1 = "0x100000000000000000000000000000001",
    F2 = "0x100000000000000000000000000000002"
}
/**
 * V3 Transaction Versions
 */
declare enum ETransactionVersion3 {
    V3 = "0x3",
    F3 = "0x100000000000000000000000000000003"
}

type Methods = ReadMethods & WriteMethods & TraceMethods;
type ReadMethods = {
    starknet_specVersion: {
        params: [];
        result: string;
    };
    starknet_getBlockWithTxHashes: {
        params: {
            block_id: BLOCK_ID$1;
        };
        result: BlockWithTxHashes$1;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_getBlockWithTxs: {
        params: {
            block_id: BLOCK_ID$1;
        };
        result: BlockWithTxs;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_getBlockWithReceipts: {
        params: {
            block_id: BLOCK_ID$1;
        };
        result: BlockWithTxReceipts;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_getStateUpdate: {
        params: {
            block_id: BLOCK_ID$1;
        };
        result: StateUpdate$1;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_getStorageAt: {
        params: {
            contract_address: ADDRESS$1;
            key: STORAGE_KEY$1;
            block_id: BLOCK_ID$1;
        };
        result: FELT$2;
        errors: CONTRACT_NOT_FOUND | BLOCK_NOT_FOUND;
    };
    starknet_getTransactionStatus: {
        params: {
            transaction_hash: TXN_HASH$2;
        };
        result: TransactionStatus$1;
        errors: TXN_HASH_NOT_FOUND;
    };
    starknet_getTransactionByHash: {
        params: {
            transaction_hash: TXN_HASH$2;
        };
        result: TransactionWithHash$1;
        errors: TXN_HASH_NOT_FOUND;
    };
    starknet_getTransactionByBlockIdAndIndex: {
        params: {
            block_id: BLOCK_ID$1;
            index: number;
        };
        result: TransactionWithHash$1;
        errors: BLOCK_NOT_FOUND | INVALID_TXN_INDEX;
    };
    starknet_getTransactionReceipt: {
        params: {
            transaction_hash: TXN_HASH$2;
        };
        result: TransactionReceipt$1;
        errors: TXN_HASH_NOT_FOUND;
    };
    starknet_getClass: {
        params: {
            block_id: BLOCK_ID$1;
            class_hash: FELT$2;
        };
        result: ContractClass$1;
        errors: BLOCK_NOT_FOUND | CLASS_HASH_NOT_FOUND;
    };
    starknet_getClassHashAt: {
        params: {
            block_id: BLOCK_ID$1;
            contract_address: ADDRESS$1;
        };
        result: FELT$2;
        errors: BLOCK_NOT_FOUND | CONTRACT_NOT_FOUND;
    };
    starknet_getClassAt: {
        params: {
            block_id: BLOCK_ID$1;
            contract_address: ADDRESS$1;
        };
        result: ContractClass$1;
        errors: BLOCK_NOT_FOUND | CONTRACT_NOT_FOUND;
    };
    starknet_getBlockTransactionCount: {
        params: {
            block_id: BLOCK_ID$1;
        };
        result: number;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_call: {
        params: {
            request: FUNCTION_CALL$1;
            block_id: BLOCK_ID$1;
        };
        result: FELT$2[];
        errors: CONTRACT_NOT_FOUND | CONTRACT_ERROR | BLOCK_NOT_FOUND;
    };
    starknet_estimateFee: {
        params: {
            request: BROADCASTED_TXN$1[];
            simulation_flags?: [SIMULATION_FLAG_FOR_ESTIMATE_FEE$1] | [];
            block_id: BLOCK_ID$1;
        };
        result: FeeEstimate$1[];
        errors: TRANSACTION_EXECUTION_ERROR | BLOCK_NOT_FOUND;
    };
    starknet_estimateMessageFee: {
        params: {
            message: MSG_FROM_L1$1;
            block_id: BLOCK_ID$1;
        };
        result: FeeEstimate$1;
        errors: CONTRACT_ERROR | BLOCK_NOT_FOUND;
    };
    starknet_blockNumber: {
        params: [];
        result: BLOCK_NUMBER$2;
        errors: NO_BLOCKS;
    };
    starknet_blockHashAndNumber: {
        params: [];
        result: BlockHashAndNumber;
        errors: NO_BLOCKS;
    };
    starknet_chainId: {
        params: [];
        result: CHAIN_ID$1;
    };
    starknet_syncing: {
        params: [];
        result: Syncing;
    };
    starknet_getEvents: {
        params: {
            filter: EVENT_FILTER$1 & RESULT_PAGE_REQUEST$1;
        };
        result: Events;
        errors: PAGE_SIZE_TOO_BIG | INVALID_CONTINUATION_TOKEN | BLOCK_NOT_FOUND | TOO_MANY_KEYS_IN_FILTER;
    };
    starknet_getNonce: {
        params: {
            block_id: BLOCK_ID$1;
            contract_address: ADDRESS$1;
        };
        result: Nonce$1;
        errors: BLOCK_NOT_FOUND | CONTRACT_NOT_FOUND;
    };
};
type WriteMethods = {
    starknet_addInvokeTransaction: {
        params: {
            invoke_transaction: BROADCASTED_INVOKE_TXN$1;
        };
        result: InvokedTransaction$1;
        errors: INSUFFICIENT_ACCOUNT_BALANCE | INSUFFICIENT_MAX_FEE | INVALID_TRANSACTION_NONCE | VALIDATION_FAILURE | NON_ACCOUNT | DUPLICATE_TX | UNSUPPORTED_TX_VERSION | UNEXPECTED_ERROR;
    };
    starknet_addDeclareTransaction: {
        params: {
            declare_transaction: BROADCASTED_DECLARE_TXN$1;
        };
        result: DeclaredTransaction$1;
        errors: CLASS_ALREADY_DECLARED | COMPILATION_FAILED | COMPILED_CLASS_HASH_MISMATCH | INSUFFICIENT_ACCOUNT_BALANCE | INSUFFICIENT_MAX_FEE | INVALID_TRANSACTION_NONCE | VALIDATION_FAILURE | NON_ACCOUNT | DUPLICATE_TX | CONTRACT_CLASS_SIZE_IS_TOO_LARGE | UNSUPPORTED_TX_VERSION | UNSUPPORTED_CONTRACT_CLASS_VERSION | UNEXPECTED_ERROR;
    };
    starknet_addDeployAccountTransaction: {
        params: {
            deploy_account_transaction: BROADCASTED_DEPLOY_ACCOUNT_TXN$1;
        };
        result: DeployedAccountTransaction;
        errors: INSUFFICIENT_ACCOUNT_BALANCE | INSUFFICIENT_MAX_FEE | INVALID_TRANSACTION_NONCE | VALIDATION_FAILURE | NON_ACCOUNT | CLASS_HASH_NOT_FOUND | DUPLICATE_TX | UNSUPPORTED_TX_VERSION | UNEXPECTED_ERROR;
    };
};
type TraceMethods = {
    starknet_traceTransaction: {
        params: {
            transaction_hash: TXN_HASH$2;
        };
        result: TransactionTrace;
        errors: TXN_HASH_NOT_FOUND | NO_TRACE_AVAILABLE;
    };
    starknet_traceBlockTransactions: {
        params: {
            block_id: BLOCK_ID$1;
        };
        result: BlockTransactionsTraces;
        errors: BLOCK_NOT_FOUND;
    };
    starknet_simulateTransactions: {
        params: {
            block_id: BLOCK_ID$1;
            transactions: Array<BROADCASTED_TXN$1>;
            simulation_flags: Array<SIMULATION_FLAG$3>;
        };
        result: SimulateTransactionResponse$1;
        errors: BLOCK_NOT_FOUND | TRANSACTION_EXECUTION_ERROR;
    };
};

/**
 * version v0.7.0-rc1
 */

type index$4_ABI = ABI;
type index$4_BaseTransaction = BaseTransaction;
type index$4_BlockHash = BlockHash;
type index$4_BlockHashAndNumber = BlockHashAndNumber;
type index$4_BlockTransactionsTraces = BlockTransactionsTraces;
type index$4_BlockWithTxReceipts = BlockWithTxReceipts;
type index$4_BlockWithTxs = BlockWithTxs;
type index$4_ChainId = ChainId;
type index$4_ContractAddress = ContractAddress;
type index$4_DeployedAccountTransaction = DeployedAccountTransaction;
type index$4_DeprecatedDeclaredClasses = DeprecatedDeclaredClasses;
type index$4_EBlockTag = EBlockTag;
declare const index$4_EBlockTag: typeof EBlockTag;
type index$4_EDAMode = EDAMode;
declare const index$4_EDAMode: typeof EDAMode;
type index$4_EDataAvailabilityMode = EDataAvailabilityMode;
declare const index$4_EDataAvailabilityMode: typeof EDataAvailabilityMode;
type index$4_ESimulationFlag = ESimulationFlag;
declare const index$4_ESimulationFlag: typeof ESimulationFlag;
type index$4_ETransactionExecutionStatus = ETransactionExecutionStatus;
declare const index$4_ETransactionExecutionStatus: typeof ETransactionExecutionStatus;
type index$4_ETransactionFinalityStatus = ETransactionFinalityStatus;
declare const index$4_ETransactionFinalityStatus: typeof ETransactionFinalityStatus;
type index$4_ETransactionStatus = ETransactionStatus;
declare const index$4_ETransactionStatus: typeof ETransactionStatus;
type index$4_ETransactionType = ETransactionType;
declare const index$4_ETransactionType: typeof ETransactionType;
type index$4_ETransactionVersion = ETransactionVersion;
declare const index$4_ETransactionVersion: typeof ETransactionVersion;
type index$4_ETransactionVersion2 = ETransactionVersion2;
declare const index$4_ETransactionVersion2: typeof ETransactionVersion2;
type index$4_ETransactionVersion3 = ETransactionVersion3;
declare const index$4_ETransactionVersion3: typeof ETransactionVersion3;
type index$4_EmittedEvent = EmittedEvent;
type index$4_Event = Event;
type index$4_EventFilter = EventFilter;
type index$4_Events = Events;
type index$4_FeePayment = FeePayment;
type index$4_Felt = Felt;
type index$4_L1Message = L1Message;
type index$4_Methods = Methods;
type index$4_NonceUpdates = NonceUpdates;
type index$4_PendingReceipt = PendingReceipt;
type index$4_PriceUnit = PriceUnit;
type index$4_Receipt = Receipt;
type index$4_ReplacedClasses = ReplacedClasses;
type index$4_StorageDiffs = StorageDiffs;
type index$4_Syncing = Syncing;
type index$4_Transaction = Transaction;
type index$4_TransactionHash = TransactionHash;
type index$4_TransactionTrace = TransactionTrace;
declare namespace index$4 {
  export { type index$4_ABI as ABI, type index$4_BaseTransaction as BaseTransaction, type index$4_BlockHash as BlockHash, type index$4_BlockHashAndNumber as BlockHashAndNumber, type index$4_BlockTransactionsTraces as BlockTransactionsTraces, type BlockWithTxHashes$1 as BlockWithTxHashes, type index$4_BlockWithTxReceipts as BlockWithTxReceipts, type index$4_BlockWithTxs as BlockWithTxs, type index$4_ChainId as ChainId, type index$4_ContractAddress as ContractAddress, type ContractClass$1 as ContractClass, type DeclaredTransaction$1 as DeclaredTransaction, type index$4_DeployedAccountTransaction as DeployedAccountTransaction, type index$4_DeprecatedDeclaredClasses as DeprecatedDeclaredClasses, index$4_EBlockTag as EBlockTag, index$4_EDAMode as EDAMode, index$4_EDataAvailabilityMode as EDataAvailabilityMode, index$4_ESimulationFlag as ESimulationFlag, index$4_ETransactionExecutionStatus as ETransactionExecutionStatus, index$4_ETransactionFinalityStatus as ETransactionFinalityStatus, index$4_ETransactionStatus as ETransactionStatus, index$4_ETransactionType as ETransactionType, index$4_ETransactionVersion as ETransactionVersion, index$4_ETransactionVersion2 as ETransactionVersion2, index$4_ETransactionVersion3 as ETransactionVersion3, type index$4_EmittedEvent as EmittedEvent, errors as Errors, type index$4_Event as Event, type index$4_EventFilter as EventFilter, type index$4_Events as Events, type FeeEstimate$1 as FeeEstimate, type index$4_FeePayment as FeePayment, type index$4_Felt as Felt, type InvokedTransaction$1 as InvokedTransaction, type index$4_L1Message as L1Message, type index$4_Methods as Methods, type Nonce$1 as Nonce, type index$4_NonceUpdates as NonceUpdates, type index$4_PendingReceipt as PendingReceipt, type index$4_PriceUnit as PriceUnit, type index$4_Receipt as Receipt, type index$4_ReplacedClasses as ReplacedClasses, type ResourceBounds$1 as ResourceBounds, components$1 as SPEC, type SimulateTransaction$1 as SimulateTransaction, type SimulateTransactionResponse$1 as SimulateTransactionResponse, type SimulationFlags$1 as SimulationFlags, type StateUpdate$1 as StateUpdate, type index$4_StorageDiffs as StorageDiffs, type index$4_Syncing as Syncing, type index$4_Transaction as Transaction, type index$4_TransactionHash as TransactionHash, type TransactionReceipt$1 as TransactionReceipt, type TransactionStatus$1 as TransactionStatus, type index$4_TransactionTrace as TransactionTrace, type TransactionWithHash$1 as TransactionWithHash };
}

type index$3_ABI = ABI;
type index$3_BaseTransaction = BaseTransaction;
type index$3_BlockHash = BlockHash;
type index$3_BlockHashAndNumber = BlockHashAndNumber;
type index$3_BlockTransactionsTraces = BlockTransactionsTraces;
type index$3_BlockWithTxReceipts = BlockWithTxReceipts;
type index$3_BlockWithTxs = BlockWithTxs;
type index$3_ChainId = ChainId;
type index$3_ContractAddress = ContractAddress;
type index$3_DeployedAccountTransaction = DeployedAccountTransaction;
type index$3_DeprecatedDeclaredClasses = DeprecatedDeclaredClasses;
type index$3_EBlockTag = EBlockTag;
declare const index$3_EBlockTag: typeof EBlockTag;
type index$3_EDAMode = EDAMode;
declare const index$3_EDAMode: typeof EDAMode;
type index$3_EDataAvailabilityMode = EDataAvailabilityMode;
declare const index$3_EDataAvailabilityMode: typeof EDataAvailabilityMode;
type index$3_ESimulationFlag = ESimulationFlag;
declare const index$3_ESimulationFlag: typeof ESimulationFlag;
type index$3_ETransactionExecutionStatus = ETransactionExecutionStatus;
declare const index$3_ETransactionExecutionStatus: typeof ETransactionExecutionStatus;
type index$3_ETransactionFinalityStatus = ETransactionFinalityStatus;
declare const index$3_ETransactionFinalityStatus: typeof ETransactionFinalityStatus;
type index$3_ETransactionStatus = ETransactionStatus;
declare const index$3_ETransactionStatus: typeof ETransactionStatus;
type index$3_ETransactionType = ETransactionType;
declare const index$3_ETransactionType: typeof ETransactionType;
type index$3_ETransactionVersion = ETransactionVersion;
declare const index$3_ETransactionVersion: typeof ETransactionVersion;
type index$3_ETransactionVersion2 = ETransactionVersion2;
declare const index$3_ETransactionVersion2: typeof ETransactionVersion2;
type index$3_ETransactionVersion3 = ETransactionVersion3;
declare const index$3_ETransactionVersion3: typeof ETransactionVersion3;
type index$3_EmittedEvent = EmittedEvent;
type index$3_Event = Event;
type index$3_EventFilter = EventFilter;
type index$3_Events = Events;
type index$3_FeePayment = FeePayment;
type index$3_Felt = Felt;
type index$3_L1Message = L1Message;
type index$3_Methods = Methods;
type index$3_NonceUpdates = NonceUpdates;
type index$3_PendingReceipt = PendingReceipt;
type index$3_PriceUnit = PriceUnit;
type index$3_Receipt = Receipt;
type index$3_ReplacedClasses = ReplacedClasses;
type index$3_StorageDiffs = StorageDiffs;
type index$3_Syncing = Syncing;
type index$3_Transaction = Transaction;
type index$3_TransactionHash = TransactionHash;
type index$3_TransactionTrace = TransactionTrace;
declare namespace index$3 {
  export { type index$3_ABI as ABI, type index$3_BaseTransaction as BaseTransaction, type index$3_BlockHash as BlockHash, type index$3_BlockHashAndNumber as BlockHashAndNumber, type index$3_BlockTransactionsTraces as BlockTransactionsTraces, type BlockWithTxHashes$1 as BlockWithTxHashes, type index$3_BlockWithTxReceipts as BlockWithTxReceipts, type index$3_BlockWithTxs as BlockWithTxs, type index$3_ChainId as ChainId, type index$3_ContractAddress as ContractAddress, type ContractClass$1 as ContractClass, type DeclaredTransaction$1 as DeclaredTransaction, type index$3_DeployedAccountTransaction as DeployedAccountTransaction, type index$3_DeprecatedDeclaredClasses as DeprecatedDeclaredClasses, index$3_EBlockTag as EBlockTag, index$3_EDAMode as EDAMode, index$3_EDataAvailabilityMode as EDataAvailabilityMode, index$3_ESimulationFlag as ESimulationFlag, index$3_ETransactionExecutionStatus as ETransactionExecutionStatus, index$3_ETransactionFinalityStatus as ETransactionFinalityStatus, index$3_ETransactionStatus as ETransactionStatus, index$3_ETransactionType as ETransactionType, index$3_ETransactionVersion as ETransactionVersion, index$3_ETransactionVersion2 as ETransactionVersion2, index$3_ETransactionVersion3 as ETransactionVersion3, type index$3_EmittedEvent as EmittedEvent, errors as Errors, type index$3_Event as Event, type index$3_EventFilter as EventFilter, type index$3_Events as Events, type FeeEstimate$1 as FeeEstimate, type index$3_FeePayment as FeePayment, type index$3_Felt as Felt, type InvokedTransaction$1 as InvokedTransaction, index$6 as JRPC, type index$3_L1Message as L1Message, type index$3_Methods as Methods, type Nonce$1 as Nonce, type index$3_NonceUpdates as NonceUpdates, type index$3_PendingReceipt as PendingReceipt, type index$3_PriceUnit as PriceUnit, index$5 as RPCSPEC06, index$4 as RPCSPEC07, type index$3_Receipt as Receipt, type index$3_ReplacedClasses as ReplacedClasses, type ResourceBounds$1 as ResourceBounds, components$1 as SPEC, type SimulateTransaction$1 as SimulateTransaction, type SimulateTransactionResponse$1 as SimulateTransactionResponse, type SimulationFlags$1 as SimulationFlags, type StateUpdate$1 as StateUpdate, type index$3_StorageDiffs as StorageDiffs, type index$3_Syncing as Syncing, type index$3_Transaction as Transaction, type index$3_TransactionHash as TransactionHash, type TransactionReceipt$1 as TransactionReceipt, type TransactionStatus$1 as TransactionStatus, type index$3_TransactionTrace as TransactionTrace, type TransactionWithHash$1 as TransactionWithHash };
}

declare const IS_BROWSER: boolean;
/**
 * Some functions recreated from https://github.com/pedrouid/enc-utils/blob/master/src/index.ts
 * enc-utils is not a dependency to avoid using `Buffer` which only works in node and not browsers
 */
/**
 * Convert array buffer to string
 *
 * *[internal usage]*
 */
declare function arrayBufferToString(array: ArrayBuffer): string;
/**
 * Convert utf8-string to Uint8Array
 *
 * *[internal usage]*
 */
declare function utf8ToArray(str: string): Uint8Array;
/**
 * Convert utf8-string to Uint8Array
 *
 * @deprecated equivalent to 'utf8ToArray', alias will be removed
 */
declare function stringToArrayBuffer(str: string): Uint8Array;
/**
 * Convert string to array buffer (browser and node compatible)
 */
declare function atobUniversal(a: string): Uint8Array;
/**
 * Convert array buffer to string (browser and node compatible)
 */
declare function btoaUniversal(b: ArrayBuffer): string;
/**
 * Convert array buffer to hex-string
 * @returns format: hex-string
 */
declare function buf2hex(buffer: Uint8Array): string;
/**
 * Remove hex prefix '0x' from hex-string
 * @param hex hex-string
 * @returns format: base16-string
 */
declare function removeHexPrefix(hex: string): string;
/**
 * Add hex prefix '0x' to base16-string
 * @param hex base16-string
 * @returns format: hex-string
 */
declare function addHexPrefix(hex: string): string;
/**
 * Prepend string (default with '0')
 */
declare function padLeft(str: string, length: number, padding?: string): string;
/**
 * Calculate byte length of string
 *
 * *[no internal usage]*
 */
declare function calcByteLength(str: string, byteSize?: number): number;
/**
 * Prepend '0' to string bytes
 *
 * *[no internal usage]*
 */
declare function sanitizeBytes(str: string, byteSize?: number, padding?: string): string;
/**
 * Prepend '0' to hex-string bytes
 *
 * *[no internal usage]*
 * @param hex hex-string
 * @returns format: hex-string
 */
declare function sanitizeHex(hex: string): string;
/**
 * String transformation util
 *
 * Pascal case to screaming snake case
 */
declare const pascalToSnake: (text: string) => string;

declare const encode_IS_BROWSER: typeof IS_BROWSER;
declare const encode_addHexPrefix: typeof addHexPrefix;
declare const encode_arrayBufferToString: typeof arrayBufferToString;
declare const encode_atobUniversal: typeof atobUniversal;
declare const encode_btoaUniversal: typeof btoaUniversal;
declare const encode_buf2hex: typeof buf2hex;
declare const encode_calcByteLength: typeof calcByteLength;
declare const encode_padLeft: typeof padLeft;
declare const encode_pascalToSnake: typeof pascalToSnake;
declare const encode_removeHexPrefix: typeof removeHexPrefix;
declare const encode_sanitizeBytes: typeof sanitizeBytes;
declare const encode_sanitizeHex: typeof sanitizeHex;
declare const encode_stringToArrayBuffer: typeof stringToArrayBuffer;
declare const encode_utf8ToArray: typeof utf8ToArray;
declare namespace encode {
  export { encode_IS_BROWSER as IS_BROWSER, encode_addHexPrefix as addHexPrefix, encode_arrayBufferToString as arrayBufferToString, encode_atobUniversal as atobUniversal, encode_btoaUniversal as btoaUniversal, encode_buf2hex as buf2hex, encode_calcByteLength as calcByteLength, encode_padLeft as padLeft, encode_pascalToSnake as pascalToSnake, encode_removeHexPrefix as removeHexPrefix, encode_sanitizeBytes as sanitizeBytes, encode_sanitizeHex as sanitizeHex, encode_stringToArrayBuffer as stringToArrayBuffer, encode_utf8ToArray as utf8ToArray };
}

/**
 * Cairo Felt support storing max 31 character
 */
declare const TEXT_TO_FELT_MAX_LEN = 31;

declare const ZERO = 0n;
declare const MASK_250: bigint;
declare const API_VERSION = 0n;
declare const PRIME: bigint;
declare const MAX_STORAGE_ITEM_SIZE = 256n;
declare const ADDR_BOUND: bigint;
declare const RANGE_FELT: {
    readonly min: bigint;
    readonly max: bigint;
};
declare const RANGE_I128: {
    readonly min: bigint;
    readonly max: bigint;
};
declare const RANGE_U128: {
    readonly min: bigint;
    readonly max: bigint;
};
declare enum BaseUrl {
    SN_MAIN = "https://alpha-mainnet.starknet.io",
    SN_GOERLI = "https://alpha4.starknet.io",
    SN_SEPOLIA = "https://alpha-sepolia.starknet.io"
}
declare enum NetworkName {
    SN_MAIN = "SN_MAIN",
    SN_GOERLI = "SN_GOERLI",
    SN_SEPOLIA = "SN_SEPOLIA"
}
declare enum StarknetChainId {
    SN_MAIN = "0x534e5f4d41494e",// encodeShortString('SN_MAIN'),
    SN_GOERLI = "0x534e5f474f45524c49",// encodeShortString('SN_GOERLI')
    SN_SEPOLIA = "0x534e5f5345504f4c4941"
}
declare enum TransactionHashPrefix {
    DECLARE = "0x6465636c617265",// encodeShortString('declare'),
    DEPLOY = "0x6465706c6f79",// encodeShortString('deploy'),
    DEPLOY_ACCOUNT = "0x6465706c6f795f6163636f756e74",// encodeShortString('deploy_account'),
    INVOKE = "0x696e766f6b65",// encodeShortString('invoke'),
    L1_HANDLER = "0x6c315f68616e646c6572"
}
declare const enum feeMarginPercentage {
    L1_BOUND_MAX_AMOUNT = 50,
    L1_BOUND_MAX_PRICE_PER_UNIT = 50,
    MAX_FEE = 50
}
declare const UDC: {
    ADDRESS: string;
    ENTRYPOINT: string;
};
declare const RPC_DEFAULT_VERSION = "v0_7";
declare const RPC_NODES: {
    SN_GOERLI: string[];
    SN_MAIN: string[];
    SN_SEPOLIA: string[];
};

declare const constants_ADDR_BOUND: typeof ADDR_BOUND;
declare const constants_API_VERSION: typeof API_VERSION;
type constants_BaseUrl = BaseUrl;
declare const constants_BaseUrl: typeof BaseUrl;
declare const constants_IS_BROWSER: typeof IS_BROWSER;
declare const constants_MASK_250: typeof MASK_250;
declare const constants_MAX_STORAGE_ITEM_SIZE: typeof MAX_STORAGE_ITEM_SIZE;
type constants_NetworkName = NetworkName;
declare const constants_NetworkName: typeof NetworkName;
declare const constants_PRIME: typeof PRIME;
declare const constants_RANGE_FELT: typeof RANGE_FELT;
declare const constants_RANGE_I128: typeof RANGE_I128;
declare const constants_RANGE_U128: typeof RANGE_U128;
declare const constants_RPC_DEFAULT_VERSION: typeof RPC_DEFAULT_VERSION;
declare const constants_RPC_NODES: typeof RPC_NODES;
type constants_StarknetChainId = StarknetChainId;
declare const constants_StarknetChainId: typeof StarknetChainId;
declare const constants_TEXT_TO_FELT_MAX_LEN: typeof TEXT_TO_FELT_MAX_LEN;
type constants_TransactionHashPrefix = TransactionHashPrefix;
declare const constants_TransactionHashPrefix: typeof TransactionHashPrefix;
declare const constants_UDC: typeof UDC;
declare const constants_ZERO: typeof ZERO;
type constants_feeMarginPercentage = feeMarginPercentage;
declare const constants_feeMarginPercentage: typeof feeMarginPercentage;
declare namespace constants {
  export { constants_ADDR_BOUND as ADDR_BOUND, constants_API_VERSION as API_VERSION, constants_BaseUrl as BaseUrl, constants_IS_BROWSER as IS_BROWSER, constants_MASK_250 as MASK_250, constants_MAX_STORAGE_ITEM_SIZE as MAX_STORAGE_ITEM_SIZE, constants_NetworkName as NetworkName, constants_PRIME as PRIME, constants_RANGE_FELT as RANGE_FELT, constants_RANGE_I128 as RANGE_I128, constants_RANGE_U128 as RANGE_U128, constants_RPC_DEFAULT_VERSION as RPC_DEFAULT_VERSION, constants_RPC_NODES as RPC_NODES, constants_StarknetChainId as StarknetChainId, constants_TEXT_TO_FELT_MAX_LEN as TEXT_TO_FELT_MAX_LEN, ETransactionVersion as TRANSACTION_VERSION, constants_TransactionHashPrefix as TransactionHashPrefix, constants_UDC as UDC, constants_ZERO as ZERO, constants_feeMarginPercentage as feeMarginPercentage };
}

declare const ec_weierstrass: typeof weierstrass;
declare namespace ec {
  export { starknet as starkCurve, ec_weierstrass as weierstrass };
}

type CairoEnumRaw = {
    [key: string]: any;
};
/**
 * Class to handle Cairo custom Enum
 * @param enumContent object containing the variants and its content. Example :
 *  {Success: 234, Warning: undefined, Error: undefined}.
 *  Only one variant with a value, object, array.
 * @returns an instance representing a Cairo custom Enum.
 * @example
 * ```typescript
 * const myCairoEnum = new CairoCustomEnum( {Success: undefined, Warning: "0x7f32ea", Error: undefined})
 * ```
 */
declare class CairoCustomEnum {
    /**
     * direct readonly access to variants of the Cairo Custom Enum.
     * @returns a value of type any
     * @example
     * ```typescript
     * const successValue = myCairoEnum.variant.Success;
     */
    readonly variant: CairoEnumRaw;
    /**
     * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.
     */
    constructor(enumContent: CairoEnumRaw);
    /**
     *
     * @returns the content of the valid variant of a Cairo custom Enum.
     */
    unwrap(): any;
    /**
     *
     * @returns the name of the valid variant of a Cairo custom Enum.
     */
    activeVariant(): string;
}

declare enum CairoOptionVariant {
    Some = 0,
    None = 1
}
/**
 * Class to handle Cairo Option
 * @param variant CairoOptionVariant.Some or CairoOptionVariant.None
 * @param someContent value of type T.
 * @returns an instance representing a Cairo Option.
 * @example
 * ```typescript
 * const myOption = new CairoOption<BigNumberish>(CairoOptionVariant.Some, "0x54dda8");
 * ```
 */
declare class CairoOption<T> {
    readonly Some?: T;
    readonly None?: boolean;
    constructor(variant: CairoOptionVariant, someContent?: T);
    /**
     *
     * @returns the content of the valid variant of a Cairo custom Enum.
     *  If None, returns 'undefined'.
     */
    unwrap(): T | undefined;
    /**
     *
     * @returns true if the valid variant is 'isSome'.
     */
    isSome(): boolean;
    /**
     *
     * @returns true if the valid variant is 'isNone'.
     */
    isNone(): boolean;
}

declare enum CairoResultVariant {
    Ok = 0,
    Err = 1
}
/**
 * Class to handle Cairo Result
 * @param variant CairoResultVariant.Ok or CairoResultVariant.Err
 * @param resultContent value of type T or U.
 * @returns an instance representing a Cairo Result.
 * @example
 * ```typescript
 * const myOption = new CairoResult<BigNumberish, CustomError>(CairoResultVariant.Ok, "0x54dda8");
 * ```
 */
declare class CairoResult<T, U> {
    readonly Ok?: T;
    readonly Err?: U;
    constructor(variant: CairoResultVariant, resultContent: T | U);
    /**
     *
     * @returns the content of the valid variant of a Cairo Result.
     */
    unwrap(): T | U;
    /**
     *
     * @returns true if the valid variant is 'Ok'.
     */
    isOk(): boolean;
    /**
     *
     * @returns true if the valid variant is 'isErr'.
     */
    isErr(): boolean;
}

type CairoEnum = CairoCustomEnum | CairoOption<any> | CairoResult<any, any>;

/** ABI */
type Abi = ReadonlyArray<FunctionAbi | EventAbi | StructAbi | any>;
type AbiEntry = {
    name: string;
    type: 'felt' | 'felt*' | string;
};
type EventEntry = {
    name: string;
    type: 'felt' | 'felt*' | string;
    kind: 'key' | 'data';
};
declare enum FunctionAbiType {
    'function' = 0,
    'l1_handler' = 1,
    'constructor' = 2
}
type FunctionAbi = {
    inputs: AbiEntry[];
    name: string;
    outputs: AbiEntry[];
    stateMutability?: 'view';
    state_mutability?: string;
    type: FunctionAbiType;
};
type AbiStructs = {
    [name: string]: StructAbi;
};
type StructAbi = {
    members: (AbiEntry & {
        offset: number;
    })[];
    name: string;
    size: number;
    type: 'struct';
};
type AbiEnums = {
    [name: string]: EnumAbi;
};
type EnumAbi = {
    variants: (AbiEntry & {
        offset: number;
    })[];
    name: string;
    size: number;
    type: 'enum';
};
type AbiEvents = {
    [hash: string]: EventAbi;
};
type EventAbi = Cairo1Event | LegacyEvent;
type Cairo1Event = {
    name: string;
    members: EventEntry[];
    kind: 'struct';
    type: 'event';
};
type LegacyEvent = {
    name: string;
    type: 'event';
    data: EventEntry[];
    keys: EventEntry[];
};

/** LEGACY CONTRACT */
/**
 * format produced after compressing 'program' property
 */
type LegacyContractClass = {
    program: CompressedProgram;
    entry_points_by_type: EntryPointsByType;
    abi: Abi;
};
/**
 * format produced after compiling .cairo to .json
 */
type LegacyCompiledContract = Omit<LegacyContractClass, 'program'> & {
    program: Program;
};
/** SUBTYPES */
type Builtins = string[];
type CompressedProgram = string;
type EntryPointsByType = {
    CONSTRUCTOR: ContractEntryPointFields[];
    EXTERNAL: ContractEntryPointFields[];
    L1_HANDLER: ContractEntryPointFields[];
};
type ContractEntryPointFields = {
    selector: string;
    offset: string | number;
    builtins?: Builtins;
};
interface Program extends Record<string, any> {
    builtins: string[];
    data: string[];
}

/** SYSTEM TYPES */
type CairoAssembly = {
    prime: string;
    compiler_version: string;
    bytecode: ByteCode;
    hints: any[];
    pythonic_hints?: PythonicHints;
    bytecode_segment_lengths?: number[];
    entry_points_by_type: EntryPointsByType;
};
/** COMPILED CONTRACT */
/**
 * format produced after starknet-compile .cairo to .json
 * sierra_program is hex array
 */
type CompiledSierra = {
    sierra_program: ByteCode;
    sierra_program_debug_info?: SierraProgramDebugInfo;
    contract_class_version: string;
    entry_points_by_type: SierraEntryPointsByType;
    abi: Abi;
};
/**
 * format produced after compressing 'sierra_program', stringifies 'abi' property and omit sierra_program_debug_info
 * CompressedCompiledSierra
 */
type SierraContractClass = Omit<CompiledSierra, 'abi' | 'sierra_program_debug_info'> & {
    sierra_program: string;
    abi: string;
};
type CompiledSierraCasm = CairoAssembly;
/** SUBTYPES */
type ByteCode = string[];
type PythonicHints = [number, string[]][];
type SierraProgramDebugInfo = {
    type_names: [number, string][];
    libfunc_names: [number, string][];
    user_func_names: [number, string][];
};
type SierraEntryPointsByType = {
    CONSTRUCTOR: SierraContractEntryPointFields[];
    EXTERNAL: SierraContractEntryPointFields[];
    L1_HANDLER: SierraContractEntryPointFields[];
};
type SierraContractEntryPointFields = {
    selector: string;
    function_idx: number;
};

/**
 * format produced after compressing compiled contract
 * CompressedCompiledContract
 */
type ContractClass = LegacyContractClass | SierraContractClass;
/**
 * format produced after compile .cairo to .json
 */
type CompiledContract = LegacyCompiledContract | CompiledSierra;
/**
 * Compressed or decompressed Cairo0 or Cairo1 Contract
 */
type CairoContract = ContractClass | CompiledContract;
declare enum EntryPointType {
    EXTERNAL = "EXTERNAL",
    L1_HANDLER = "L1_HANDLER",
    CONSTRUCTOR = "CONSTRUCTOR"
}

type WeierstrassSignatureType = weierstrass.SignatureType;
type ArraySignatureType = string[];
type Signature = ArraySignatureType | WeierstrassSignatureType;
type BigNumberish = string | number | bigint;
type ByteArray = {
    data: BigNumberish[];
    pending_word: BigNumberish;
    pending_word_len: BigNumberish;
};
/**
 * Compiled calldata ready to be sent
 * decimal-string array
 */
type Calldata = string[] & {
    readonly __compiled__?: true;
};
/**
 * Represents an integer in the range [0, 2^256)
 */
interface Uint256 {
    low: BigNumberish;
    high: BigNumberish;
}
/**
 * Represents an integer in the range [0, 2^256)
 */
interface Uint512 {
    limb0: BigNumberish;
    limb1: BigNumberish;
    limb2: BigNumberish;
    limb3: BigNumberish;
}
/**
 * BigNumberish array
 * use CallData.compile() to convert to Calldata
 */
type RawCalldata = BigNumberish[];
/**
 * Hexadecimal-string array
 */
type HexCalldata = string[];
type AllowArray<T> = T | T[];
type OptionalPayload<T> = {
    payload: T;
} | T;
type RawArgs = RawArgsObject | RawArgsArray;
type RawArgsObject = {
    [inputName: string]: MultiType | MultiType[] | RawArgs;
};
type RawArgsArray = Array<MultiType | MultiType[] | RawArgs>;
type MultiType = BigNumberish | Uint256 | object | boolean | CairoEnum;
type UniversalDeployerContractPayload = {
    classHash: BigNumberish;
    salt?: string;
    unique?: boolean;
    constructorCalldata?: RawArgs;
};
type DeployAccountContractPayload = {
    classHash: string;
    constructorCalldata?: RawArgs;
    addressSalt?: BigNumberish;
    contractAddress?: string;
};
type DeployAccountContractTransaction = Omit<DeployAccountContractPayload, 'contractAddress'> & {
    signature?: Signature;
};
type DeclareContractPayload = {
    contract: CompiledContract | string;
    classHash?: string;
    casm?: CompiledSierraCasm;
    compiledClassHash?: string;
};
type CompleteDeclareContractPayload = {
    contract: CompiledContract | string;
    classHash: string;
    casm?: CompiledSierraCasm;
    compiledClassHash?: string;
};
type DeclareAndDeployContractPayload = Omit<UniversalDeployerContractPayload, 'classHash'> & DeclareContractPayload;
type DeclareContractTransaction = {
    contract: ContractClass;
    senderAddress: string;
    signature?: Signature;
    compiledClassHash?: string;
};
type CallDetails = {
    contractAddress: string;
    calldata?: RawArgs | Calldata;
    entrypoint?: string;
};
type Invocation = CallDetails & {
    signature?: Signature;
};
type Call = CallDetails & {
    entrypoint: string;
};
type CairoVersion = '0' | '1' | undefined;
type CompilerVersion = '0' | '1' | '2' | undefined;
type InvocationsDetails = {
    nonce?: BigNumberish;
    maxFee?: BigNumberish;
    version?: BigNumberish;
} & Partial<V3TransactionDetails>;
type V3TransactionDetails = {
    nonce: BigNumberish;
    version: BigNumberish;
    resourceBounds: ResourceBounds$1;
    tip: BigNumberish;
    paymasterData: BigNumberish[];
    accountDeploymentData: BigNumberish[];
    nonceDataAvailabilityMode: EDataAvailabilityMode;
    feeDataAvailabilityMode: EDataAvailabilityMode;
};
/**
 * Contain all additional details params
 */
type Details = {
    nonce: BigNumberish;
    maxFee: BigNumberish;
    version: BigNumberish;
    chainId: StarknetChainId;
};
type InvocationsDetailsWithNonce = (InvocationsDetails & {
    nonce: BigNumberish;
}) | V3TransactionDetails;
declare enum TransactionType {
    DECLARE = "DECLARE",
    DEPLOY = "DEPLOY",
    DEPLOY_ACCOUNT = "DEPLOY_ACCOUNT",
    INVOKE = "INVOKE_FUNCTION"
}
/**
 * new statuses are defined by props: finality_status and execution_status
 * to be #deprecated
 */
declare enum TransactionStatus {
    NOT_RECEIVED = "NOT_RECEIVED",
    RECEIVED = "RECEIVED",
    ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
    ACCEPTED_ON_L1 = "ACCEPTED_ON_L1",
    REJECTED = "REJECTED",
    REVERTED = "REVERTED"
}
declare enum TransactionFinalityStatus {
    NOT_RECEIVED = "NOT_RECEIVED",
    RECEIVED = "RECEIVED",
    ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
    ACCEPTED_ON_L1 = "ACCEPTED_ON_L1"
}
declare enum TransactionExecutionStatus {
    REJECTED = "REJECTED",
    REVERTED = "REVERTED",
    SUCCEEDED = "SUCCEEDED"
}
declare enum BlockStatus {
    PENDING = "PENDING",
    ACCEPTED_ON_L1 = "ACCEPTED_ON_L1",
    ACCEPTED_ON_L2 = "ACCEPTED_ON_L2",
    REJECTED = "REJECTED"
}
declare enum BlockTag {
    pending = "pending",
    latest = "latest"
}
type BlockNumber = BlockTag | null | number;
/**
 * hex string and BN are detected as block hashes
 * decimal string and number are detected as block numbers
 * null appends nothing to the request url
 */
type BlockIdentifier = BlockNumber | BigNumberish;
/**
 * items used by AccountInvocations
 */
type AccountInvocationItem = (({
    type: TransactionType.DECLARE;
} & DeclareContractTransaction) | ({
    type: TransactionType.DEPLOY_ACCOUNT;
} & DeployAccountContractTransaction) | ({
    type: TransactionType.INVOKE;
} & Invocation)) & InvocationsDetailsWithNonce;
/**
 * Complete invocations array with account details (internal type from account -> provider)
 */
type AccountInvocations = AccountInvocationItem[];
/**
 * Invocations array user provide to bulk method (simulate)
 */
type Invocations = Array<({
    type: TransactionType.DECLARE;
} & OptionalPayload<DeclareContractPayload>) | ({
    type: TransactionType.DEPLOY;
} & OptionalPayload<AllowArray<UniversalDeployerContractPayload>>) | ({
    type: TransactionType.DEPLOY_ACCOUNT;
} & OptionalPayload<DeployAccountContractPayload>) | ({
    type: TransactionType.INVOKE;
} & OptionalPayload<AllowArray<Call>>)>;
type Tupled = {
    element: any;
    type: string;
};
type Args = {
    [inputName: string]: BigNumberish | BigNumberish[] | ParsedStruct | ParsedStruct[];
};
type ParsedStruct = {
    [key: string]: BigNumberish | BigNumberish[] | ParsedStruct | Uint256;
};
type waitForTransactionOptions = {
    retryInterval?: number;
    successStates?: Array<TransactionFinalityStatus | TransactionExecutionStatus>;
    errorStates?: Array<TransactionFinalityStatus | TransactionExecutionStatus>;
};
type getSimulateTransactionOptions = {
    blockIdentifier?: BlockIdentifier;
    skipValidate?: boolean;
    skipExecute?: boolean;
    skipFeeCharge?: boolean;
};
type getContractVersionOptions = {
    blockIdentifier?: BlockIdentifier;
    compiler?: boolean;
};
type getEstimateFeeBulkOptions = {
    blockIdentifier?: BlockIdentifier;
    skipValidate?: boolean;
};
interface CallStruct {
    to: string;
    selector: string;
    calldata: string[];
}
/**
 * Represent Contract version
 */
type ContractVersion = {
    /** version of the cairo language */
    cairo: CairoVersion;
    /** version of the cairo compiler used to compile the contract */
    compiler: CompilerVersion;
};

interface ProviderOptions extends RpcProviderOptions {
}
type RpcProviderOptions = {
    nodeUrl?: string | NetworkName;
    retries?: number;
    headers?: object;
    blockIdentifier?: BlockIdentifier;
    chainId?: StarknetChainId;
    specVersion?: string;
    default?: boolean;
    waitMode?: boolean;
    feeMarginPercentage?: {
        l1BoundMaxAmount: number;
        l1BoundMaxPricePerUnit: number;
        maxFee: number;
    };
};

type Simplify<T> = {
    [K in keyof T]: T[K];
} & {};
type RequiredKeysOf<T extends object> = Exclude<{
    [K in keyof T]: T extends Record<K, T[K]> ? K : never;
}[keyof T], undefined>;
type ArrayElement<T> = T extends Array<infer U> ? U : never;
type MergeProperties<T1 extends Record<any, any>, T2 extends Record<any, any>> = {
    [K in RequiredKeysOf<T1> & RequiredKeysOf<T2>]: Merge<T1[K], T2[K]>;
} & {
    [K in keyof T1 & keyof T2]?: Merge<T1[K], T2[K]>;
} & {
    [K in Exclude<keyof T1, keyof T2>]?: T1[K];
} & {
    [K in Exclude<keyof T2, keyof T1>]?: T2[K];
};
type Merge<T1, T2> = Simplify<T1 extends Array<any> ? T2 extends Array<any> ? Array<Merge<ArrayElement<T1>, ArrayElement<T2>>> : T1 : T2 extends Array<any> ? T2 : T1 extends object ? T2 extends object ? MergeProperties<T1, T2> : T1 : T2 extends object ? T2 : T1 | T2>;
type BLOCK_HASH = Merge<BLOCK_HASH$1, BLOCK_HASH$2>;
type BLOCK_NUMBER = Merge<BLOCK_NUMBER$1, BLOCK_NUMBER$2>;
type FELT = Merge<FELT$1, FELT$2>;
type TXN_HASH = Merge<TXN_HASH$1, TXN_HASH$2>;
type PRICE_UNIT = Merge<PRICE_UNIT$1, PRICE_UNIT$2>;
type RESOURCE_PRICE = Merge<RESOURCE_PRICE$1, RESOURCE_PRICE$2>;
type SIMULATION_FLAG$1 = Merge<SIMULATION_FLAG$2, SIMULATION_FLAG$3>;
type STATE_UPDATE = Merge<STATE_UPDATE$1, STATE_UPDATE$2>;
type PENDING_STATE_UPDATE = Merge<PENDING_STATE_UPDATE$1, PENDING_STATE_UPDATE$2>;
type INVOKE_TXN_RECEIPT = Merge<INVOKE_TXN_RECEIPT$1, INVOKE_TXN_RECEIPT$2 & BlockHashAndNumber>;
type DECLARE_TXN_RECEIPT = Merge<DECLARE_TXN_RECEIPT$1, DECLARE_TXN_RECEIPT$2 & BlockHashAndNumber>;
type DEPLOY_ACCOUNT_TXN_RECEIPT = Merge<DEPLOY_ACCOUNT_TXN_RECEIPT$1, DEPLOY_ACCOUNT_TXN_RECEIPT$2 & BlockHashAndNumber>;
type L1_HANDLER_TXN_RECEIPT = Merge<L1_HANDLER_TXN_RECEIPT$1, L1_HANDLER_TXN_RECEIPT$2 & BlockHashAndNumber>;
type PENDING_INVOKE_TXN_RECEIPT = Merge<PENDING_INVOKE_TXN_RECEIPT$1, INVOKE_TXN_RECEIPT$2>;
type PENDING_DECLARE_TXN_RECEIPT = Merge<PENDING_DECLARE_TXN_RECEIPT$1, DECLARE_TXN_RECEIPT$2>;
type PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT = Merge<PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT$1, DEPLOY_ACCOUNT_TXN_RECEIPT$2>;
type PENDING_L1_HANDLER_TXN_RECEIPT = Merge<PENDING_L1_HANDLER_TXN_RECEIPT$1, L1_HANDLER_TXN_RECEIPT$2>;
type BlockWithTxHashes = Merge<BlockWithTxHashes$2, BlockWithTxHashes$1>;
type ContractClassPayload = Merge<ContractClass$2, ContractClass$1>;
type DeclaredTransaction = Merge<DeclaredTransaction$2, DeclaredTransaction$1>;
type FeeEstimate = Merge<FEE_ESTIMATE, FEE_ESTIMATE$1>;
type InvokedTransaction = Merge<InvokedTransaction$2, InvokedTransaction$1>;
type ResourceBounds = Merge<ResourceBounds$2, ResourceBounds$1>;
type SimulateTransaction = Merge<SimulateTransaction$2, SimulateTransaction$1>;
type TransactionReceipt = Merge<TransactionReceipt$2, TransactionReceipt$1>;
type TransactionWithHash = Merge<TransactionWithHash$2, TransactionWithHash$1>;

/**
 * Common interface response
 * Intersection (sequencer response  ( rpc responses))
 */

type GetBlockResponse = PendingBlock | Block$1;
type PendingBlock = {
    status: 'PENDING';
    parent_hash: BLOCK_HASH;
    timestamp: number;
    sequencer_address: FELT;
    l1_gas_price: RESOURCE_PRICE;
    starknet_version: string;
    transactions: TXN_HASH[];
};
type Block$1 = {
    status: 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';
    block_hash: BLOCK_HASH;
    parent_hash: BLOCK_HASH;
    block_number: BLOCK_NUMBER;
    new_root: FELT;
    timestamp: number;
    sequencer_address: FELT;
    l1_gas_price: RESOURCE_PRICE;
    starknet_version: string;
    transactions: TXN_HASH[];
};
interface MessageToL1 {
    to_address: string;
    payload: Array<string>;
}
type RevertedTransactionReceiptResponse = {
    type?: TransactionType | any;
    execution_status: TransactionExecutionStatus.REVERTED | any;
    finality_status: TransactionFinalityStatus | any;
    status?: TransactionStatus;
    actual_fee: string;
    block_hash?: string;
    block_number?: BlockNumber;
    transaction_hash: string;
    transaction_index?: number;
    messages_sent: Array<MessageToL1>;
    events: any[];
    revert_reason?: string;
};
type RejectedTransactionReceiptResponse = {
    status: `${TransactionStatus.REJECTED}`;
    transaction_failure_reason: {
        code: string;
        error_message: string;
    };
};
type GetTxReceiptResponseWithoutHelper = SuccessfulTransactionReceiptResponse | RevertedTransactionReceiptResponse | RejectedTransactionReceiptResponse;
type SuccessfulTransactionReceiptResponse = InvokeTransactionReceiptResponse | DeployTransactionReceiptResponse | DeclareTransactionReceiptResponse;
type GetTransactionResponse = TransactionWithHash;
type InvokeTransactionReceiptResponse = INVOKE_TXN_RECEIPT | PENDING_INVOKE_TXN_RECEIPT;
type DeclareTransactionReceiptResponse = DECLARE_TXN_RECEIPT | PENDING_DECLARE_TXN_RECEIPT;
type DeployTransactionReceiptResponse = InvokeTransactionReceiptResponse;
type DeployAccountTransactionReceiptResponse = DEPLOY_ACCOUNT_TXN_RECEIPT | PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT;
type L1HandlerTransactionReceiptResponse = L1_HANDLER_TXN_RECEIPT | PENDING_L1_HANDLER_TXN_RECEIPT;
interface EstimateFeeResponse {
    gas_consumed: bigint;
    overall_fee: bigint;
    gas_price: bigint;
    unit: PRICE_UNIT;
    suggestedMaxFee: bigint;
    resourceBounds: ResourceBounds;
    data_gas_consumed: bigint;
    data_gas_price: bigint;
}
type EstimateFeeResponseBulk = Array<EstimateFeeResponse>;
type InvokeFunctionResponse = InvokedTransaction;
type DeclareContractResponse = DeclaredTransaction;
type CallContractResponse = string[];
type Storage = FELT;
type Nonce = string;
type SimulationFlags = Array<SIMULATION_FLAG$1>;
type SimulatedTransaction = SimulateTransaction & {
    suggestedMaxFee: bigint;
    resourceBounds: ResourceBounds;
};
type SimulateTransactionResponse = SimulatedTransaction[];
type StateUpdateResponse = StateUpdate | PendingStateUpdate;
type StateUpdate = STATE_UPDATE;
type PendingStateUpdate = PENDING_STATE_UPDATE;
/**
 * Standardized type
 * Cairo0 program compressed and Cairo1 sierra_program decompressed
 * abi Abi
 * CompiledSierra without '.sierra_program_debug_info'
 */
type ContractClassResponse = LegacyContractClass | Omit<CompiledSierra, 'sierra_program_debug_info'>;

interface EstimateFee extends EstimateFeeResponse {
}
type EstimateFeeBulk = Array<EstimateFee>;
type AccountInvocationsFactoryDetails = {
    versions: Array<`${ETransactionVersion}`>;
    nonce?: BigNumberish;
    blockIdentifier?: BlockIdentifier;
    skipValidate?: boolean;
} & Partial<V3TransactionDetails>;
interface UniversalDetails {
    nonce?: BigNumberish;
    blockIdentifier?: BlockIdentifier;
    maxFee?: BigNumberish;
    tip?: BigNumberish;
    paymasterData?: BigNumberish[];
    accountDeploymentData?: BigNumberish[];
    nonceDataAvailabilityMode?: EDataAvailabilityMode;
    feeDataAvailabilityMode?: EDataAvailabilityMode;
    version?: BigNumberish;
    resourceBounds?: ResourceBounds$1;
    skipValidate?: boolean;
}
interface EstimateFeeDetails extends UniversalDetails {
}
interface DeployContractResponse {
    contract_address: string;
    transaction_hash: string;
}
type MultiDeployContractResponse = {
    contract_address: Array<string>;
    transaction_hash: string;
};
type DeployContractUDCResponse = {
    contract_address: string;
    transaction_hash: string;
    address: string;
    deployer: string;
    unique: string;
    classHash: string;
    calldata_len: string;
    calldata: Array<string>;
    salt: string;
};
type DeclareDeployUDCResponse = {
    declare: {
        class_hash: BigNumberish;
    } & Partial<DeclareTransactionReceiptResponse>;
    deploy: DeployContractUDCResponse;
};
type SimulateTransactionDetails = {
    nonce?: BigNumberish;
    blockIdentifier?: BlockIdentifier;
    skipValidate?: boolean;
    skipExecute?: boolean;
} & Partial<V3TransactionDetails>;
declare enum SIMULATION_FLAG {
    SKIP_VALIDATE = "SKIP_VALIDATE",
    SKIP_EXECUTE = "SKIP_EXECUTE"
}
type EstimateFeeAction = {
    type: TransactionType.INVOKE;
    payload: AllowArray<Call>;
} | {
    type: TransactionType.DECLARE;
    payload: DeclareContractPayload;
} | {
    type: TransactionType.DEPLOY_ACCOUNT;
    payload: DeployAccountContractPayload;
} | {
    type: TransactionType.DEPLOY;
    payload: UniversalDeployerContractPayload;
};
type StarkProfile = {
    name?: string;
    profilePicture?: string;
    discord?: string;
    twitter?: string;
    github?: string;
    proofOfPersonhood?: boolean;
};

declare enum ValidateType {
    DEPLOY = "DEPLOY",
    CALL = "CALL",
    INVOKE = "INVOKE"
}
declare enum Uint {
    u8 = "core::integer::u8",
    u16 = "core::integer::u16",
    u32 = "core::integer::u32",
    u64 = "core::integer::u64",
    u128 = "core::integer::u128",
    u256 = "core::integer::u256",// This one is struct
    u512 = "core::integer::u512"
}
declare enum Literal {
    ClassHash = "core::starknet::class_hash::ClassHash",
    ContractAddress = "core::starknet::contract_address::ContractAddress",
    Secp256k1Point = "core::starknet::secp256k1::Secp256k1Point"
}

type AsyncContractFunction<T = any> = (...args: ArgsOrCalldataWithOptions) => Promise<T>;
type ContractFunction = (...args: ArgsOrCalldataWithOptions) => any;
type Result = {
    [key: string]: any;
} | Result[] | bigint | string | boolean | CairoEnum;
type ArgsOrCalldata = RawArgsArray | [Calldata] | Calldata;
type ArgsOrCalldataWithOptions = ArgsOrCalldata & ContractOptions;
type ContractOptions = {
    blockIdentifier?: BlockIdentifier;
    parseRequest?: boolean;
    parseResponse?: boolean;
    formatResponse?: {
        [key: string]: any;
    };
    maxFee?: BigNumberish;
    nonce?: BigNumberish;
    signature?: Signature;
    addressSalt?: string;
};
type CallOptions = Pick<ContractOptions, 'blockIdentifier' | 'parseRequest' | 'parseResponse' | 'formatResponse'>;
type InvokeOptions = Pick<ContractOptions, 'maxFee' | 'nonce' | 'signature' | 'parseRequest'>;
type ParsedEvent = {
    [name: string]: ParsedStruct;
};
type ParsedEvents = Array<ParsedEvent>;

type InvocationsSignerDetails = (V2InvocationsSignerDetails | V3InvocationsSignerDetails) & {
    version: `${ETransactionVersion}`;
    skipValidate?: boolean;
};
type V2InvocationsSignerDetails = {
    walletAddress: string;
    cairoVersion: CairoVersion;
    chainId: StarknetChainId;
    nonce: BigNumberish;
    maxFee: BigNumberish;
    version: `${ETransactionVersion2}`;
};
type V3InvocationsSignerDetails = V3TransactionDetails & {
    walletAddress: string;
    cairoVersion: CairoVersion;
    chainId: StarknetChainId;
    version: `${ETransactionVersion3}`;
};
type DeclareSignerDetails = (V3DeclareSignerDetails | V2DeclareSignerDetails) & {
    version: `${ETransactionVersion}`;
};
type V2DeclareSignerDetails = Required<InvocationsDetails> & {
    classHash: string;
    compiledClassHash?: string;
    senderAddress: string;
    chainId: StarknetChainId;
    version: `${ETransactionVersion2}`;
};
type V3DeclareSignerDetails = V3TransactionDetails & {
    classHash: string;
    compiledClassHash: string;
    senderAddress: string;
    chainId: StarknetChainId;
    version: `${ETransactionVersion3}`;
};
type DeployAccountSignerDetails = V2DeployAccountSignerDetails | V3DeployAccountSignerDetails;
type V2DeployAccountSignerDetails = Required<DeployAccountContractPayload> & Required<InvocationsDetails> & {
    contractAddress: BigNumberish;
    chainId: StarknetChainId;
    version: `${ETransactionVersion2}`;
};
type V3DeployAccountSignerDetails = Required<DeployAccountContractPayload> & V3TransactionDetails & {
    contractAddress: BigNumberish;
    chainId: StarknetChainId;
    version: `${ETransactionVersion3}`;
};

type TransactionStatusReceiptSets = {
    success: SuccessfulTransactionReceiptResponse;
    reverted: RevertedTransactionReceiptResponse;
    rejected: RejectedTransactionReceiptResponse;
    error: Error;
};
type TransactionReceiptStatus = keyof TransactionStatusReceiptSets;
type TransactionReceiptValue = TransactionStatusReceiptSets[TransactionReceiptStatus];
type TransactionReceiptCallbacksDefined = {
    [key in TransactionReceiptStatus]: (response: TransactionStatusReceiptSets[key]) => void;
};
type TransactionReceiptCallbacksDefault = Partial<TransactionReceiptCallbacksDefined> & {
    _: () => void;
};
type TransactionReceiptCallbacks = TransactionReceiptCallbacksDefined | TransactionReceiptCallbacksDefault;
type TransactionReceiptUtilityInterface = {
    readonly statusReceipt: TransactionReceiptStatus;
    readonly value: TransactionReceiptValue;
    match(callbacks: TransactionReceiptCallbacks): void;
} & {
    [key in `is${Capitalize<TransactionReceiptStatus>}`]: () => boolean;
};

type index$2_Abi = Abi;
type index$2_AbiEntry = AbiEntry;
type index$2_AbiEnums = AbiEnums;
type index$2_AbiEvents = AbiEvents;
type index$2_AbiStructs = AbiStructs;
type index$2_AccountInvocationItem = AccountInvocationItem;
type index$2_AccountInvocations = AccountInvocations;
type index$2_AccountInvocationsFactoryDetails = AccountInvocationsFactoryDetails;
type index$2_AllowArray<T> = AllowArray<T>;
type index$2_Args = Args;
type index$2_ArgsOrCalldata = ArgsOrCalldata;
type index$2_ArgsOrCalldataWithOptions = ArgsOrCalldataWithOptions;
type index$2_ArraySignatureType = ArraySignatureType;
type index$2_AsyncContractFunction<T = any> = AsyncContractFunction<T>;
type index$2_BigNumberish = BigNumberish;
type index$2_BlockIdentifier = BlockIdentifier;
type index$2_BlockNumber = BlockNumber;
type index$2_BlockStatus = BlockStatus;
declare const index$2_BlockStatus: typeof BlockStatus;
type index$2_BlockTag = BlockTag;
declare const index$2_BlockTag: typeof BlockTag;
type index$2_BlockWithTxHashes = BlockWithTxHashes;
type index$2_Builtins = Builtins;
type index$2_ByteArray = ByteArray;
type index$2_ByteCode = ByteCode;
type index$2_Cairo1Event = Cairo1Event;
type index$2_CairoAssembly = CairoAssembly;
type index$2_CairoContract = CairoContract;
type index$2_CairoEnum = CairoEnum;
type index$2_CairoVersion = CairoVersion;
type index$2_Call = Call;
type index$2_CallContractResponse = CallContractResponse;
type index$2_CallDetails = CallDetails;
type index$2_CallOptions = CallOptions;
type index$2_CallStruct = CallStruct;
type index$2_Calldata = Calldata;
type index$2_CompiledContract = CompiledContract;
type index$2_CompiledSierra = CompiledSierra;
type index$2_CompiledSierraCasm = CompiledSierraCasm;
type index$2_CompilerVersion = CompilerVersion;
type index$2_CompleteDeclareContractPayload = CompleteDeclareContractPayload;
type index$2_CompressedProgram = CompressedProgram;
type index$2_ContractClass = ContractClass;
type index$2_ContractClassPayload = ContractClassPayload;
type index$2_ContractClassResponse = ContractClassResponse;
type index$2_ContractEntryPointFields = ContractEntryPointFields;
type index$2_ContractFunction = ContractFunction;
type index$2_ContractOptions = ContractOptions;
type index$2_ContractVersion = ContractVersion;
type index$2_DeclareAndDeployContractPayload = DeclareAndDeployContractPayload;
type index$2_DeclareContractPayload = DeclareContractPayload;
type index$2_DeclareContractResponse = DeclareContractResponse;
type index$2_DeclareContractTransaction = DeclareContractTransaction;
type index$2_DeclareDeployUDCResponse = DeclareDeployUDCResponse;
type index$2_DeclareSignerDetails = DeclareSignerDetails;
type index$2_DeclareTransactionReceiptResponse = DeclareTransactionReceiptResponse;
type index$2_DeployAccountContractPayload = DeployAccountContractPayload;
type index$2_DeployAccountContractTransaction = DeployAccountContractTransaction;
type index$2_DeployAccountSignerDetails = DeployAccountSignerDetails;
type index$2_DeployAccountTransactionReceiptResponse = DeployAccountTransactionReceiptResponse;
type index$2_DeployContractResponse = DeployContractResponse;
type index$2_DeployContractUDCResponse = DeployContractUDCResponse;
type index$2_DeployTransactionReceiptResponse = DeployTransactionReceiptResponse;
type index$2_Details = Details;
type index$2_EntryPointType = EntryPointType;
declare const index$2_EntryPointType: typeof EntryPointType;
type index$2_EntryPointsByType = EntryPointsByType;
type index$2_EnumAbi = EnumAbi;
type index$2_EstimateFee = EstimateFee;
type index$2_EstimateFeeAction = EstimateFeeAction;
type index$2_EstimateFeeBulk = EstimateFeeBulk;
type index$2_EstimateFeeDetails = EstimateFeeDetails;
type index$2_EstimateFeeResponse = EstimateFeeResponse;
type index$2_EstimateFeeResponseBulk = EstimateFeeResponseBulk;
type index$2_EventAbi = EventAbi;
type index$2_EventEntry = EventEntry;
type index$2_FeeEstimate = FeeEstimate;
type index$2_FunctionAbi = FunctionAbi;
type index$2_GetBlockResponse = GetBlockResponse;
type index$2_GetTransactionResponse = GetTransactionResponse;
type index$2_GetTxReceiptResponseWithoutHelper = GetTxReceiptResponseWithoutHelper;
type index$2_HexCalldata = HexCalldata;
type index$2_Invocation = Invocation;
type index$2_Invocations = Invocations;
type index$2_InvocationsDetails = InvocationsDetails;
type index$2_InvocationsDetailsWithNonce = InvocationsDetailsWithNonce;
type index$2_InvocationsSignerDetails = InvocationsSignerDetails;
type index$2_InvokeFunctionResponse = InvokeFunctionResponse;
type index$2_InvokeOptions = InvokeOptions;
type index$2_InvokeTransactionReceiptResponse = InvokeTransactionReceiptResponse;
type index$2_L1HandlerTransactionReceiptResponse = L1HandlerTransactionReceiptResponse;
type index$2_LegacyCompiledContract = LegacyCompiledContract;
type index$2_LegacyContractClass = LegacyContractClass;
type index$2_LegacyEvent = LegacyEvent;
type index$2_Literal = Literal;
declare const index$2_Literal: typeof Literal;
type index$2_MessageToL1 = MessageToL1;
type index$2_MultiDeployContractResponse = MultiDeployContractResponse;
type index$2_MultiType = MultiType;
type index$2_Nonce = Nonce;
type index$2_OptionalPayload<T> = OptionalPayload<T>;
type index$2_ParsedEvent = ParsedEvent;
type index$2_ParsedEvents = ParsedEvents;
type index$2_ParsedStruct = ParsedStruct;
type index$2_PendingBlock = PendingBlock;
type index$2_PendingStateUpdate = PendingStateUpdate;
type index$2_Program = Program;
type index$2_ProviderOptions = ProviderOptions;
type index$2_PythonicHints = PythonicHints;
type index$2_RawArgs = RawArgs;
type index$2_RawArgsArray = RawArgsArray;
type index$2_RawArgsObject = RawArgsObject;
type index$2_RawCalldata = RawCalldata;
type index$2_RejectedTransactionReceiptResponse = RejectedTransactionReceiptResponse;
type index$2_Result = Result;
type index$2_RevertedTransactionReceiptResponse = RevertedTransactionReceiptResponse;
type index$2_RpcProviderOptions = RpcProviderOptions;
type index$2_SIMULATION_FLAG = SIMULATION_FLAG;
declare const index$2_SIMULATION_FLAG: typeof SIMULATION_FLAG;
type index$2_SierraContractClass = SierraContractClass;
type index$2_SierraContractEntryPointFields = SierraContractEntryPointFields;
type index$2_SierraEntryPointsByType = SierraEntryPointsByType;
type index$2_SierraProgramDebugInfo = SierraProgramDebugInfo;
type index$2_Signature = Signature;
type index$2_SimulateTransactionDetails = SimulateTransactionDetails;
type index$2_SimulateTransactionResponse = SimulateTransactionResponse;
type index$2_SimulatedTransaction = SimulatedTransaction;
type index$2_SimulationFlags = SimulationFlags;
type index$2_StarkProfile = StarkProfile;
declare const index$2_StarknetDomain: typeof StarknetDomain;
declare const index$2_StarknetEnumType: typeof StarknetEnumType;
declare const index$2_StarknetMerkleType: typeof StarknetMerkleType;
declare const index$2_StarknetType: typeof StarknetType;
type index$2_StateUpdate = StateUpdate;
type index$2_StateUpdateResponse = StateUpdateResponse;
type index$2_Storage = Storage;
type index$2_StructAbi = StructAbi;
type index$2_SuccessfulTransactionReceiptResponse = SuccessfulTransactionReceiptResponse;
type index$2_TransactionExecutionStatus = TransactionExecutionStatus;
declare const index$2_TransactionExecutionStatus: typeof TransactionExecutionStatus;
type index$2_TransactionFinalityStatus = TransactionFinalityStatus;
declare const index$2_TransactionFinalityStatus: typeof TransactionFinalityStatus;
type index$2_TransactionReceipt = TransactionReceipt;
type index$2_TransactionReceiptCallbacks = TransactionReceiptCallbacks;
type index$2_TransactionReceiptCallbacksDefault = TransactionReceiptCallbacksDefault;
type index$2_TransactionReceiptCallbacksDefined = TransactionReceiptCallbacksDefined;
type index$2_TransactionReceiptStatus = TransactionReceiptStatus;
type index$2_TransactionReceiptUtilityInterface = TransactionReceiptUtilityInterface;
type index$2_TransactionReceiptValue = TransactionReceiptValue;
type index$2_TransactionStatus = TransactionStatus;
declare const index$2_TransactionStatus: typeof TransactionStatus;
type index$2_TransactionStatusReceiptSets = TransactionStatusReceiptSets;
type index$2_TransactionType = TransactionType;
declare const index$2_TransactionType: typeof TransactionType;
type index$2_Tupled = Tupled;
declare const index$2_TypedData: typeof TypedData;
declare const index$2_TypedDataRevision: typeof TypedDataRevision;
type index$2_Uint = Uint;
declare const index$2_Uint: typeof Uint;
type index$2_Uint256 = Uint256;
type index$2_Uint512 = Uint512;
type index$2_UniversalDeployerContractPayload = UniversalDeployerContractPayload;
type index$2_UniversalDetails = UniversalDetails;
type index$2_V2DeclareSignerDetails = V2DeclareSignerDetails;
type index$2_V2DeployAccountSignerDetails = V2DeployAccountSignerDetails;
type index$2_V2InvocationsSignerDetails = V2InvocationsSignerDetails;
type index$2_V3DeclareSignerDetails = V3DeclareSignerDetails;
type index$2_V3DeployAccountSignerDetails = V3DeployAccountSignerDetails;
type index$2_V3InvocationsSignerDetails = V3InvocationsSignerDetails;
type index$2_V3TransactionDetails = V3TransactionDetails;
type index$2_ValidateType = ValidateType;
declare const index$2_ValidateType: typeof ValidateType;
type index$2_WeierstrassSignatureType = WeierstrassSignatureType;
type index$2_getContractVersionOptions = getContractVersionOptions;
type index$2_getEstimateFeeBulkOptions = getEstimateFeeBulkOptions;
type index$2_getSimulateTransactionOptions = getSimulateTransactionOptions;
type index$2_waitForTransactionOptions = waitForTransactionOptions;
declare namespace index$2 {
  export { type index$2_Abi as Abi, type index$2_AbiEntry as AbiEntry, type index$2_AbiEnums as AbiEnums, type index$2_AbiEvents as AbiEvents, type index$2_AbiStructs as AbiStructs, type index$2_AccountInvocationItem as AccountInvocationItem, type index$2_AccountInvocations as AccountInvocations, type index$2_AccountInvocationsFactoryDetails as AccountInvocationsFactoryDetails, type index$2_AllowArray as AllowArray, type index$2_Args as Args, type index$2_ArgsOrCalldata as ArgsOrCalldata, type index$2_ArgsOrCalldataWithOptions as ArgsOrCalldataWithOptions, type index$2_ArraySignatureType as ArraySignatureType, type index$2_AsyncContractFunction as AsyncContractFunction, type index$2_BigNumberish as BigNumberish, type Block$1 as Block, type index$2_BlockIdentifier as BlockIdentifier, type index$2_BlockNumber as BlockNumber, index$2_BlockStatus as BlockStatus, index$2_BlockTag as BlockTag, type index$2_BlockWithTxHashes as BlockWithTxHashes, type index$2_Builtins as Builtins, type index$2_ByteArray as ByteArray, type index$2_ByteCode as ByteCode, type index$2_Cairo1Event as Cairo1Event, type index$2_CairoAssembly as CairoAssembly, type index$2_CairoContract as CairoContract, type index$2_CairoEnum as CairoEnum, type index$2_CairoVersion as CairoVersion, type index$2_Call as Call, type index$2_CallContractResponse as CallContractResponse, type index$2_CallDetails as CallDetails, type index$2_CallOptions as CallOptions, type index$2_CallStruct as CallStruct, type index$2_Calldata as Calldata, type index$2_CompiledContract as CompiledContract, type index$2_CompiledSierra as CompiledSierra, type index$2_CompiledSierraCasm as CompiledSierraCasm, type index$2_CompilerVersion as CompilerVersion, type index$2_CompleteDeclareContractPayload as CompleteDeclareContractPayload, type index$2_CompressedProgram as CompressedProgram, type index$2_ContractClass as ContractClass, type index$2_ContractClassPayload as ContractClassPayload, type index$2_ContractClassResponse as ContractClassResponse, type index$2_ContractEntryPointFields as ContractEntryPointFields, type index$2_ContractFunction as ContractFunction, type index$2_ContractOptions as ContractOptions, type index$2_ContractVersion as ContractVersion, type index$2_DeclareAndDeployContractPayload as DeclareAndDeployContractPayload, type index$2_DeclareContractPayload as DeclareContractPayload, type index$2_DeclareContractResponse as DeclareContractResponse, type index$2_DeclareContractTransaction as DeclareContractTransaction, type index$2_DeclareDeployUDCResponse as DeclareDeployUDCResponse, type index$2_DeclareSignerDetails as DeclareSignerDetails, type index$2_DeclareTransactionReceiptResponse as DeclareTransactionReceiptResponse, type index$2_DeployAccountContractPayload as DeployAccountContractPayload, type index$2_DeployAccountContractTransaction as DeployAccountContractTransaction, type index$2_DeployAccountSignerDetails as DeployAccountSignerDetails, type index$2_DeployAccountTransactionReceiptResponse as DeployAccountTransactionReceiptResponse, type index$2_DeployContractResponse as DeployContractResponse, type index$2_DeployContractUDCResponse as DeployContractUDCResponse, type index$2_DeployTransactionReceiptResponse as DeployTransactionReceiptResponse, type index$2_Details as Details, index$2_EntryPointType as EntryPointType, type index$2_EntryPointsByType as EntryPointsByType, type index$2_EnumAbi as EnumAbi, type index$2_EstimateFee as EstimateFee, type index$2_EstimateFeeAction as EstimateFeeAction, type index$2_EstimateFeeBulk as EstimateFeeBulk, type index$2_EstimateFeeDetails as EstimateFeeDetails, type index$2_EstimateFeeResponse as EstimateFeeResponse, type index$2_EstimateFeeResponseBulk as EstimateFeeResponseBulk, type index$2_EventAbi as EventAbi, type index$2_EventEntry as EventEntry, type index$2_FeeEstimate as FeeEstimate, type index$2_FunctionAbi as FunctionAbi, type index$2_GetBlockResponse as GetBlockResponse, type index$2_GetTransactionResponse as GetTransactionResponse, type index$2_GetTxReceiptResponseWithoutHelper as GetTxReceiptResponseWithoutHelper, type index$2_HexCalldata as HexCalldata, type index$2_Invocation as Invocation, type index$2_Invocations as Invocations, type index$2_InvocationsDetails as InvocationsDetails, type index$2_InvocationsDetailsWithNonce as InvocationsDetailsWithNonce, type index$2_InvocationsSignerDetails as InvocationsSignerDetails, type index$2_InvokeFunctionResponse as InvokeFunctionResponse, type index$2_InvokeOptions as InvokeOptions, type index$2_InvokeTransactionReceiptResponse as InvokeTransactionReceiptResponse, type index$2_L1HandlerTransactionReceiptResponse as L1HandlerTransactionReceiptResponse, type index$2_LegacyCompiledContract as LegacyCompiledContract, type index$2_LegacyContractClass as LegacyContractClass, type index$2_LegacyEvent as LegacyEvent, index$2_Literal as Literal, type index$2_MessageToL1 as MessageToL1, type index$2_MultiDeployContractResponse as MultiDeployContractResponse, type index$2_MultiType as MultiType, type index$2_Nonce as Nonce, type index$2_OptionalPayload as OptionalPayload, type index$2_ParsedEvent as ParsedEvent, type index$2_ParsedEvents as ParsedEvents, type index$2_ParsedStruct as ParsedStruct, type index$2_PendingBlock as PendingBlock, type index$2_PendingStateUpdate as PendingStateUpdate, type index$2_Program as Program, type index$2_ProviderOptions as ProviderOptions, type index$2_PythonicHints as PythonicHints, index$3 as RPC, type index$2_RawArgs as RawArgs, type index$2_RawArgsArray as RawArgsArray, type index$2_RawArgsObject as RawArgsObject, type index$2_RawCalldata as RawCalldata, type index$2_RejectedTransactionReceiptResponse as RejectedTransactionReceiptResponse, type index$2_Result as Result, type index$2_RevertedTransactionReceiptResponse as RevertedTransactionReceiptResponse, type index$2_RpcProviderOptions as RpcProviderOptions, index$2_SIMULATION_FLAG as SIMULATION_FLAG, type index$2_SierraContractClass as SierraContractClass, type index$2_SierraContractEntryPointFields as SierraContractEntryPointFields, type index$2_SierraEntryPointsByType as SierraEntryPointsByType, type index$2_SierraProgramDebugInfo as SierraProgramDebugInfo, type index$2_Signature as Signature, type index$2_SimulateTransactionDetails as SimulateTransactionDetails, type index$2_SimulateTransactionResponse as SimulateTransactionResponse, type index$2_SimulatedTransaction as SimulatedTransaction, type index$2_SimulationFlags as SimulationFlags, type index$2_StarkProfile as StarkProfile, index$2_StarknetDomain as StarknetDomain, index$2_StarknetEnumType as StarknetEnumType, index$2_StarknetMerkleType as StarknetMerkleType, index$2_StarknetType as StarknetType, type index$2_StateUpdate as StateUpdate, type index$2_StateUpdateResponse as StateUpdateResponse, type index$2_Storage as Storage, type index$2_StructAbi as StructAbi, type index$2_SuccessfulTransactionReceiptResponse as SuccessfulTransactionReceiptResponse, index$2_TransactionExecutionStatus as TransactionExecutionStatus, index$2_TransactionFinalityStatus as TransactionFinalityStatus, type index$2_TransactionReceipt as TransactionReceipt, type index$2_TransactionReceiptCallbacks as TransactionReceiptCallbacks, type index$2_TransactionReceiptCallbacksDefault as TransactionReceiptCallbacksDefault, type index$2_TransactionReceiptCallbacksDefined as TransactionReceiptCallbacksDefined, type index$2_TransactionReceiptStatus as TransactionReceiptStatus, type index$2_TransactionReceiptUtilityInterface as TransactionReceiptUtilityInterface, type index$2_TransactionReceiptValue as TransactionReceiptValue, index$2_TransactionStatus as TransactionStatus, type index$2_TransactionStatusReceiptSets as TransactionStatusReceiptSets, index$2_TransactionType as TransactionType, type index$2_Tupled as Tupled, index$2_TypedData as TypedData, index$2_TypedDataRevision as TypedDataRevision, index$2_Uint as Uint, type index$2_Uint256 as Uint256, type index$2_Uint512 as Uint512, type index$2_UniversalDeployerContractPayload as UniversalDeployerContractPayload, type index$2_UniversalDetails as UniversalDetails, type index$2_V2DeclareSignerDetails as V2DeclareSignerDetails, type index$2_V2DeployAccountSignerDetails as V2DeployAccountSignerDetails, type index$2_V2InvocationsSignerDetails as V2InvocationsSignerDetails, type index$2_V3DeclareSignerDetails as V3DeclareSignerDetails, type index$2_V3DeployAccountSignerDetails as V3DeployAccountSignerDetails, type index$2_V3InvocationsSignerDetails as V3InvocationsSignerDetails, type index$2_V3TransactionDetails as V3TransactionDetails, index$2_ValidateType as ValidateType, type index$2_WeierstrassSignatureType as WeierstrassSignatureType, type index$2_getContractVersionOptions as getContractVersionOptions, type index$2_getEstimateFeeBulkOptions as getEstimateFeeBulkOptions, type index$2_getSimulateTransactionOptions as getSimulateTransactionOptions, type index$2_waitForTransactionOptions as waitForTransactionOptions };
}

declare class RpcChannel$1 {
    nodeUrl: string;
    headers: object;
    readonly retries: number;
    requestId: number;
    readonly blockIdentifier: BlockIdentifier;
    private chainId?;
    private specVersion?;
    readonly waitMode: Boolean;
    constructor(optionsOrProvider?: RpcProviderOptions);
    setChainId(chainId: StarknetChainId): void;
    fetch(method: string, params?: object, id?: string | number): Promise<Response>;
    protected errorHandler(method: string, params: any, rpcError?: Error$1, otherError?: any): void;
    protected fetchEndpoint<T extends keyof Methods$1>(method: T, params?: Methods$1[T]['params']): Promise<Methods$1[T]['result']>;
    getChainId(): Promise<StarknetChainId>;
    getSpecVersion(): Promise<string>;
    getNonceForAddress(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<string>;
    /**
     * Get the most recent accepted block hash and number
     */
    getBlockLatestAccepted(): Promise<BlockHashAndNumber$1>;
    /**
     * Get the most recent accepted block number
     * redundant use getBlockLatestAccepted();
     * @returns Number of the latest block
     */
    getBlockNumber(): Promise<number>;
    getBlockWithTxHashes(blockIdentifier?: BlockIdentifier): Promise<BlockWithTxHashes$2>;
    getBlockWithTxs(blockIdentifier?: BlockIdentifier): Promise<BlockWithTxs$1>;
    getBlockStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdate$2>;
    getBlockTransactionsTraces(blockIdentifier?: BlockIdentifier): Promise<BlockTransactionsTraces$1>;
    getBlockTransactionCount(blockIdentifier?: BlockIdentifier): Promise<number>;
    getTransactionByHash(txHash: BigNumberish): Promise<TransactionWithHash$2>;
    getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number): Promise<TransactionWithHash$2>;
    getTransactionReceipt(txHash: BigNumberish): Promise<TransactionReceipt$2>;
    getTransactionTrace(txHash: BigNumberish): Promise<TRANSACTION_TRACE>;
    /**
     * Get the status of a transaction
     */
    getTransactionStatus(transactionHash: BigNumberish): Promise<TransactionStatus$2>;
    /**
     * @param invocations AccountInvocations
     * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>
     * - blockIdentifier<br/>
     * - skipValidate (default false)<br/>
     * - skipFeeCharge (default true)<br/>
     */
    simulateTransaction(invocations: AccountInvocations, { blockIdentifier, skipValidate, skipFeeCharge, }?: getSimulateTransactionOptions): Promise<SimulateTransactionResponse$2>;
    waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions): Promise<TXN_RECEIPT>;
    getStorageAt(contractAddress: BigNumberish, key: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<string>;
    getClassHashAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<string>;
    getClass(classHash: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<ContractClass$2>;
    getClassAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<ContractClass$2>;
    getEstimateFee(invocations: AccountInvocations, { blockIdentifier, skipValidate }: getEstimateFeeBulkOptions): Promise<FEE_ESTIMATE[]>;
    invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce): Promise<InvokedTransaction$2>;
    declare({ contract, signature, senderAddress, compiledClassHash }: DeclareContractTransaction, details: InvocationsDetailsWithNonce): Promise<TXN_RECEIPT | DeclaredTransaction$2>;
    deployAccount({ classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce): Promise<TXN_RECEIPT | DeployedAccountTransaction$1>;
    callContract(call: Call, blockIdentifier?: BlockIdentifier): Promise<string[]>;
    /**
     * NEW: Estimate the fee for a message from L1
     * @param message Message From L1
     */
    estimateMessageFee(message: L1Message$1, blockIdentifier?: BlockIdentifier): Promise<FEE_ESTIMATE>;
    /**
     * Returns an object about the sync status, or false if the node is not synching
     * @returns Object with the stats data
     */
    getSyncingStats(): Promise<Syncing$1>;
    /**
     * Returns all events matching the given filter
     * @returns events and the pagination of the events
     */
    getEvents(eventFilter: EventFilter$1): Promise<EVENTS_CHUNK>;
    buildTransaction(invocation: AccountInvocationItem, versionType?: 'fee' | 'transaction'): BaseTransaction$1;
}

declare namespace rpc_0_6 {
  export { RpcChannel$1 as RpcChannel };
}

declare class RpcChannel {
    nodeUrl: string;
    headers: object;
    readonly retries: number;
    requestId: number;
    readonly blockIdentifier: BlockIdentifier;
    private chainId?;
    private specVersion?;
    readonly waitMode: Boolean;
    constructor(optionsOrProvider?: RpcProviderOptions);
    setChainId(chainId: StarknetChainId): void;
    fetch(method: string, params?: object, id?: string | number): Promise<Response>;
    protected errorHandler(method: string, params: any, rpcError?: Error$1, otherError?: any): void;
    protected fetchEndpoint<T extends keyof Methods>(method: T, params?: Methods[T]['params']): Promise<Methods[T]['result']>;
    getChainId(): Promise<StarknetChainId>;
    getSpecVersion(): Promise<string>;
    getNonceForAddress(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<string>;
    /**
     * Get the most recent accepted block hash and number
     */
    getBlockLatestAccepted(): Promise<BlockHashAndNumber>;
    /**
     * Get the most recent accepted block number
     * redundant use getBlockLatestAccepted();
     * @returns Number of the latest block
     */
    getBlockNumber(): Promise<number>;
    getBlockWithTxHashes(blockIdentifier?: BlockIdentifier): Promise<BlockWithTxHashes$1>;
    getBlockWithTxs(blockIdentifier?: BlockIdentifier): Promise<BlockWithTxs>;
    getBlockWithReceipts(blockIdentifier?: BlockIdentifier): Promise<BlockWithTxReceipts>;
    getBlockStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdate$1>;
    getBlockTransactionsTraces(blockIdentifier?: BlockIdentifier): Promise<BlockTransactionsTraces>;
    getBlockTransactionCount(blockIdentifier?: BlockIdentifier): Promise<number>;
    getTransactionByHash(txHash: BigNumberish): Promise<TransactionWithHash$1>;
    getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number): Promise<TransactionWithHash$1>;
    getTransactionReceipt(txHash: BigNumberish): Promise<TXN_RECEIPT_WITH_BLOCK_INFO>;
    getTransactionTrace(txHash: BigNumberish): Promise<TRANSACTION_TRACE$1>;
    /**
     * Get the status of a transaction
     */
    getTransactionStatus(transactionHash: BigNumberish): Promise<TransactionStatus$1>;
    /**
     * @param invocations AccountInvocations
     * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>
     * - blockIdentifier<br/>
     * - skipValidate (default false)<br/>
     * - skipFeeCharge (default true)<br/>
     */
    simulateTransaction(invocations: AccountInvocations, { blockIdentifier, skipValidate, skipFeeCharge, }?: getSimulateTransactionOptions): Promise<SimulateTransactionResponse$1>;
    waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions): Promise<TXN_RECEIPT$1>;
    getStorageAt(contractAddress: BigNumberish, key: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<string>;
    getClassHashAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<string>;
    getClass(classHash: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<ContractClass$1>;
    getClassAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<ContractClass$1>;
    getEstimateFee(invocations: AccountInvocations, { blockIdentifier, skipValidate }: getEstimateFeeBulkOptions): Promise<FEE_ESTIMATE$1[]>;
    invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce): Promise<InvokedTransaction$1>;
    declare({ contract, signature, senderAddress, compiledClassHash }: DeclareContractTransaction, details: InvocationsDetailsWithNonce): Promise<TXN_RECEIPT$1 | DeclaredTransaction$1>;
    deployAccount({ classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce): Promise<TXN_RECEIPT$1 | DeployedAccountTransaction>;
    callContract(call: Call, blockIdentifier?: BlockIdentifier): Promise<string[]>;
    /**
     * NEW: Estimate the fee for a message from L1
     * @param message Message From L1
     */
    estimateMessageFee(message: L1Message, blockIdentifier?: BlockIdentifier): Promise<FEE_ESTIMATE$1>;
    /**
     * Returns an object about the sync status, or false if the node is not synching
     * @returns Object with the stats data
     */
    getSyncingStats(): Promise<Syncing>;
    /**
     * Returns all events matching the given filter
     * @returns events and the pagination of the events
     */
    getEvents(eventFilter: EventFilter): Promise<EVENTS_CHUNK$1>;
    buildTransaction(invocation: AccountInvocationItem, versionType?: 'fee' | 'transaction'): BaseTransaction;
}

type rpc_0_7_RpcChannel = RpcChannel;
declare const rpc_0_7_RpcChannel: typeof RpcChannel;
declare namespace rpc_0_7 {
  export { rpc_0_7_RpcChannel as RpcChannel };
}

/**
 * Utility that analyses transaction receipt response and provides helpers to process it
 * @example
 * ```typescript
 * const responseTx = new ReceiptTx(receipt);
 * responseTx.match({
 *   success: (txR: SuccessfulTransactionReceiptResponse) => { },
 *   rejected: (txR: RejectedTransactionReceiptResponse) => { },
 *   reverted: (txR: RevertedTransactionReceiptResponse) => { },
 *   error: (err: Error) => { },
 * });
 * responseTx.match({
 *   success: (txR: SuccessfulTransactionReceiptResponse) => { },
 *   _: () => { },
 * }
 * ```
 */
declare class ReceiptTx implements TransactionReceiptUtilityInterface {
    readonly statusReceipt: TransactionReceiptStatus;
    readonly value: TransactionReceiptValue;
    constructor(receipt: GetTxReceiptResponseWithoutHelper);
    match(callbacks: TransactionReceiptCallbacks): void;
    isSuccess(): this is SuccessfulTransactionReceiptResponse;
    isReverted(): this is RevertedTransactionReceiptResponse;
    isRejected(): this is RejectedTransactionReceiptResponse;
    isError(): boolean;
    static isSuccess(transactionReceipt: GetTxReceiptResponseWithoutHelper): transactionReceipt is SuccessfulTransactionReceiptResponse;
    static isReverted(transactionReceipt: GetTxReceiptResponseWithoutHelper): transactionReceipt is RevertedTransactionReceiptResponse;
    static isRejected(transactionReceipt: GetTxReceiptResponseWithoutHelper): transactionReceipt is RejectedTransactionReceiptResponse;
}
type GetTransactionReceiptResponse = GetTxReceiptResponseWithoutHelper & ReceiptTx;

declare abstract class ProviderInterface {
    abstract channel: RpcChannel | RpcChannel$1;
    /**
     * Gets the Starknet chain Id
     *
     * @returns the chain Id
     */
    abstract getChainId(): Promise<StarknetChainId>;
    /**
     * Calls a function on the Starknet contract.
     *
     * @param call transaction to be called
     * @param blockIdentifier block identifier
     * @returns the result of the function on the smart contract.
     */
    abstract callContract(call: Call, blockIdentifier?: BlockIdentifier): Promise<CallContractResponse>;
    /**
     * Gets the block information
     *
     * @param blockIdentifier block identifier
     * @returns the block object
     */
    abstract getBlock(): Promise<PendingBlock>;
    abstract getBlock(blockIdentifier: 'pending'): Promise<PendingBlock>;
    abstract getBlock(blockIdentifier: 'latest'): Promise<Block$1>;
    abstract getBlock(blockIdentifier: BlockIdentifier): Promise<GetBlockResponse>;
    /**
     * Gets the contract class of the deployed contract.
     *
     * @param contractAddress - contract address
     * @param blockIdentifier - block identifier
     * @returns Contract class of compiled contract
     */
    abstract getClassAt(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<ContractClassResponse>;
    /**
     * Returns the contract class hash in the given block for the contract deployed at the given address
     *
     * @param contractAddress - contract address
     * @param blockIdentifier - block identifier
     * @returns Class hash
     */
    abstract getClassHashAt(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<string>;
    /**
     * Returns the contract class deployed under the given class hash.
     *
     * @param classHash - class hash
     * @returns Contract class of compiled contract
     */
    abstract getClassByHash(classHash: string): Promise<ContractClassResponse>;
    /**
     * Returns the nonce associated with the given address in the given block
     *
     * @param contractAddress - contract address
     * @returns the hex nonce
     */
    abstract getNonceForAddress(contractAddress: string, blockIdentifier?: BlockIdentifier): Promise<Nonce>;
    /**
     * Get the value of the storage (contract's variable) at the given address and key
     *
     * @param contractAddress
     * @param key - from getStorageVarAddress('<STORAGE_VARIABLE_NAME>') (WIP)
     * @param blockIdentifier - block identifier
     * @returns the value of the storage variable
     */
    abstract getStorageAt(contractAddress: string, key: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<Storage>;
    /**
     * Gets the transaction information from a tx id.
     *
     * @param txHash
     * @returns the transaction object \{ transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? \}
     */
    abstract getTransaction(transactionHash: BigNumberish): Promise<GetTransactionResponse>;
    /**
     * Gets the transaction receipt from a tx hash.
     *
     * @param txHash
     * @returns the transaction receipt object
     */
    abstract getTransactionReceipt(transactionHash: BigNumberish): Promise<GetTransactionReceiptResponse>;
    /**
     * Deploys a given compiled Account contract (json) to starknet
     *
     * @param payload payload to be deployed containing:
     * - compiled contract code
     * - constructor calldata
     * - address salt
     * @returns a confirmation of sending a transaction on the starknet contract
     */
    abstract deployAccountContract(payload: DeployAccountContractPayload, details: InvocationsDetailsWithNonce): Promise<DeployContractResponse>;
    /**
     * Invokes a function on starknet
     * @deprecated This method won't be supported as soon as fees are mandatory. Should not be used outside of Account class
     *
     * @param invocation the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param details - optional details containing:
     * - nonce - optional nonce
     * - version - optional version
     * - maxFee - optional maxFee
     * @returns response from addTransaction
     */
    abstract invokeFunction(invocation: Invocation, details: InvocationsDetailsWithNonce): Promise<InvokeFunctionResponse>;
    /**
     * Declares a given compiled contract (json) to starknet
     * @param transaction transaction payload to be deployed containing:
     * - compiled contract code
     * - sender address
     * - signature
     * @param details Invocation Details containing:
     * - nonce
     * - optional version
     * - optional maxFee
     * @returns a confirmation of sending a transaction on the starknet contract
     */
    abstract declareContract(transaction: DeclareContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeclareContractResponse>;
    /**
     * Estimates the fee for a given INVOKE transaction
     * @deprecated Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class
     *
     * @param invocation the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param details - optional details containing:
     * - nonce - optional nonce
     * - version - optional version
     * @param blockIdentifier - (optional) block identifier
     * @param skipValidate - (optional) skip cairo __validate__ method
     * @returns the estimated fee
     */
    abstract getEstimateFee(invocation: Invocation, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier, skipValidate?: boolean): Promise<EstimateFeeResponse>;
    /**
     * Estimates the fee for a given INVOKE transaction
     *
     * @param invocation the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param details - optional details containing:
     * - nonce - optional nonce
     * - version - optional version
     * @param blockIdentifier - (optional) block identifier
     * @param skipValidate - (optional) skip cairo __validate__ method
     * @returns the estimated fee
     */
    abstract getInvokeEstimateFee(invocation: Invocation, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier, skipValidate?: boolean): Promise<EstimateFeeResponse>;
    /**
     * Estimates the fee for a given DECLARE transaction
     *
     * @param transaction transaction payload to be declared containing:
     * - compiled contract code
     * - sender address
     * - signature - (defaults to []) the signature
     * @param details - optional details containing:
     * - nonce
     * - version - optional version
     * - optional maxFee
     * @param blockIdentifier - (optional) block identifier
     * @param skipValidate - (optional) skip cairo __validate__ method
     * @returns the estimated fee
     */
    abstract getDeclareEstimateFee(transaction: DeclareContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier, skipValidate?: boolean): Promise<EstimateFeeResponse>;
    /**
     * Estimates the fee for a given DEPLOY_ACCOUNT transaction
     *
     * @param transaction transaction payload to be deployed containing:
     * - classHash
     * - constructorCalldata
     * - addressSalt
     * - signature - (defaults to []) the signature
     * @param details - optional details containing:
     * - nonce
     * - version - optional version
     * - optional maxFee
     * @param blockIdentifier - (optional) block identifier
     * @param skipValidate - (optional) skip cairo __validate__ method
     * @returns the estimated fee
     */
    abstract getDeployAccountEstimateFee(transaction: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier, skipValidate?: boolean): Promise<EstimateFeeResponse>;
    /**
     * Estimates the fee for a list of INVOKE transaction
     *
     * @param invocations AccountInvocations - Complete invocations array with account details
     * @param options getEstimateFeeBulkOptions
     * - (optional) blockIdentifier - BlockIdentifier
     * @returns the estimated fee
     */
    abstract getEstimateFeeBulk(invocations: AccountInvocations, options?: getEstimateFeeBulkOptions): Promise<EstimateFeeResponseBulk>;
    /**
     * Wait for the transaction to be accepted
     * @param txHash - transaction hash
     * @param options waitForTransactionOptions
     * - (optional) retryInterval: number | undefined;
     * - (optional) successStates: TransactionStatus[] | undefined;
     * @return GetTransactionReceiptResponse
     */
    abstract waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions): Promise<GetTransactionReceiptResponse>;
    /**
     * Simulates the transaction and returns the transaction trace and estimated fee.
     *
     * @param invocations AccountInvocations - Complete invocations array with account details
     * @param options - getSimulateTransactionOptions
     *  - (optional) blockIdentifier - block identifier
     *  - (optional) skipValidate - skip cairo __validate__ method
     *  - (optional) skipExecute - skip cairo __execute__ method
     * @returns an array of transaction trace and estimated fee
     */
    abstract getSimulateTransaction(invocations: AccountInvocations, options?: getSimulateTransactionOptions): Promise<SimulateTransactionResponse>;
    /**
     * Gets the state changes in a specific block (result of executing the requested block)
     *
     * @param blockIdentifier - block identifier
     * @returns StateUpdateResponse
     */
    abstract getStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;
    /**
     * Gets the contract version from the provided address
     * @param contractAddress string
     * @param classHash undefined
     * @param options - getContractVersionOptions
     *   - (optional) compiler - (default true) extract compiler version using type tactic from abi
     *   - (optional) blockIdentifier - block identifier
     */
    abstract getContractVersion(contractAddress: string, classHash?: undefined, options?: getContractVersionOptions): Promise<ContractVersion>;
    /**
     * Gets the contract version from the provided address
     * @param contractAddress undefined
     * @param classHash
     * @param options - getContractVersionOptions
     *   - (optional) compiler - (default true) extract compiler version using type tactic from abi
     *   - (optional) blockIdentifier - block identifier
     */
    abstract getContractVersion(contractAddress: undefined, classHash: string, options?: getContractVersionOptions): Promise<ContractVersion>;
}

declare class RpcProvider$1 implements ProviderInterface {
    private responseParser;
    channel: RpcChannel | RpcChannel$1;
    constructor(optionsOrProvider?: RpcProviderOptions | ProviderInterface | RpcProvider$1);
    fetch(method: string, params?: object, id?: string | number): Promise<Response>;
    getChainId(): Promise<StarknetChainId>;
    getSpecVersion(): Promise<string>;
    getNonceForAddress(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<string>;
    getBlock(): Promise<PendingBlock>;
    getBlock(blockIdentifier: 'pending'): Promise<PendingBlock>;
    getBlock(blockIdentifier: 'latest'): Promise<Block$1>;
    getBlock(blockIdentifier?: BlockIdentifier): Promise<GetBlockResponse>;
    /**
     * Get the most recent accepted block hash and number
     */
    getBlockLatestAccepted(): Promise<BlockHashAndNumber$1>;
    /**
     * Get the most recent accepted block number
     * redundant use getBlockLatestAccepted();
     * @returns Number of the latest block
     */
    getBlockNumber(): Promise<number>;
    getBlockWithTxHashes(blockIdentifier?: BlockIdentifier): Promise<BlockWithTxHashes$2>;
    getBlockWithTxs(blockIdentifier?: BlockIdentifier): Promise<BlockWithTxs$1>;
    getBlockWithReceipts(blockIdentifier?: BlockIdentifier): Promise<BlockWithTxReceipts>;
    getStateUpdate: {
        (): Promise<PendingStateUpdate>;
        (blockIdentifier: 'pending'): Promise<PendingStateUpdate>;
        (blockIdentifier: 'latest'): Promise<StateUpdate>;
        (blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;
    };
    getBlockStateUpdate(): Promise<PendingStateUpdate>;
    getBlockStateUpdate(blockIdentifier: 'pending'): Promise<PendingStateUpdate>;
    getBlockStateUpdate(blockIdentifier: 'latest'): Promise<StateUpdate>;
    getBlockStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;
    getBlockTransactionsTraces(blockIdentifier?: BlockIdentifier): Promise<BlockTransactionsTraces$1>;
    getBlockTransactionCount(blockIdentifier?: BlockIdentifier): Promise<number>;
    /**
     * Return transactions from pending block
     * @deprecated Instead use getBlock(BlockTag.pending); (will be removed in next minor version)
     * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);
     */
    getPendingTransactions(): Promise<TransactionWithHash$2[]>;
    getTransaction(txHash: BigNumberish): Promise<TransactionWithHash$2>;
    getTransactionByHash(txHash: BigNumberish): Promise<TransactionWithHash$2>;
    getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number): Promise<TransactionWithHash$2>;
    getTransactionReceipt(txHash: BigNumberish): Promise<GetTransactionReceiptResponse>;
    getTransactionTrace(txHash: BigNumberish): Promise<TRANSACTION_TRACE>;
    /**
     * Get the status of a transaction
     */
    getTransactionStatus(transactionHash: BigNumberish): Promise<TransactionStatus$2>;
    /**
     * @param invocations AccountInvocations
     * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>
     * - blockIdentifier<br/>
     * - skipValidate (default false)<br/>
     * - skipFeeCharge (default true)<br/>
     */
    getSimulateTransaction(invocations: AccountInvocations, options?: getSimulateTransactionOptions): Promise<SimulateTransactionResponse>;
    waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions): Promise<GetTransactionReceiptResponse>;
    getStorageAt(contractAddress: BigNumberish, key: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<string>;
    getClassHashAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<string>;
    getClassByHash(classHash: BigNumberish): Promise<LegacyContractClass | Omit<CompiledSierra, "sierra_program_debug_info">>;
    getClass(classHash: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<LegacyContractClass | Omit<CompiledSierra, "sierra_program_debug_info">>;
    getClassAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier): Promise<LegacyContractClass | Omit<CompiledSierra, "sierra_program_debug_info">>;
    getContractVersion(contractAddress: BigNumberish, classHash?: undefined, options?: getContractVersionOptions): Promise<ContractVersion>;
    getContractVersion(contractAddress: undefined, classHash: BigNumberish, options?: getContractVersionOptions): Promise<ContractVersion>;
    /**
     * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)
     */
    getEstimateFee(invocation: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier, skipValidate?: boolean): Promise<EstimateFeeResponse>;
    getInvokeEstimateFee(invocation: Invocation, invocationDetails: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier, skipValidate?: boolean): Promise<EstimateFeeResponse>;
    getDeclareEstimateFee(invocation: DeclareContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier, skipValidate?: boolean): Promise<EstimateFeeResponse>;
    getDeployAccountEstimateFee(invocation: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce, blockIdentifier?: BlockIdentifier, skipValidate?: boolean): Promise<EstimateFeeResponse>;
    getEstimateFeeBulk(invocations: AccountInvocations, options: getEstimateFeeBulkOptions): Promise<EstimateFeeResponseBulk>;
    invokeFunction(functionInvocation: Invocation, details: InvocationsDetailsWithNonce): Promise<InvokedTransaction$1>;
    declareContract(transaction: DeclareContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeclaredTransaction$1>;
    deployAccountContract(transaction: DeployAccountContractTransaction, details: InvocationsDetailsWithNonce): Promise<DeployedAccountTransaction>;
    callContract(call: Call, blockIdentifier?: BlockIdentifier): Promise<string[]>;
    /**
     * NEW: Estimate the fee for a message from L1
     * @param message Message From L1
     */
    estimateMessageFee(message: L1Message, blockIdentifier?: BlockIdentifier): Promise<FEE_ESTIMATE>;
    /**
     * Returns an object about the sync status, or false if the node is not synching
     * @returns Object with the stats data
     */
    getSyncingStats(): Promise<Syncing$1>;
    /**
     * Returns all events matching the given filter
     * @returns events and the pagination of the events
     */
    getEvents(eventFilter: EventFilter): Promise<EVENTS_CHUNK>;
}

declare class StarknetId {
    getStarkName(address: BigNumberish, StarknetIdContract?: string): Promise<string>;
    getAddressFromStarkName(name: string, StarknetIdContract?: string): Promise<string>;
    getStarkProfile(address: BigNumberish, StarknetIdContract?: string, StarknetIdIdentityContract?: string, StarknetIdVerifierContract?: string, StarknetIdPfpContract?: string, StarknetIdPopContract?: string, StarknetIdMulticallContract?: string): Promise<StarkProfile>;
    static getStarkName(provider: ProviderInterface, address: BigNumberish, StarknetIdContract?: string): Promise<string>;
    static getAddressFromStarkName(provider: ProviderInterface, name: string, StarknetIdContract?: string): Promise<string>;
    static getStarkProfile(provider: ProviderInterface, address: BigNumberish, StarknetIdContract?: string, StarknetIdIdentityContract?: string, StarknetIdVerifierContract?: string, StarknetIdPfpContract?: string, StarknetIdPopContract?: string, StarknetIdMulticallContract?: string): Promise<StarkProfile>;
}

declare const RpcProvider_base: ts_mixer_dist_types_types.Class<any[], RpcProvider$1 & StarknetId, typeof RpcProvider$1 & typeof StarknetId>;
declare class RpcProvider extends RpcProvider_base {
}

declare function fixStack(target: Error, fn?: Function): void;
declare function fixProto(target: Error, prototype: {}): void;
declare class CustomError extends Error {
    name: string;
    constructor(message?: string);
}
declare class LibraryError extends CustomError {
}
declare class GatewayError extends LibraryError {
    errorCode: string;
    constructor(message: string, errorCode: string);
}
declare class HttpError extends LibraryError {
    errorCode: number;
    constructor(message: string, errorCode: number);
}

declare const defaultProvider: RpcProvider$1;

declare abstract class SignerInterface {
    /**
     * Method to get the public key of the signer
     *
     * @returns format: hex-string
     */
    abstract getPubKey(): Promise<string>;
    /**
     * Signs a JSON object for off-chain usage with the Starknet private key and returns the signature
     * This adds a message prefix so it can't be interchanged with transactions
     *
     * @param typedData - JSON object to be signed
     * @param accountAddress
     */
    abstract signMessage(typedData: TypedData, accountAddress: string): Promise<Signature>;
    /**
     * Signs transactions with the Starknet private key and returns the signature
     *
     * @param transactions - Array of Call objects, each including:<br/>
     *  - contractAddress<br/>
     *  - entrypoint<br/>
     *  - calldata<br/>
     * @param transactionsDetail - InvocationsSignerDetails object with:<br/>
     *  - walletAddress<br/>
     *  - chainId<br/>
     *  - cairoVersion<br/>
     *  - maxFee<br/>
     *  - version<br/>
     *  - nonce<br/>
     */
    abstract signTransaction(transactions: Call[], transactionsDetail: InvocationsSignerDetails): Promise<Signature>;
    /**
     * Signs a DEPLOY_ACCOUNT transaction with the Starknet private key and returns the signature
     *
     * @param transaction<br/>
     * - contractAddress<br/>
     * - chainId<br/>
     * - classHash<br/>
     * - constructorCalldata<br/>
     * - addressSalt<br/>
     * - maxFee<br/>
     * - version<br/>
     * - nonce<br/>
     */
    abstract signDeployAccountTransaction(transaction: DeployAccountSignerDetails): Promise<Signature>;
    /**
     * Signs a DECLARE transaction with the Starknet private key and returns the signature
     *
     * @param transaction<br/>
     * - classHash<br/>
     * - compiledClassHash? - used for Cairo1<br/>
     * - senderAddress<br/>
     * - chainId<br/>
     * - maxFee<br/>
     * - version<br/>
     * - nonce<br/>
     */
    abstract signDeclareTransaction(transaction: DeclareSignerDetails): Promise<Signature>;
}

declare class Signer implements SignerInterface {
    protected pk: Uint8Array | string;
    constructor(pk?: Uint8Array | string);
    getPubKey(): Promise<string>;
    signMessage(typedData: TypedData, accountAddress: string): Promise<Signature>;
    signTransaction(transactions: Call[], details: InvocationsSignerDetails): Promise<Signature>;
    signDeployAccountTransaction(details: DeployAccountSignerDetails): Promise<Signature>;
    signDeclareTransaction(details: DeclareSignerDetails): Promise<Signature>;
    protected signRaw(msgHash: string): Promise<Signature>;
}

/**
 * Signer for accounts using Ethereum signature
 */
declare class EthSigner implements SignerInterface {
    protected pk: string;
    constructor(pk?: Uint8Array | string);
    /**
     * provides the Ethereum full public key (without parity prefix)
     * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.
     */
    getPubKey(): Promise<string>;
    signMessage(typedData: TypedData, accountAddress: string): Promise<Signature>;
    signTransaction(transactions: Call[], details: InvocationsSignerDetails): Promise<Signature>;
    signDeployAccountTransaction(details: DeployAccountSignerDetails): Promise<Signature>;
    signDeclareTransaction(details: DeclareSignerDetails): Promise<Signature>;
    /**
     * Serialize the signature in conformity with starknet::eth_signature::Signature
     * @param ethSignature secp256k1 signature from Noble curves library
     * @return an array of felts, representing a Cairo Eth Signature.
     */
    protected formatEthSignature(ethSignature: RecoveredSignatureType): ArraySignatureType;
}

declare abstract class AccountInterface extends ProviderInterface {
    abstract address: string;
    abstract signer: SignerInterface;
    abstract cairoVersion: CairoVersion;
    /**
     * Estimate Fee for executing an INVOKE transaction on starknet
     *
     * @param calls the invocation object containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata? - (defaults to []) the calldata
     *
     * @param estimateFeeDetails -
     * - blockIdentifier?
     * - nonce? = 0
     * - skipValidate? - default true
     * - tip? - prioritize order of transactions in the mempool.
     * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)
     * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)
     * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei
     *
     * @returns response from estimate_fee
     */
    abstract estimateInvokeFee(calls: AllowArray<Call>, estimateFeeDetails?: EstimateFeeDetails): Promise<EstimateFeeResponse>;
    /**
     * Estimate Fee for executing a DECLARE transaction on starknet
     *
     * @param contractPayload the payload object containing:
     * - contract - the compiled contract to be declared
     * - casm? - compiled cairo assembly. Cairo1(casm or compiledClassHash are required)
     * - classHash? - the class hash of the compiled contract. Precalculate for faster execution.
     * - compiledClassHash?: class hash of the cairo assembly. Cairo1(casm or compiledClassHash are required)
     *
     * @param estimateFeeDetails -
     * - blockIdentifier?
     * - nonce? = 0
     * - skipValidate? - default true
     * - tip? - prioritize order of transactions in the mempool.
     * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)
     * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)
     * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei
     *
     * @returns response from estimate_fee
     */
    abstract estimateDeclareFee(contractPayload: DeclareContractPayload, estimateFeeDetails?: EstimateFeeDetails): Promise<EstimateFeeResponse>;
    /**
     * Estimate Fee for executing a DEPLOY_ACCOUNT transaction on starknet
     *
     * @param contractPayload -
     * - classHash - the class hash of the compiled contract.
     * - constructorCalldata? - constructor data;
     * - contractAddress? - future account contract address. Precalculate for faster execution.
     * - addressSalt? - salt used for calculation of the contractAddress. Required if contractAddress is provided.
     *
     * @param estimateFeeDetails -
     * - blockIdentifier?
     * - nonce? = 0
     * - skipValidate? - default true
     * - tip? - prioritize order of transactions in the mempool.
     * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)
     * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei
     *
     * @returns response from estimate_fee
     */
    abstract estimateAccountDeployFee(contractPayload: DeployAccountContractPayload, estimateFeeDetails?: EstimateFeeDetails): Promise<EstimateFeeResponse>;
    /**
     * Estimate Fee for executing a UDC DEPLOY transaction on starknet
     * This is different from the normal DEPLOY transaction as it goes through the Universal Deployer Contract (UDC)
     
    * @param deployContractPayload array or singular
     * - classHash: computed class hash of compiled contract
     * - salt: address salt
     * - unique: bool if true ensure unique salt
     * - constructorCalldata: constructor calldata
     *
     * @param estimateFeeDetails -
     * - blockIdentifier?
     * - nonce?
     * - skipValidate? - default true
     * - tip? - prioritize order of transactions in the mempool.
     * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)
     * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)
     * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei
     */
    abstract estimateDeployFee(deployContractPayload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], estimateFeeDetails?: EstimateFeeDetails): Promise<EstimateFeeResponse>;
    /**
     * Estimate Fee for executing a list of transactions on starknet
     * Contract must be deployed for fee estimation to be possible
     *
     * @param transactions array of transaction object containing :
     * - type - the type of transaction : 'DECLARE' | (multi)'DEPLOY' | (multi)'INVOKE_FUNCTION' | 'DEPLOY_ACCOUNT'
     * - payload - the payload of the transaction
     *
     *  @param estimateFeeDetails -
     * - blockIdentifier?
     * - nonce?
     * - skipValidate? - default true
     * - tip? - prioritize order of transactions in the mempool.
     * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)
     * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)
     * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)
     * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei
     *
     * @returns response from estimate_fee
     */
    abstract estimateFeeBulk(invocations: Invocations, details?: EstimateFeeDetails): Promise<EstimateFeeResponseBulk>;
    /**
     * Gets Suggested Max Fee based on the transaction type
     *
     * @param  {EstimateFeeAction} estimateFeeAction
     * @param  {EstimateFeeDetails} details
     * @returns EstimateFee (...response, resourceBounds, suggestedMaxFee)
     */
    abstract getSuggestedFee(estimateFeeAction: EstimateFeeAction, details: EstimateFeeDetails): Promise<EstimateFee>;
    /**
     * Simulates an array of transaction and returns an array of transaction trace and estimated fee.
     *
     * @param invocations Invocations containing:
     * - type - transaction type: DECLARE, (multi)DEPLOY, DEPLOY_ACCOUNT, (multi)INVOKE_FUNCTION
     * @param details SimulateTransactionDetails
     *
     * @returns response from simulate_transaction
     */
    abstract simulateTransaction(invocations: Invocations, details?: SimulateTransactionDetails): Promise<SimulateTransactionResponse>;
    /**
     * Invoke execute function in account contract
     *
     * @param transactions the invocation object or an array of them, containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param {InvocationsDetails} transactionsDetail Additional optional parameters for the transaction
     *
     * @returns response from addTransaction
     */
    abstract execute(transactions: AllowArray<Call>, transactionsDetail?: InvocationsDetails): Promise<InvokeFunctionResponse>;
    /**
     * @deprecated
     * @param transactions the invocation object or an array of them, containing:
     * - contractAddress - the address of the contract
     * - entrypoint - the entrypoint of the contract
     * - calldata - (defaults to []) the calldata
     * - signature - (defaults to []) the signature
     * @param abis (optional) the abi of the contract for better displaying
     * @param {InvocationsDetails} transactionsDetail Additional optional parameters for the transaction
     * * @returns response from addTransaction
     */
    abstract execute(transactions: AllowArray<Call>, abis?: Abi[], transactionsDetail?: InvocationsDetails): Promise<InvokeFunctionResponse>;
    /**
     * Declares a given compiled contract (json) to starknet
     *
     * @param contractPayload transaction payload to be deployed containing:
     * - contract: compiled contract code
     * - (optional) classHash: computed class hash of compiled contract. Pre-compute it for faster execution.
     * - (required for Cairo1 without compiledClassHash) casm: CompiledContract | string;
     * - (optional for Cairo1 with casm) compiledClassHash: compiled class hash from casm. Pre-compute it for faster execution.
     * @param transactionsDetail - InvocationsDetails
     *
     * @returns a confirmation of sending a transaction on the starknet contract
     */
    abstract declare(contractPayload: DeclareContractPayload, transactionsDetail?: InvocationsDetails): Promise<DeclareContractResponse>;
    /**
     * Deploys a declared contract to starknet - using Universal Deployer Contract (UDC)
     * support multicall
     *
     * @param payload -
     * - classHash: computed class hash of compiled contract
     * - [constructorCalldata] contract constructor calldata
     * - [salt=pseudorandom] deploy address salt
     * - [unique=true] ensure unique salt
     * @param details - InvocationsDetails
     *
     * @returns
     * - contract_address[]
     * - transaction_hash
     */
    abstract deploy(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], details?: InvocationsDetails): Promise<MultiDeployContractResponse>;
    /**
     * Simplify deploy simulating old DeployContract with same response + UDC specific response
     * Internal wait for L2 transaction, support multicall
     *
     * @param payload -
     * - classHash: computed class hash of compiled contract
     * - [constructorCalldata] contract constructor calldata
     * - [salt=pseudorandom] deploy address salt
     * - [unique=true] ensure unique salt
     * @param details - InvocationsDetails
     *
     * @returns
     *  - contract_address
     *  - transaction_hash
     *  - address
     *  - deployer
     *  - unique
     *  - classHash
     *  - calldata_len
     *  - calldata
     *  - salt
     */
    abstract deployContract(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], details?: InvocationsDetails): Promise<DeployContractUDCResponse>;
    /**
     * Declares and Deploy a given compiled contract (json) to starknet using UDC
     * Internal wait for L2 transaction, do not support multicall
     * Method will pass even if contract is already declared (internal using DeclareIfNot)
     *
     * @param payload
     * - contract: compiled contract code
     * - [casm=cairo1]: CairoAssembly | undefined;
     * - [compiledClassHash]: string | undefined;
     * - [classHash]: computed class hash of compiled contract
     * - [constructorCalldata] contract constructor calldata
     * - [salt=pseudorandom] deploy address salt
     * - [unique=true] ensure unique salt
     * @param details - InvocationsDetails
     *
     * @returns
     * - declare
     *    - transaction_hash
     * - deploy
     *    - contract_address
     *    - transaction_hash
     *    - address
     *    - deployer
     *    - unique
     *    - classHash
     *    - calldata_len
     *    - calldata
     *    - salt
     */
    abstract declareAndDeploy(payload: DeclareAndDeployContractPayload, details?: InvocationsDetails): Promise<DeclareDeployUDCResponse>;
    /**
     * Deploy the account on Starknet
     *
     * @param contractPayload transaction payload to be deployed containing:
     * - classHash: computed class hash of compiled contract
     * - optional constructor calldata
     * - optional address salt
     * - optional contractAddress
     * @param transactionsDetail - InvocationsDetails
     *
     * @returns a confirmation of sending a transaction on the starknet contract
     */
    abstract deployAccount(contractPayload: DeployAccountContractPayload, transactionsDetail?: InvocationsDetails): Promise<DeployContractResponse>;
    /**
     * Signs a JSON object for off-chain usage with the Starknet private key and returns the signature
     * This adds a message prefix so it can't be interchanged with transactions
     *
     * @param json - JSON object to be signed
     * @returns the signature of the JSON object
     * @throws {Error} if the JSON object is not a valid JSON
     */
    abstract signMessage(typedData: TypedData): Promise<Signature>;
    /**
     * Hash a JSON object with Pedersen hash and return the hash
     * This adds a message prefix so it can't be interchanged with transactions
     *
     * @param json - JSON object to be hashed
     * @returns the hash of the JSON object
     * @throws {Error} if the JSON object is not a valid JSON
     */
    abstract hashMessage(typedData: TypedData): Promise<string>;
    /**
     * Verify a signature of a JSON object
     *
     * @param typedData - JSON object to be verified
     * @param signature - signature of the JSON object
     * @returns true if the signature is valid, false otherwise
     * @throws {Error} if the JSON object is not a valid JSON or the signature is not a valid signature
     */
    abstract verifyMessage(typedData: TypedData, signature: Signature): Promise<boolean>;
    /**
     * Verify a signature of a given hash
     * @warning This method is not recommended, use verifyMessage instead
     *
     * @param hash - hash to be verified
     * @param signature - signature of the hash
     * @returns true if the signature is valid, false otherwise
     * @throws {Error} if the signature is not a valid signature
     */
    abstract verifyMessageHash(hash: BigNumberish, signature: Signature): Promise<boolean>;
    /**
     * Gets the nonce of the account with respect to a specific block
     *
     * @param  {BlockIdentifier} blockIdentifier - optional blockIdentifier. Defaults to 'pending'
     * @returns nonce of the account
     */
    abstract getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce>;
}

declare class Account extends RpcProvider implements AccountInterface {
    signer: SignerInterface;
    address: string;
    cairoVersion: CairoVersion;
    readonly transactionVersion: ETransactionVersion.V2 | ETransactionVersion.V3;
    constructor(providerOrOptions: ProviderOptions | ProviderInterface, address: string, pkOrSigner: Uint8Array | string | SignerInterface, cairoVersion?: CairoVersion, transactionVersion?: ETransactionVersion.V2 | ETransactionVersion.V3);
    protected getPreferredVersion(type12: ETransactionVersion, type3: ETransactionVersion): ETransactionVersion;
    getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce>;
    protected getNonceSafe(nonce?: BigNumberish): Promise<bigint>;
    /**
     * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor
     * @param classHash if provided detects Cairo version from classHash, otherwise from the account address
     */
    getCairoVersion(classHash?: string): Promise<CairoVersion>;
    estimateFee(calls: AllowArray<Call>, estimateFeeDetails?: UniversalDetails): Promise<EstimateFee>;
    estimateInvokeFee(calls: AllowArray<Call>, details?: UniversalDetails): Promise<EstimateFee>;
    estimateDeclareFee(payload: DeclareContractPayload, details?: UniversalDetails): Promise<EstimateFee>;
    estimateAccountDeployFee({ classHash, addressSalt, constructorCalldata, contractAddress, }: DeployAccountContractPayload, details?: UniversalDetails): Promise<EstimateFee>;
    estimateDeployFee(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], details?: UniversalDetails): Promise<EstimateFee>;
    estimateFeeBulk(invocations: Invocations, details?: UniversalDetails): Promise<EstimateFeeBulk>;
    simulateTransaction(invocations: Invocations, details?: SimulateTransactionDetails): Promise<SimulateTransactionResponse>;
    execute(transactions: AllowArray<Call>, transactionsDetail?: UniversalDetails): Promise<InvokeFunctionResponse>;
    execute(transactions: AllowArray<Call>, abis?: Abi[], transactionsDetail?: UniversalDetails): Promise<InvokeFunctionResponse>;
    /**
     * First check if contract is already declared, if not declare it
     * If contract already declared returned transaction_hash is ''.
     * Method will pass even if contract is already declared
     * @param transactionsDetail (optional)
     */
    declareIfNot(payload: DeclareContractPayload, transactionsDetail?: UniversalDetails): Promise<DeclareContractResponse>;
    declare(payload: DeclareContractPayload, details?: UniversalDetails): Promise<DeclareContractResponse>;
    deploy(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], details?: UniversalDetails): Promise<MultiDeployContractResponse>;
    deployContract(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], details?: UniversalDetails): Promise<DeployContractUDCResponse>;
    declareAndDeploy(payload: DeclareAndDeployContractPayload, details?: UniversalDetails): Promise<DeclareDeployUDCResponse>;
    deploySelf: ({ classHash, constructorCalldata, addressSalt, contractAddress: providedContractAddress, }: DeployAccountContractPayload, details?: UniversalDetails) => Promise<DeployContractResponse>;
    deployAccount({ classHash, constructorCalldata, addressSalt, contractAddress: providedContractAddress, }: DeployAccountContractPayload, details?: UniversalDetails): Promise<DeployContractResponse>;
    signMessage(typedData: TypedData): Promise<Signature>;
    hashMessage(typedData: TypedData): Promise<string>;
    verifyMessageHash(hash: BigNumberish, signature: Signature): Promise<boolean>;
    verifyMessage(typedData: TypedData, signature: Signature): Promise<boolean>;
    protected getUniversalSuggestedFee(version: ETransactionVersion, { type, payload }: EstimateFeeAction, details: UniversalDetails): Promise<{
        maxFee: BigNumberish;
        resourceBounds: RESOURCE_BOUNDS_MAPPING$1;
    }>;
    getSuggestedFee({ type, payload }: EstimateFeeAction, details: UniversalDetails): Promise<EstimateFee>;
    buildInvocation(call: Array<Call>, details: InvocationsSignerDetails): Promise<Invocation>;
    buildDeclarePayload(payload: DeclareContractPayload, details: InvocationsSignerDetails): Promise<DeclareContractTransaction>;
    buildAccountDeployPayload({ classHash, addressSalt, constructorCalldata, contractAddress: providedContractAddress, }: DeployAccountContractPayload, details: InvocationsSignerDetails): Promise<DeployAccountContractTransaction>;
    buildUDCContractPayload(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[]): Call[];
    accountInvocationsFactory(invocations: Invocations, details: AccountInvocationsFactoryDetails): Promise<AccountInvocations>;
    getStarkName(address?: BigNumberish, // default to the wallet address
    StarknetIdContract?: string): Promise<string>;
}

interface StarknetWalletProvider extends StarknetWindowObject {
}

declare class WalletAccount extends Account implements AccountInterface {
    address: string;
    walletProvider: StarknetWalletProvider;
    constructor(providerOrOptions: ProviderOptions | ProviderInterface, walletProvider: StarknetWalletProvider, cairoVersion?: CairoVersion);
    /**
     * WALLET EVENTS
     */
    onAccountChange(callback: AccountChangeEventHandler): void;
    onNetworkChanged(callback: NetworkChangeEventHandler): void;
    /**
     * WALLET SPECIFIC METHODS
     */
    requestAccounts(silentMode?: boolean): Promise<string[]>;
    getPermissions(): Promise<starknet_types.Permission[]>;
    switchStarknetChain(chainId: StarknetChainId): Promise<boolean>;
    watchAsset(asset: WatchAssetParameters): Promise<boolean>;
    addStarknetChain(chain: AddStarknetChainParameters): Promise<boolean>;
    /**
     * ACCOUNT METHODS
     */
    execute(calls: AllowArray<Call>): Promise<starknet_types.AddInvokeTransactionResult>;
    declare(payload: DeclareContractPayload): Promise<starknet_types.AddDeclareTransactionResult>;
    deploy(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[]): Promise<MultiDeployContractResponse>;
    deployAccount(payload: DeployAccountContractPayload): Promise<starknet_types.AddDeployAccountTransactionResult>;
    signMessage(typedData: TypedData): Promise<string[]>;
}

declare module 'abi-wan-kanabi' {
    interface Config<OptionT = any, ResultT = any, ErrorT = any> {
        FeltType: BigNumberish;
        U256Type: number | bigint | Uint256;
        U512Type: BigNumberish;
        Secp256k1PointType: BigNumberish;
        Option: CairoOption<OptionT>;
        Tuple: Record<number, BigNumberish | object | boolean>;
        Result: CairoResult<ResultT, ErrorT>;
        Enum: CairoCustomEnum;
        Calldata: RawArgs | Calldata;
        CallOptions: CallOptions;
        InvokeOptions: InvokeOptions;
        InvokeFunctionResponse: InvokeFunctionResponse;
    }
}
type TypedContractV2$1<TAbi extends Abi$1> = TypedContract<TAbi> & ContractInterface;
declare abstract class ContractInterface {
    abstract abi: Abi;
    abstract address: string;
    abstract providerOrAccount: ProviderInterface | AccountInterface;
    abstract deployTransactionHash?: string;
    readonly functions: {
        [name: string]: AsyncContractFunction;
    };
    readonly callStatic: {
        [name: string]: AsyncContractFunction;
    };
    readonly populateTransaction: {
        [name: string]: ContractFunction;
    };
    readonly estimateFee: {
        [name: string]: ContractFunction;
    };
    readonly [key: string]: AsyncContractFunction | any;
    /**
     * Saves the address of the contract deployed on network that will be used for interaction
     *
     * @param address - address of the contract
     */
    abstract attach(address: string): void;
    /**
     * Attaches to new Provider or Account
     *
     * @param providerOrAccount - new Provider or Account to attach to
     */
    abstract connect(providerOrAccount: ProviderInterface | AccountInterface): void;
    /**
     * Resolves when contract is deployed on the network or when no deployment transaction is found
     *
     * @returns Promise that resolves when contract is deployed on the network or when no deployment transaction is found
     * @throws When deployment fails
     */
    abstract deployed(): Promise<ContractInterface>;
    /**
     * Calls a method on a contract
     *
     * @param method name of the method
     * @param args Array of the arguments for the call
     * @param options optional blockIdentifier
     * @returns Result of the call as an array with key value pars
     */
    abstract call(method: string, args?: ArgsOrCalldata, options?: CallOptions): Promise<Result>;
    /**
     * Invokes a method on a contract
     *
     * @param method name of the method
     * @param args Array of the arguments for the invoke or Calldata
     * @param options
     * @returns Add Transaction Response
     */
    abstract invoke(method: string, args?: ArgsOrCalldata, options?: InvokeOptions): Promise<InvokeFunctionResponse>;
    /**
     * Estimates a method on a contract
     *
     * @param method name of the method
     * @param args Array of the arguments for the call or Calldata
     * @param options optional blockIdentifier
     */
    abstract estimate(method: string, args?: ArgsOrCalldata, options?: {
        blockIdentifier?: BlockIdentifier;
    }): Promise<EstimateFeeResponse>;
    /**
     * Calls a method on a contract
     *
     * @param method name of the method
     * @param args Array of the arguments for the call or Calldata
     * @returns Invocation object
     */
    abstract populate(method: string, args?: ArgsOrCalldata): Invocation;
    /**
     * Parse contract events of a GetTransactionReceiptResponse received from waitForTransaction. Based on contract's abi
     *
     * @param receipt transaction receipt
     * @returns Events parsed
     */
    abstract parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents;
    /**
     * tells if the contract comes from a Cairo 1 contract
     *
     * @returns TRUE if the contract comes from a Cairo1 contract
     * @example
     * ```typescript
     * const isCairo1: boolean = myContract.isCairo1();
     * ```
     */
    abstract isCairo1(): boolean;
    /**
     * Retrieves the version of the contract (cairo version & compiler version)
     */
    abstract getVersion(): Promise<ContractVersion>;
    abstract typedv2<TAbi extends Abi$1>(tAbi: TAbi): TypedContractV2$1<TAbi>;
}

type TypedContractV2<TAbi extends Abi$1> = TypedContract<TAbi> & Contract;
declare const splitArgsAndOptions: (args: ArgsOrCalldataWithOptions) => {
    args: ArgsOrCalldata;
    options: ContractOptions;
} | {
    args: ArgsOrCalldata;
    options?: undefined;
};
declare function getCalldata(args: RawArgs, callback: Function): Calldata;
declare class Contract implements ContractInterface {
    abi: Abi;
    address: string;
    providerOrAccount: ProviderInterface | AccountInterface;
    deployTransactionHash?: string;
    protected readonly structs: {
        [name: string]: StructAbi;
    };
    protected readonly events: AbiEvents;
    readonly functions: {
        [name: string]: AsyncContractFunction;
    };
    readonly callStatic: {
        [name: string]: AsyncContractFunction;
    };
    readonly populateTransaction: {
        [name: string]: ContractFunction;
    };
    readonly estimateFee: {
        [name: string]: ContractFunction;
    };
    readonly [key: string]: AsyncContractFunction | any;
    private callData;
    /**
     * Contract class to handle contract methods
     *
     * @param abi - Abi of the contract object
     * @param address (optional) - address to connect to
     * @param providerOrAccount (optional) - Provider or Account to attach to
     */
    constructor(abi: Abi, address: string, providerOrAccount?: ProviderInterface | AccountInterface);
    attach(address: string): void;
    connect(providerOrAccount: ProviderInterface | AccountInterface): void;
    deployed(): Promise<Contract>;
    call(method: string, args?: ArgsOrCalldata, { parseRequest, parseResponse, formatResponse, blockIdentifier, }?: CallOptions): Promise<Result>;
    invoke(method: string, args?: ArgsOrCalldata, { parseRequest, maxFee, nonce, signature }?: InvokeOptions): Promise<InvokeFunctionResponse>;
    estimate(method: string, args?: ArgsOrCalldata): Promise<EstimateFeeResponse>;
    populate(method: string, args?: RawArgs): Call;
    parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents;
    isCairo1(): boolean;
    getVersion(): Promise<ContractVersion>;
    typedv2<TAbi extends Abi$1>(tAbi: TAbi): TypedContractV2<TAbi>;
}

type ContractFactoryParams = {
    compiledContract: CompiledContract;
    account: any;
    casm?: CairoAssembly;
    classHash?: string;
    compiledClassHash?: string;
    abi?: Abi;
};
declare class ContractFactory {
    compiledContract: CompiledContract;
    account: AccountInterface;
    abi: Abi;
    classHash?: string;
    casm?: CairoAssembly;
    compiledClassHash?: string;
    private CallData;
    /**
     * @param params CFParams
     *  - compiledContract: CompiledContract;
     *  - account: AccountInterface;
     *  - casm?: CairoAssembly;
     *  - classHash?: string;
     *  - compiledClassHash?: string;
     *  - abi?: Abi;
     */
    constructor(params: ContractFactoryParams);
    /**
     * Deploys contract and returns new instance of the Contract
     *
     * If contract is not declared it will first declare it, and then deploy
     */
    deploy(...args: ArgsOrCalldataWithOptions): Promise<Contract>;
    /**
     * Attaches to new Account
     *
     * @param account - new Account to attach to
     */
    connect(account: AccountInterface): ContractFactory;
    /**
     * Attaches current abi and account to the new address
     */
    attach(address: string): Contract;
}

/**
 * Calculate hex-string keccak hash for a given BigNumberish
 *
 * BigNumberish -> hex-string keccak hash
 * @returns format: hex-string
 */
declare function keccakBn(value: BigNumberish): string;
/**
 * Calculate bigint keccak hash for a given string
 *
 * String -> bigint keccak hash
 *
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L17-L22)
 * @param str the value you want to get the keccak hash from
 * @returns starknet keccak hash as BigInt
 */
declare function starknetKeccak(str: string): bigint;
/**
 * Calculate hex-string selector for a given abi-function-name
 *
 * Abi-function-name -> hex-string selector
 *
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L25-L26)
 * @param funcName ascii-string of 'abi function name'
 * @returns format: hex-string; selector for 'abi function name'
 */
declare function getSelectorFromName(funcName: string): string;
/**
 * Calculate hex-string selector from abi-function-name, decimal string or hex string
 *
 * ('abi-function-name' or dec-string or hex-string) -> hex-string selector
 *
 * @param value hex-string | dec-string | ascii-string
 * @returns format: hex-string
 */
declare function getSelector(value: string): string;

declare const selector_getSelector: typeof getSelector;
declare const selector_getSelectorFromName: typeof getSelectorFromName;
declare const selector_keccakBn: typeof keccakBn;
declare const selector_starknetKeccak: typeof starknetKeccak;
declare namespace selector {
  export { selector_getSelector as getSelector, selector_getSelectorFromName as getSelectorFromName, selector_keccakBn as keccakBn, selector_starknetKeccak as starknetKeccak };
}

/**
 * Transaction Hash based on Transaction Version
 */

type CalcV2InvokeTxHashArgs = {
    senderAddress: BigNumberish;
    version: `${ETransactionVersion2}`;
    compiledCalldata: Calldata;
    maxFee: BigNumberish;
    chainId: StarknetChainId;
    nonce: BigNumberish;
};
type CalcV3InvokeTxHashArgs = {
    senderAddress: BigNumberish;
    version: `${ETransactionVersion3}`;
    compiledCalldata: Calldata;
    chainId: StarknetChainId;
    nonce: BigNumberish;
    accountDeploymentData: BigNumberish[];
    nonceDataAvailabilityMode: EDAMode;
    feeDataAvailabilityMode: EDAMode;
    resourceBounds: ResourceBounds$1;
    tip: BigNumberish;
    paymasterData: BigNumberish[];
};
type CalcInvokeTxHashArgs = CalcV2InvokeTxHashArgs | CalcV3InvokeTxHashArgs;
declare function calculateInvokeTransactionHash$1(args: CalcInvokeTxHashArgs): string;
type CalcV2DeclareTxHashArgs = {
    classHash: string;
    senderAddress: BigNumberish;
    version: `${ETransactionVersion2}`;
    maxFee: BigNumberish;
    chainId: StarknetChainId;
    nonce: BigNumberish;
    compiledClassHash?: string;
};
type CalcV3DeclareTxHashArgs = {
    classHash: string;
    compiledClassHash: string;
    senderAddress: BigNumberish;
    version: `${ETransactionVersion3}`;
    chainId: StarknetChainId;
    nonce: BigNumberish;
    accountDeploymentData: BigNumberish[];
    nonceDataAvailabilityMode: EDAMode;
    feeDataAvailabilityMode: EDAMode;
    resourceBounds: ResourceBounds$1;
    tip: BigNumberish;
    paymasterData: BigNumberish[];
};
type CalcDeclareTxHashArgs = CalcV2DeclareTxHashArgs | CalcV3DeclareTxHashArgs;
declare function calculateDeclareTransactionHash$2(args: CalcDeclareTxHashArgs): string;
type CalcV2DeployAccountTxHashArgs = {
    contractAddress: BigNumberish;
    classHash: BigNumberish;
    constructorCalldata: Calldata;
    salt: BigNumberish;
    version: `${ETransactionVersion2}`;
    maxFee: BigNumberish;
    chainId: StarknetChainId;
    nonce: BigNumberish;
};
type CalcV3DeployAccountTxHashArgs = {
    contractAddress: BigNumberish;
    classHash: BigNumberish;
    compiledConstructorCalldata: Calldata;
    salt: BigNumberish;
    version: `${ETransactionVersion3}`;
    chainId: StarknetChainId;
    nonce: BigNumberish;
    nonceDataAvailabilityMode: EDAMode;
    feeDataAvailabilityMode: EDAMode;
    resourceBounds: ResourceBounds$1;
    tip: BigNumberish;
    paymasterData: BigNumberish[];
};
type CalcDeployAccountTxHashArgs = CalcV2DeployAccountTxHashArgs | CalcV3DeployAccountTxHashArgs;
declare function calculateDeployAccountTransactionHash$2(args: CalcDeployAccountTxHashArgs): string;

/**
 * Class Hash
 */

declare function computePedersenHash(a: BigNumberish, b: BigNumberish): string;
declare function computePoseidonHash(a: BigNumberish, b: BigNumberish): string;
/**
 * Compute pedersen hash from data
 * @returns format: hex-string - pedersen hash
 */
declare function computeHashOnElements$1(data: BigNumberish[]): string;
declare const computePedersenHashOnElements: typeof computeHashOnElements$1;
declare function computePoseidonHashOnElements(data: BigNumberish[]): string;
/**
 * Calculate contract address from class hash
 * @returns format: hex-string
 */
declare function calculateContractAddressFromHash(salt: BigNumberish, classHash: BigNumberish, constructorCalldata: RawArgs, deployerAddress: BigNumberish): string;
/**
 * Format json-string to conform starknet json-string
 * @param json json-string
 * @returns format: json-string
 */
declare function formatSpaces(json: string): string;
/**
 * Computes the class hash for legacy compiled contract (Cairo 0)
 * @returns format: hex-string
 */
declare function computeLegacyContractClassHash(contract: LegacyCompiledContract | string): string;
/**
 * Compute hash of the bytecode for Sierra v1.5.0 onwards (Cairo 2.6.0)
 * Each segment is Poseidon hashed.
 * The global hash is : 1 + PoseidonHash(len0, h0, len1, h1, ...)
 * @param casm compiled Sierra CASM file content.
 * @returns the bytecode hash as bigint.
 */
declare function hashByteCodeSegments(casm: CompiledSierraCasm): bigint;
/**
 * Compute compiled class hash for contract (Cairo 1)
 * @returns format: hex-string
 */
declare function computeCompiledClassHash(casm: CompiledSierraCasm): string;
/**
 * Compute sierra contract class hash (Cairo 1)
 * @returns format: hex-string
 */
declare function computeSierraContractClassHash(sierra: CompiledSierra): string;
/**
 * Compute ClassHash (sierra or legacy) based on provided contract
 * @returns format: hex-string
 */
declare function computeContractClassHash(contract: CompiledContract | string): string;

/**
 * Hashes Exports
 */

declare const index$1_calculateContractAddressFromHash: typeof calculateContractAddressFromHash;
declare const index$1_computeCompiledClassHash: typeof computeCompiledClassHash;
declare const index$1_computeContractClassHash: typeof computeContractClassHash;
declare const index$1_computeLegacyContractClassHash: typeof computeLegacyContractClassHash;
declare const index$1_computePedersenHash: typeof computePedersenHash;
declare const index$1_computePedersenHashOnElements: typeof computePedersenHashOnElements;
declare const index$1_computePoseidonHash: typeof computePoseidonHash;
declare const index$1_computePoseidonHashOnElements: typeof computePoseidonHashOnElements;
declare const index$1_computeSierraContractClassHash: typeof computeSierraContractClassHash;
declare const index$1_formatSpaces: typeof formatSpaces;
declare const index$1_getSelector: typeof getSelector;
declare const index$1_getSelectorFromName: typeof getSelectorFromName;
declare const index$1_hashByteCodeSegments: typeof hashByteCodeSegments;
declare const index$1_keccakBn: typeof keccakBn;
declare const index$1_poseidon: typeof poseidon;
declare const index$1_starknetKeccak: typeof starknetKeccak;
declare namespace index$1 {
  export { index$1_calculateContractAddressFromHash as calculateContractAddressFromHash, calculateDeclareTransactionHash$2 as calculateDeclareTransactionHash, calculateDeployAccountTransactionHash$2 as calculateDeployAccountTransactionHash, calculateInvokeTransactionHash$1 as calculateInvokeTransactionHash, index$1_computeCompiledClassHash as computeCompiledClassHash, index$1_computeContractClassHash as computeContractClassHash, computeHashOnElements$1 as computeHashOnElements, index$1_computeLegacyContractClassHash as computeLegacyContractClassHash, index$1_computePedersenHash as computePedersenHash, index$1_computePedersenHashOnElements as computePedersenHashOnElements, index$1_computePoseidonHash as computePoseidonHash, index$1_computePoseidonHashOnElements as computePoseidonHashOnElements, index$1_computeSierraContractClassHash as computeSierraContractClassHash, index$1_formatSpaces as formatSpaces, index$1_getSelector as getSelector, index$1_getSelectorFromName as getSelectorFromName, index$1_hashByteCodeSegments as hashByteCodeSegments, index$1_keccakBn as keccakBn, index$1_poseidon as poseidon, index$1_starknetKeccak as starknetKeccak };
}

/**
 * Calculate Hashes for v3 transactions
 */

declare function hashDAMode(nonceDAMode: BigNumberish, feeDAMode: BigNumberish): bigint;
declare function hashFeeField(tip: BigNumberish, bounds: ResourceBounds$1): bigint;
declare function calculateTransactionHashCommon$1(txHashPrefix: TransactionHashPrefix, version: BigNumberish, senderAddress: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish, tip: BigNumberish, paymasterData: BigNumberish[], nonceDataAvailabilityMode: EDAMode, feeDataAvailabilityMode: EDAMode, resourceBounds: ResourceBounds$1, additionalData?: BigNumberish[]): string;
/**
 * Calculate v3 deploy_account transaction hash
 * @returns format: hex-string
 */
declare function calculateDeployAccountTransactionHash$1(contractAddress: BigNumberish, classHash: BigNumberish, compiledConstructorCalldata: Calldata, salt: BigNumberish, version: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish, nonceDataAvailabilityMode: EDAMode, feeDataAvailabilityMode: EDAMode, resourceBounds: ResourceBounds$1, tip: BigNumberish, paymasterData: BigNumberish[]): string;
/**
 * Calculate v3 declare transaction hash
 * @returns format: hex-string
 */
declare function calculateDeclareTransactionHash$1(classHash: string, compiledClassHash: string, senderAddress: BigNumberish, version: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish, accountDeploymentData: BigNumberish[], nonceDataAvailabilityMode: EDAMode, feeDataAvailabilityMode: EDAMode, resourceBounds: ResourceBounds$1, tip: BigNumberish, paymasterData: BigNumberish[]): string;
/**
 * Calculate v3 invoke transaction hash
 * @returns format: hex-string
 */
declare function calculateInvokeTransactionHash(senderAddress: BigNumberish, version: BigNumberish, compiledCalldata: Calldata, chainId: StarknetChainId, nonce: BigNumberish, accountDeploymentData: BigNumberish[], nonceDataAvailabilityMode: EDAMode, feeDataAvailabilityMode: EDAMode, resourceBounds: ResourceBounds$1, tip: BigNumberish, paymasterData: BigNumberish[]): string;

declare const v3_calculateInvokeTransactionHash: typeof calculateInvokeTransactionHash;
declare const v3_hashDAMode: typeof hashDAMode;
declare const v3_hashFeeField: typeof hashFeeField;
declare namespace v3 {
  export { calculateDeclareTransactionHash$1 as calculateDeclareTransactionHash, calculateDeployAccountTransactionHash$1 as calculateDeployAccountTransactionHash, v3_calculateInvokeTransactionHash as calculateInvokeTransactionHash, calculateTransactionHashCommon$1 as calculateTransactionHashCommon, v3_hashDAMode as hashDAMode, v3_hashFeeField as hashFeeField };
}

/**
 * Calculate Hashes for v0 - v2 transactions
 */

/**
 * Compute pedersen hash from data
 * @returns format: hex-string - pedersen hash
 */
declare function computeHashOnElements(data: BigNumberish[]): string;
/**
 * Calculate transaction pedersen hash for common properties
 *
 * Following implementation is based on this python [implementation #](https://github.com/starkware-libs/cairo-lang/blob/b614d1867c64f3fb2cf4a4879348cfcf87c3a5a7/src/starkware/starknet/core/os/transaction_hash/transaction_hash.py)
 * @returns format: hex-string
 */
declare function calculateTransactionHashCommon(txHashPrefix: TransactionHashPrefix, version: BigNumberish, contractAddress: BigNumberish, entryPointSelector: BigNumberish, calldata: RawCalldata, maxFee: BigNumberish, chainId: StarknetChainId, additionalData?: BigNumberish[]): string;
/**
 * Calculate declare transaction hash
 * @param classHash hex-string
 * @param compiledClassHash hex-string
 * @returns format: hex-string
 */
declare function calculateDeclareTransactionHash(classHash: string, senderAddress: BigNumberish, version: BigNumberish, maxFee: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish, compiledClassHash?: string): string;
/**
 * Calculate deploy_account transaction hash
 * @returns format: hex-string
 */
declare function calculateDeployAccountTransactionHash(contractAddress: BigNumberish, classHash: BigNumberish, constructorCalldata: RawCalldata, salt: BigNumberish, version: BigNumberish, maxFee: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish): string;
/**
 * Calculate invoke transaction hash
 * @returns format: hex-string
 */
declare function calculateTransactionHash(contractAddress: BigNumberish, version: BigNumberish, calldata: RawCalldata, maxFee: BigNumberish, chainId: StarknetChainId, nonce: BigNumberish): string;

declare const v2_calculateDeclareTransactionHash: typeof calculateDeclareTransactionHash;
declare const v2_calculateDeployAccountTransactionHash: typeof calculateDeployAccountTransactionHash;
declare const v2_calculateTransactionHash: typeof calculateTransactionHash;
declare const v2_calculateTransactionHashCommon: typeof calculateTransactionHashCommon;
declare const v2_computeHashOnElements: typeof computeHashOnElements;
declare namespace v2 {
  export { v2_calculateDeclareTransactionHash as calculateDeclareTransactionHash, v2_calculateDeployAccountTransactionHash as calculateDeployAccountTransactionHash, v2_calculateTransactionHash as calculateTransactionHash, v2_calculateTransactionHashCommon as calculateTransactionHashCommon, v2_computeHashOnElements as computeHashOnElements };
}

/**
 * Convert JSON string to JSON object
 *
 * NOTE: the String() wrapping is used so the behavior conforms to JSON.parse()
 * which can accept simple data types but is not represented in the default typing
 * @param x JSON string
 */
declare const parse: (x: string) => any;
/**
 * Convert JSON string to JSON object with all numbers as bigint
 * @param x JSON string
 */
declare const parseAlwaysAsBig: (x: string) => any;
/**
 * Convert JSON object to JSON string
 *
 * NOTE: the not-null assertion is used so the return type conforms to JSON.stringify()
 * which can also return undefined but is not represented in the default typing
 * @returns JSON string
 */
declare const stringify: (value: unknown, replacer?: any, space?: string | number | undefined, numberStringifiers?: json$1.NumberStringifier[] | undefined) => string;
/** @deprecated equivalent to 'stringify', alias will be removed */
declare const stringifyAlwaysAsBig: (value: unknown, replacer?: any, space?: string | number | undefined, numberStringifiers?: json$1.NumberStringifier[] | undefined) => string;

declare const json_parse: typeof parse;
declare const json_parseAlwaysAsBig: typeof parseAlwaysAsBig;
declare const json_stringify: typeof stringify;
declare const json_stringifyAlwaysAsBig: typeof stringifyAlwaysAsBig;
declare namespace json {
  export { json_parse as parse, json_parseAlwaysAsBig as parseAlwaysAsBig, json_stringify as stringify, json_stringifyAlwaysAsBig as stringifyAlwaysAsBig };
}

/**
 * Test if string is hex-string
 * @param hex hex-string
 */
declare function isHex(hex: string): boolean;
/**
 * Convert BigNumberish to bigint
 */
declare function toBigInt(value: BigNumberish): bigint;
/**
 * Test if value is bigint
 */
declare function isBigInt(value: any): value is bigint;
/**
 * Convert BigNumberish to hex-string
 * @returns format: hex-string
 */
declare function toHex(number: BigNumberish): string;
/**
 * Alias of ToHex
 */
declare const toHexString: typeof toHex;
/**
 * Convert BigNumberish to storage-key-string
 *
 * Same as toHex but conforming to the STORAGE_KEY pattern `^0x0[0-7]{1}[a-fA-F0-9]{0,62}$`.
 *
 * A storage key is represented as up to 62 hex digits, 3 bits, and 5 leading zeroes:
 * `0x0 + [0-7] + 62 hex = 0x + 64 hex`
 * @returns format: storage-key-string
 */
declare function toStorageKey(number: BigNumberish): string;
/**
 * Convert hexadecimal string to decimal string
 * @param hex hex-string
 * @returns format: decimal string
 */
declare function hexToDecimalString(hex: string): string;
/**
 * Remove hex string leading zero and lowercase it
 * @example '0x01A...' -> '0x1a..'
 * @param hex hex-string
 * @returns format: hex-string
 */
declare const cleanHex: (hex: string) => string;
/**
 * Asserts input is equal to or greater then lowerBound and lower then upperBound.
 *
 * The `inputName` parameter is used in the assertion message.
 */
declare function assertInRange(input: BigNumberish, lowerBound: BigNumberish, upperBound: BigNumberish, inputName?: string): void;
/**
 * Convert BigNumberish array to decimal string array
 * @returns format: decimal string array
 */
declare function bigNumberishArrayToDecimalStringArray(rawCalldata: BigNumberish[]): string[];
/**
 * Convert BigNumberish array to hexadecimal string array
 * @returns format: hex-string array
 */
declare function bigNumberishArrayToHexadecimalStringArray(rawCalldata: BigNumberish[]): string[];
/**
 * Test if string is whole number (0, 1, 2, 3...)
 */
declare const isStringWholeNumber: (value: string) => boolean;
/**
 * Convert string to decimal string
 * @returns format: decimal string
 */
declare function getDecimalString(value: string): string;
/**
 * Convert string to hexadecimal string
 * @returns format: hex-string
 */
declare function getHexString(value: string): string;
/**
 * Convert string array to hex-string array
 * @returns format: hex-string array
 */
declare function getHexStringArray(value: Array<string>): string[];
/**
 * Convert boolean to "0" or "1"
 */
declare const toCairoBool: (value: boolean) => string;
/**
 * Convert hex-string to an array of Bytes (Uint8Array)
 * @param value hex-string
 */
declare function hexToBytes(value: string): Uint8Array;
/**
 *
 * @param number value to be increased
 * @param percent integer as percent ex. 50 for 50%
 * @returns increased value
 */
declare function addPercent(number: BigNumberish, percent: number): bigint;
/**
 * Check if a value is a number.
 *
 * @param {unknown} value - The value to check.
 * @return {boolean} Returns true if the value is a number, otherwise returns false.
 */
declare function isNumber(value: unknown): value is number;
/**
 * Checks if a given value is of boolean type.
 *
 * @param {unknown} value - The value to check.
 * @return {boolean} - True if the value is of boolean type, false otherwise.
 */
declare function isBoolean(value: unknown): value is boolean;

type num_BigNumberish = BigNumberish;
declare const num_addPercent: typeof addPercent;
declare const num_assertInRange: typeof assertInRange;
declare const num_bigNumberishArrayToDecimalStringArray: typeof bigNumberishArrayToDecimalStringArray;
declare const num_bigNumberishArrayToHexadecimalStringArray: typeof bigNumberishArrayToHexadecimalStringArray;
declare const num_cleanHex: typeof cleanHex;
declare const num_getDecimalString: typeof getDecimalString;
declare const num_getHexString: typeof getHexString;
declare const num_getHexStringArray: typeof getHexStringArray;
declare const num_hexToBytes: typeof hexToBytes;
declare const num_hexToDecimalString: typeof hexToDecimalString;
declare const num_isBigInt: typeof isBigInt;
declare const num_isBoolean: typeof isBoolean;
declare const num_isHex: typeof isHex;
declare const num_isNumber: typeof isNumber;
declare const num_isStringWholeNumber: typeof isStringWholeNumber;
declare const num_toBigInt: typeof toBigInt;
declare const num_toCairoBool: typeof toCairoBool;
declare const num_toHex: typeof toHex;
declare const num_toHexString: typeof toHexString;
declare const num_toStorageKey: typeof toStorageKey;
declare namespace num {
  export { type num_BigNumberish as BigNumberish, num_addPercent as addPercent, num_assertInRange as assertInRange, num_bigNumberishArrayToDecimalStringArray as bigNumberishArrayToDecimalStringArray, num_bigNumberishArrayToHexadecimalStringArray as bigNumberishArrayToHexadecimalStringArray, num_cleanHex as cleanHex, num_getDecimalString as getDecimalString, num_getHexString as getHexString, num_getHexStringArray as getHexStringArray, num_hexToBytes as hexToBytes, num_hexToDecimalString as hexToDecimalString, num_isBigInt as isBigInt, num_isBoolean as isBoolean, num_isHex as isHex, num_isNumber as isNumber, num_isStringWholeNumber as isStringWholeNumber, num_toBigInt as toBigInt, num_toCairoBool as toCairoBool, num_toHex as toHex, num_toHexString as toHexString, num_toStorageKey as toStorageKey };
}

/**
 * Transforms a list of Calls, each with their own calldata, into
 * two arrays: one with the entry points, and one with the concatenated calldata
 */
declare const transformCallsToMulticallArrays: (calls: Call[]) => {
    callArray: ParsedStruct[];
    calldata: Calldata;
};
/**
 * Transforms a list of calls into the Cairo 0 `__execute__` calldata.
 */
declare const fromCallsToExecuteCalldata: (calls: Call[]) => Calldata;
/**
 * Transforms a list of calls into the Cairo 0 `__execute__` calldata including nonce.
 *
 * @deprecated
 */
declare const fromCallsToExecuteCalldataWithNonce: (calls: Call[], nonce: BigNumberish) => Calldata;
/**
 * Format Data inside Calls
 *
 * @deprecated Not required for getting execute Calldata
 */
declare const transformCallsToMulticallArrays_cairo1: (calls: Call[]) => CallStruct[];
/**
 * Transforms a list of calls into the Cairo 1 `__execute__` calldata.
 */
declare const fromCallsToExecuteCalldata_cairo1: (calls: Call[]) => Calldata;
/**
 * Create `__execute__` Calldata from Calls based on Cairo versions
 */
declare const getExecuteCalldata: (calls: Call[], cairoVersion?: CairoVersion) => Calldata;
declare function buildUDCCall(payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[], address: string): {
    calls: {
        contractAddress: string;
        entrypoint: string;
        calldata: BigNumberish[];
    }[];
    addresses: string[];
};
/**
 * Return transaction versions based on version type, default version type is 'transaction'
 */
declare function getVersionsByType(versionType?: 'fee' | 'transaction'): {
    v1: ETransactionVersion;
    v2: ETransactionVersion;
    v3: ETransactionVersion;
};

declare const transaction_buildUDCCall: typeof buildUDCCall;
declare const transaction_fromCallsToExecuteCalldata: typeof fromCallsToExecuteCalldata;
declare const transaction_fromCallsToExecuteCalldataWithNonce: typeof fromCallsToExecuteCalldataWithNonce;
declare const transaction_fromCallsToExecuteCalldata_cairo1: typeof fromCallsToExecuteCalldata_cairo1;
declare const transaction_getExecuteCalldata: typeof getExecuteCalldata;
declare const transaction_getVersionsByType: typeof getVersionsByType;
declare const transaction_transformCallsToMulticallArrays: typeof transformCallsToMulticallArrays;
declare const transaction_transformCallsToMulticallArrays_cairo1: typeof transformCallsToMulticallArrays_cairo1;
declare namespace transaction {
  export { transaction_buildUDCCall as buildUDCCall, transaction_fromCallsToExecuteCalldata as fromCallsToExecuteCalldata, transaction_fromCallsToExecuteCalldataWithNonce as fromCallsToExecuteCalldataWithNonce, transaction_fromCallsToExecuteCalldata_cairo1 as fromCallsToExecuteCalldata_cairo1, transaction_getExecuteCalldata as getExecuteCalldata, transaction_getVersionsByType as getVersionsByType, transaction_transformCallsToMulticallArrays as transformCallsToMulticallArrays, transaction_transformCallsToMulticallArrays_cairo1 as transformCallsToMulticallArrays_cairo1 };
}

/**
 * Compress compiled Cairo program
 *
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/services/api/gateway/transaction.py#L54-L58)
 * @param jsonProgram Representing the compiled cairo program
 */
declare function compressProgram(jsonProgram: Program | string): CompressedProgram;
/**
 * Decompress compressed compiled Cairo program
 * @param base64 Compressed program
 * @returns Parsed decompressed compiled Cairo program
 */
declare function decompressProgram(base64: CompressedProgram): any;
/**
 * Random Address based on random keyPair
 */
declare function randomAddress(): string;
/**
 * Lowercase and hex prefix string
 *
 * @deprecated Not used internally, naming is confusing based on functionality
 */
declare function makeAddress(input: string): string;
/**
 * Format Signature to standard type (hex array)
 * @returns Custom hex array or weierstrass.SignatureType hex array
 */
declare function formatSignature(sig?: Signature): ArraySignatureType;
/**
 * Format Signature to decimal string array
 */
declare function signatureToDecimalArray(sig?: Signature): ArraySignatureType;
/**
 * Format Signature to hex string array
 */
declare function signatureToHexArray(sig?: Signature): ArraySignatureType;
/**
 * Convert estimated fee to max fee with overhead
 */
declare function estimatedFeeToMaxFee(estimatedFee: BigNumberish, overhead?: number): bigint;
declare function estimateFeeToBounds(estimate: FeeEstimate | 0n, amountOverhead?: number, priceOverhead?: number): ResourceBounds$1;
declare function intDAM(dam: EDataAvailabilityMode): EDAMode;
/**
 * Convert to ETransactionVersion or throw an error.
 * Return providedVersion is specified else return defaultVersion
 * @param defaultVersion BigNumberish
 * @param providedVersion BigNumberish | undefined
 * @returns ETransactionVersion
 */
declare function toTransactionVersion(defaultVersion: BigNumberish, providedVersion?: BigNumberish): ETransactionVersion;
/**
 * Convert Transaction version to Fee version or throw an error
 * @param providedVersion BigNumberish | undefined
 */
declare function toFeeVersion(providedVersion?: BigNumberish): ETransactionVersion.F0 | ETransactionVersion.F1 | ETransactionVersion.F2 | ETransactionVersion.F3 | undefined;
/**
 * Return provided or default v3 tx details
 */
declare function v3Details(details: UniversalDetails): {
    tip: BigNumberish;
    paymasterData: BigNumberish[];
    accountDeploymentData: BigNumberish[];
    nonceDataAvailabilityMode: EDataAvailabilityMode;
    feeDataAvailabilityMode: EDataAvailabilityMode;
    resourceBounds: RESOURCE_BOUNDS_MAPPING$1;
};
/**
 * It will reduce V2 to V1, else (V3) stay the same
 * F2 -> F1
 * V2 -> V1
 * F3 -> F3
 * V3 -> V3
 */
declare function reduceV2(providedVersion: ETransactionVersion): ETransactionVersion.V0 | ETransactionVersion.V1 | ETransactionVersion.V3 | ETransactionVersion.F0 | ETransactionVersion.F1 | ETransactionVersion.F3;

declare const stark_compressProgram: typeof compressProgram;
declare const stark_decompressProgram: typeof decompressProgram;
declare const stark_estimateFeeToBounds: typeof estimateFeeToBounds;
declare const stark_estimatedFeeToMaxFee: typeof estimatedFeeToMaxFee;
declare const stark_formatSignature: typeof formatSignature;
declare const stark_intDAM: typeof intDAM;
declare const stark_makeAddress: typeof makeAddress;
declare const stark_randomAddress: typeof randomAddress;
declare const stark_reduceV2: typeof reduceV2;
declare const stark_signatureToDecimalArray: typeof signatureToDecimalArray;
declare const stark_signatureToHexArray: typeof signatureToHexArray;
declare const stark_toFeeVersion: typeof toFeeVersion;
declare const stark_toTransactionVersion: typeof toTransactionVersion;
declare const stark_v3Details: typeof v3Details;
declare namespace stark {
  export { stark_compressProgram as compressProgram, stark_decompressProgram as decompressProgram, stark_estimateFeeToBounds as estimateFeeToBounds, stark_estimatedFeeToMaxFee as estimatedFeeToMaxFee, stark_formatSignature as formatSignature, stark_intDAM as intDAM, stark_makeAddress as makeAddress, stark_randomAddress as randomAddress, stark_reduceV2 as reduceV2, stark_signatureToDecimalArray as signatureToDecimalArray, stark_signatureToHexArray as signatureToHexArray, stark_toFeeVersion as toFeeVersion, stark_toTransactionVersion as toTransactionVersion, stark_v3Details as v3Details };
}

/**
 * Get random Ethereum private Key.
 * @returns an Hex string
 * @example
 * ```typescript
 * const myPK: string = randomAddress()
 * // result = "0xf04e69ac152fba37c02929c2ae78c9a481461dda42dbc6c6e286be6eb2a8ab83"
 * ```
 */
declare function ethRandomPrivateKey(): string;
/**
 * Get a string formatted for an Ethereum address, without uppercase characters.
 * @param {BigNumberish} address Address of an Ethereum account.
 * @returns an Hex string coded on 20 bytes
 * @example
 * ```typescript
 * const myEthAddress: string = validateAndParseEthAddress("0x8359E4B0152ed5A731162D3c7B0D8D56edB165")
 * // result = "0x008359e4b0152ed5a731162d3c7b0d8d56edb165"
 * ```
 */
declare function validateAndParseEthAddress(address: BigNumberish): string;

declare const eth_ethRandomPrivateKey: typeof ethRandomPrivateKey;
declare const eth_validateAndParseEthAddress: typeof validateAndParseEthAddress;
declare namespace eth {
  export { eth_ethRandomPrivateKey as ethRandomPrivateKey, eth_validateAndParseEthAddress as validateAndParseEthAddress };
}

declare class MerkleTree {
    leaves: string[];
    branches: string[][];
    root: string;
    hashMethod: (a: BigNumberish, b: BigNumberish) => string;
    constructor(leafHashes: string[], hashMethod?: (a: BigNumberish, b: BigNumberish) => string);
    /**
     * Create Merkle tree
     * @param leaves hex-string array
     * @returns format: hex-string; Merkle tree root
     */
    private build;
    /**
     * Create hash from ordered a and b, Pedersen hash default
     * @returns format: hex-string
     */
    static hash(a: BigNumberish, b: BigNumberish, hashMethod?: (a: BigNumberish, b: BigNumberish) => string): string;
    /**
     * Return path to leaf
     * @param leaf hex-string
     * @param branch hex-string array
     * @param hashPath hex-string array
     * @returns format: hex-string array
     */
    getProof(leaf: string, branch?: string[], hashPath?: string[]): string[];
}
/**
 * Test Merkle tree path
 * @param root hex-string
 * @param leaf hex-string
 * @param path hex-string array
 * @param hashMethod hash method override, Pedersen default
 */
declare function proofMerklePath(root: string, leaf: string, path: string[], hashMethod?: (a: BigNumberish, b: BigNumberish) => string): boolean;

type merkle_MerkleTree = MerkleTree;
declare const merkle_MerkleTree: typeof MerkleTree;
declare const merkle_proofMerklePath: typeof proofMerklePath;
declare namespace merkle {
  export { merkle_MerkleTree as MerkleTree, merkle_proofMerklePath as proofMerklePath };
}

/**
 * Singular class handling cairo u256 data type
 */

declare const UINT_128_MAX: bigint;
declare const UINT_256_MAX: bigint;
declare const UINT_256_MIN = 0n;
declare const UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;
declare const UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;
declare const UINT_256_LOW_MIN = 0n;
declare const UINT_256_HIGH_MIN = 0n;
declare class CairoUint256 {
    low: bigint;
    high: bigint;
    static abiSelector: string;
    /**
     * Default constructor (Lib usage)
     * @param bigNumberish BigNumberish value representing uin256
     */
    constructor(bigNumberish: BigNumberish);
    /**
     * Direct props initialization (Api response)
     */
    constructor(low: BigNumberish, high: BigNumberish);
    /**
     * Initialization from Uint256 object
     */
    constructor(uint256: Uint256);
    /**
     * Validate if BigNumberish can be represented as Unit256
     */
    static validate(bigNumberish: BigNumberish): bigint;
    /**
     * Validate if low and high can be represented as Unit256
     */
    static validateProps(low: BigNumberish, high: BigNumberish): {
        low: bigint;
        high: bigint;
    };
    /**
     * Check if BigNumberish can be represented as Unit256
     */
    static is(bigNumberish: BigNumberish): boolean;
    /**
     * Check if provided abi type is this data type
     */
    static isAbiType(abiType: string): boolean;
    /**
     * Return bigint representation
     */
    toBigInt(): bigint;
    /**
     * Return Uint256 structure with HexString props
     * {low: HexString, high: HexString}
     */
    toUint256HexString(): {
        low: string;
        high: string;
    };
    /**
     * Return Uint256 structure with DecimalString props
     * {low: DecString, high: DecString}
     */
    toUint256DecimalString(): {
        low: string;
        high: string;
    };
    /**
     * Return api requests representation witch is felt array
     */
    toApiRequest(): string[];
}

/**
 * Convert Uint256 to bigint
 * Legacy support Export
 */
declare function uint256ToBN(uint256: Uint256): bigint;
/**
 * Test BigNumberish is smaller or equal 2**256-1
 * Legacy support Export
 */
declare function isUint256(bn: BigNumberish): boolean;
/**
 * Convert BigNumberish (string | number | bigint) to Uint256 (hex)
 * Legacy support Export
 */
declare function bnToUint256(bn: BigNumberish): Uint256;

declare const uint256$1_UINT_128_MAX: typeof UINT_128_MAX;
declare const uint256$1_UINT_256_MAX: typeof UINT_256_MAX;
declare const uint256$1_bnToUint256: typeof bnToUint256;
declare const uint256$1_isUint256: typeof isUint256;
declare const uint256$1_uint256ToBN: typeof uint256ToBN;
declare namespace uint256$1 {
  export { uint256$1_UINT_128_MAX as UINT_128_MAX, uint256$1_UINT_256_MAX as UINT_256_MAX, uint256$1_bnToUint256 as bnToUint256, uint256$1_isUint256 as isUint256, uint256$1_uint256ToBN as uint256ToBN };
}

/**
 * Test if string contains only ASCII characters (string can be ascii text)
 */
declare function isASCII(str: string): boolean;
/**
 * Test if string is a Cairo short string (string has less or equal 31 characters)
 */
declare function isShortString(str: string): boolean;
/**
 * Test if string contains only numbers (string can be converted to decimal number)
 */
declare function isDecimalString(str: string): boolean;
/**
 * Checks if a given value is a string.
 *
 * @param {unknown} value - The value to be checked.
 * @return {boolean} - Returns true if the value is a string, false otherwise.
 */
declare function isString(value: unknown): value is string;
/**
 * Test if value is a free-from string text, and not a hex string or number string
 */
declare function isText(val: any): boolean;
/**
 * Test if value is short text
 */
declare const isShortText: (val: any) => boolean;
/**
 * Test if value is long text
 */
declare const isLongText: (val: any) => boolean;
/**
 * Split long text into short strings
 */
declare function splitLongString(longStr: string): string[];
/**
 * Convert an ASCII string to a hexadecimal string.
 * @param str short string (ASCII string, 31 characters max)
 * @returns format: hex-string; 248 bits max
 * @example
 * ```typescript
 * const myEncodedString: string = encodeShortString("uri/pict/t38.jpg");
 * // return hex string (ex."0x7572692f706963742f7433382e6a7067")
 * ```
 */
declare function encodeShortString(str: string): string;
/**
 * Convert a hexadecimal or decimal string to an ASCII string.
 * @param str representing a 248 bit max number (ex. "0x1A4F64EA56" or "236942575435676423")
 * @returns format: short string; 31 characters max
 * @example
 * ```typescript
 * const myDecodedString: string = decodeShortString("0x7572692f706963742f7433382e6a7067");
 * // return string (ex."uri/pict/t38.jpg")
 * ```
 */
declare function decodeShortString(str: string): string;

declare const shortString_decodeShortString: typeof decodeShortString;
declare const shortString_encodeShortString: typeof encodeShortString;
declare const shortString_isASCII: typeof isASCII;
declare const shortString_isDecimalString: typeof isDecimalString;
declare const shortString_isLongText: typeof isLongText;
declare const shortString_isShortString: typeof isShortString;
declare const shortString_isShortText: typeof isShortText;
declare const shortString_isString: typeof isString;
declare const shortString_isText: typeof isText;
declare const shortString_splitLongString: typeof splitLongString;
declare namespace shortString {
  export { shortString_decodeShortString as decodeShortString, shortString_encodeShortString as encodeShortString, shortString_isASCII as isASCII, shortString_isDecimalString as isDecimalString, shortString_isLongText as isLongText, shortString_isShortString as isShortString, shortString_isShortText as isShortText, shortString_isString as isString, shortString_isText as isText, shortString_splitLongString as splitLongString };
}

interface Context {
    parent?: string;
    key?: string;
}
declare function prepareSelector(selector: string): string;
declare function isMerkleTreeType(type: StarknetType): type is StarknetMerkleType;
/**
 * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once
 * in the resulting array.
 */
declare function getDependencies(types: TypedData['types'], type: string, dependencies?: string[], contains?: string, revision?: TypedDataRevision): string[];
/**
 * Encode a type to a string. All dependent types are alphabetically sorted.
 */
declare function encodeType(types: TypedData['types'], type: string, revision?: TypedDataRevision): string;
/**
 * Get a type string as hash.
 */
declare function getTypeHash(types: TypedData['types'], type: string, revision?: TypedDataRevision): string;
/**
 * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of
 * an array of ABI compatible types, and an array of corresponding values.
 */
declare function encodeValue(types: TypedData['types'], type: string, data: unknown, ctx?: Context, revision?: TypedDataRevision): [string, string];
/**
 * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values.
 * All dependent types are automatically encoded.
 */
declare function encodeData<T extends TypedData>(types: T['types'], type: string, data: T['message'], revision?: TypedDataRevision): string[][];
/**
 * Get encoded data as a hash. The data should be a key -> value object with all the required values.
 * All dependent types are automatically encoded.
 */
declare function getStructHash<T extends TypedData>(types: T['types'], type: string, data: T['message'], revision?: TypedDataRevision): string;
/**
 * Get the SNIP-12 encoded message to sign, from the typedData object.
 */
declare function getMessageHash(typedData: TypedData, account: BigNumberish): string;

declare const typedData_StarknetDomain: typeof StarknetDomain;
declare const typedData_StarknetEnumType: typeof StarknetEnumType;
declare const typedData_StarknetMerkleType: typeof StarknetMerkleType;
declare const typedData_StarknetType: typeof StarknetType;
declare const typedData_TypedData: typeof TypedData;
declare const typedData_TypedDataRevision: typeof TypedDataRevision;
declare const typedData_encodeData: typeof encodeData;
declare const typedData_encodeType: typeof encodeType;
declare const typedData_encodeValue: typeof encodeValue;
declare const typedData_getDependencies: typeof getDependencies;
declare const typedData_getMessageHash: typeof getMessageHash;
declare const typedData_getStructHash: typeof getStructHash;
declare const typedData_getTypeHash: typeof getTypeHash;
declare const typedData_isMerkleTreeType: typeof isMerkleTreeType;
declare const typedData_prepareSelector: typeof prepareSelector;
declare namespace typedData {
  export { typedData_StarknetDomain as StarknetDomain, typedData_StarknetEnumType as StarknetEnumType, typedData_StarknetMerkleType as StarknetMerkleType, typedData_StarknetType as StarknetType, typedData_TypedData as TypedData, typedData_TypedDataRevision as TypedDataRevision, typedData_encodeData as encodeData, typedData_encodeType as encodeType, typedData_encodeValue as encodeValue, typedData_getDependencies as getDependencies, typedData_getMessageHash as getMessageHash, typedData_getStructHash as getStructHash, typedData_getTypeHash as getTypeHash, typedData_isMerkleTreeType as isMerkleTreeType, typedData_prepareSelector as prepareSelector };
}

declare function useDecoded(encoded: bigint[]): string;
declare function useEncoded(decoded: string): bigint;
declare const enum StarknetIdContract {
    MAINNET = "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678",
    TESTNET = "0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce",
    TESTNET_SEPOLIA = "0x0707f09bc576bd7cfee59694846291047e965f4184fe13dac62c56759b3b6fa7"
}
declare function getStarknetIdContract(chainId: StarknetChainId): string;
declare const enum StarknetIdIdentityContract {
    MAINNET = "0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af",
    TESTNET = "0x783a9097b26eae0586373b2ce0ed3529ddc44069d1e0fbc4f66d42b69d6850d",
    TESTNET_SEPOLIA = "0x070DF8B4F5cb2879f8592849fA8f3134da39d25326B8558cc9C8FE8D47EA3A90"
}
declare function getStarknetIdIdentityContract(chainId: StarknetChainId): string;
declare const StarknetIdMulticallContract = "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970";
declare function getStarknetIdMulticallContract(chainId: StarknetChainId): string;
declare const enum StarknetIdVerifierContract {
    MAINNET = "0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf",
    TESTNET = "0x057c942544063c3aea6ea6c37009cc9d1beacd750cb6801549a129c7265f0f11",
    TESTNET_SEPOLIA = "0x0182EcE8173C216A395f4828e1523541b7e3600bf190CB252E1a1A0cE219d184"
}
declare function getStarknetIdVerifierContract(chainId: StarknetChainId): string;
declare const enum StarknetIdPfpContract {
    MAINNET = "0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7",
    TESTNET = "0x03cac3228b434259734ee0e4ff445f642206ea11adace7e4f45edd2596748698",
    TESTNET_SEPOLIA = "0x058061bb6bdc501eE215172c9f87d557C1E0f466dC498cA81b18f998Bf1362b2"
}
declare function getStarknetIdPfpContract(chainId: StarknetChainId): string;
declare const enum StarknetIdPopContract {
    MAINNET = "0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4",
    TESTNET = "0x03528caf090179e337931ee669a5b0214041e1bae30d460ff07d2cea2c7a9106",
    TESTNET_SEPOLIA = "0x0023FE3b845ed5665a9eb3792bbB17347B490EE4090f855C1298d03BB5F49B49"
}
declare function getStarknetIdPopContract(chainId: StarknetChainId): string;
declare function execution(staticEx: {} | undefined, ifEqual?: number[] | undefined, ifNotEqual?: number[] | undefined): CairoCustomEnum;
declare function dynamicFelt(hardcoded: BigNumberish | undefined, reference?: number[] | undefined): CairoCustomEnum;
declare function dynamicCallData(hardcoded: BigNumberish | undefined, reference?: BigNumberish[] | undefined, arrayReference?: BigNumberish[] | undefined): CairoCustomEnum;

type starknetId_StarknetIdContract = StarknetIdContract;
declare const starknetId_StarknetIdContract: typeof StarknetIdContract;
type starknetId_StarknetIdIdentityContract = StarknetIdIdentityContract;
declare const starknetId_StarknetIdIdentityContract: typeof StarknetIdIdentityContract;
declare const starknetId_StarknetIdMulticallContract: typeof StarknetIdMulticallContract;
type starknetId_StarknetIdPfpContract = StarknetIdPfpContract;
declare const starknetId_StarknetIdPfpContract: typeof StarknetIdPfpContract;
type starknetId_StarknetIdPopContract = StarknetIdPopContract;
declare const starknetId_StarknetIdPopContract: typeof StarknetIdPopContract;
type starknetId_StarknetIdVerifierContract = StarknetIdVerifierContract;
declare const starknetId_StarknetIdVerifierContract: typeof StarknetIdVerifierContract;
declare const starknetId_dynamicCallData: typeof dynamicCallData;
declare const starknetId_dynamicFelt: typeof dynamicFelt;
declare const starknetId_execution: typeof execution;
declare const starknetId_getStarknetIdContract: typeof getStarknetIdContract;
declare const starknetId_getStarknetIdIdentityContract: typeof getStarknetIdIdentityContract;
declare const starknetId_getStarknetIdMulticallContract: typeof getStarknetIdMulticallContract;
declare const starknetId_getStarknetIdPfpContract: typeof getStarknetIdPfpContract;
declare const starknetId_getStarknetIdPopContract: typeof getStarknetIdPopContract;
declare const starknetId_getStarknetIdVerifierContract: typeof getStarknetIdVerifierContract;
declare const starknetId_useDecoded: typeof useDecoded;
declare const starknetId_useEncoded: typeof useEncoded;
declare namespace starknetId {
  export { starknetId_StarknetIdContract as StarknetIdContract, starknetId_StarknetIdIdentityContract as StarknetIdIdentityContract, starknetId_StarknetIdMulticallContract as StarknetIdMulticallContract, starknetId_StarknetIdPfpContract as StarknetIdPfpContract, starknetId_StarknetIdPopContract as StarknetIdPopContract, starknetId_StarknetIdVerifierContract as StarknetIdVerifierContract, starknetId_dynamicCallData as dynamicCallData, starknetId_dynamicFelt as dynamicFelt, starknetId_execution as execution, starknetId_getStarknetIdContract as getStarknetIdContract, starknetId_getStarknetIdIdentityContract as getStarknetIdIdentityContract, starknetId_getStarknetIdMulticallContract as getStarknetIdMulticallContract, starknetId_getStarknetIdPfpContract as getStarknetIdPfpContract, starknetId_getStarknetIdPopContract as getStarknetIdPopContract, starknetId_getStarknetIdVerifierContract as getStarknetIdVerifierContract, starknetId_useDecoded as useDecoded, starknetId_useEncoded as useEncoded };
}

/**
 * Helper - Async Sleep for 'delay' time
 */
declare function wait(delay: number): Promise<unknown>;
/**
 * Create Sierra Contract Class from a given Compiled Sierra
 *
 * CompiledSierra -> SierraContractClass
 */
declare function createSierraContractClass(contract: CompiledSierra): SierraContractClass;
/**
 * Create Contract Class from a given CompiledContract or string
 *
 * (CompiledContract or string) -> ContractClass
 */
declare function parseContract(contract: CompiledContract | string): ContractClass;
/**
 * Return randomly select available public node
 * @param networkName NetworkName
 * @param mute mute public node warning
 * @returns default node url
 */
declare const getDefaultNodeUrl: (networkName?: NetworkName, mute?: boolean) => string;
/**
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/fc97bdd8322a7df043c87c371634b26c15ed6cee/src/starkware/starknet/services/api/feeder_gateway/feeder_gateway_client.py#L148-L153)
 */
declare function formatHash(hashValue: BigNumberish): string;
/**
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/fc97bdd8322a7df043c87c371634b26c15ed6cee/src/starkware/starknet/services/api/feeder_gateway/feeder_gateway_client.py#L156-L161)
 */
declare function txIdentifier(txHash?: BigNumberish, txId?: BigNumberish): string;
declare const validBlockTags: BlockTag[];
declare class Block {
    hash: BlockIdentifier;
    number: BlockIdentifier;
    tag: BlockIdentifier;
    private setIdentifier;
    constructor(_identifier: BlockIdentifier);
    get queryIdentifier(): any;
    get identifier(): any;
    set identifier(_identifier: BlockIdentifier);
    valueOf: () => BlockIdentifier;
    toString: () => BlockIdentifier;
}
declare function isV3Tx(details: InvocationsDetailsWithNonce): details is V3TransactionDetails;
declare function isVersion(version: '0.5' | '0.6' | '0.7', response: string): boolean;
/**
 * Guard Pending Block
 */
declare function isPendingBlock(response: GetBlockResponse): response is PendingBlock;
/**
 * Guard Pending Transaction
 */
declare function isPendingTransaction(response: GetTransactionReceiptResponse): boolean;
/**
 * Guard Pending State Update
 * ex. if(isPendingStateUpdate(stateUpdate)) throw Error('Update must be final')
 */
declare function isPendingStateUpdate(response: StateUpdateResponse): response is PendingStateUpdate;

type provider_Block = Block;
declare const provider_Block: typeof Block;
declare const provider_createSierraContractClass: typeof createSierraContractClass;
declare const provider_formatHash: typeof formatHash;
declare const provider_getDefaultNodeUrl: typeof getDefaultNodeUrl;
declare const provider_isPendingBlock: typeof isPendingBlock;
declare const provider_isPendingStateUpdate: typeof isPendingStateUpdate;
declare const provider_isPendingTransaction: typeof isPendingTransaction;
declare const provider_isV3Tx: typeof isV3Tx;
declare const provider_isVersion: typeof isVersion;
declare const provider_parseContract: typeof parseContract;
declare const provider_txIdentifier: typeof txIdentifier;
declare const provider_validBlockTags: typeof validBlockTags;
declare const provider_wait: typeof wait;
declare namespace provider {
  export { provider_Block as Block, provider_createSierraContractClass as createSierraContractClass, provider_formatHash as formatHash, provider_getDefaultNodeUrl as getDefaultNodeUrl, provider_isPendingBlock as isPendingBlock, provider_isPendingStateUpdate as isPendingStateUpdate, provider_isPendingTransaction as isPendingTransaction, provider_isV3Tx as isV3Tx, provider_isVersion as isVersion, provider_parseContract as parseContract, provider_txIdentifier as txIdentifier, provider_validBlockTags as validBlockTags, provider_wait as wait };
}

declare function getAbiEvents(abi: Abi): AbiEvents;
/**
 * Parse raw events and structure them into response object based on a contract structs and defined events
 * @param providerReceivedEvents ProviderEvent[] - Array of raw events
 * @param abiEvents AbiEvents - Events defined in the abi
 * @param abiStructs AbiStructs - Structs defined in the abi
 * @return ParsedEvents - parsed events corresponding to the abi
 */
declare function parseEvents(providerReceivedEvents: Event[], abiEvents: AbiEvents, abiStructs: AbiStructs, abiEnums: AbiEnums): ParsedEvents;

declare const index_getAbiEvents: typeof getAbiEvents;
declare const index_parseEvents: typeof parseEvents;
declare namespace index {
  export { index_getAbiEvents as getAbiEvents, index_parseEvents as parseEvents };
}

/**
 * Singular class handling cairo u512 data type
 */

declare const UINT_512_MAX: bigint;
declare const UINT_512_MIN = 0n;
declare const UINT_128_MIN = 0n;
declare class CairoUint512 {
    limb0: bigint;
    limb1: bigint;
    limb2: bigint;
    limb3: bigint;
    static abiSelector: string;
    /**
     * Default constructor (Lib usage)
     * @param bigNumberish BigNumberish value representing u512
     */
    constructor(bigNumberish: BigNumberish);
    /**
     * Direct props initialization (Api response)
     */
    constructor(limb0: BigNumberish, limb1: BigNumberish, limb2: BigNumberish, limb3: BigNumberish);
    /**
     * Initialization from Uint512 object
     */
    constructor(uint512: Uint512);
    /**
     * Validate if BigNumberish can be represented as Uint512
     */
    static validate(bigNumberish: BigNumberish): bigint;
    /**
     * Validate if limbs can be represented as Uint512
     */
    static validateProps(limb0: BigNumberish, limb1: BigNumberish, limb2: BigNumberish, limb3: BigNumberish): {
        limb0: bigint;
        limb1: bigint;
        limb2: bigint;
        limb3: bigint;
    };
    /**
     * Check if BigNumberish can be represented as Uint512
     */
    static is(bigNumberish: BigNumberish): boolean;
    /**
     * Check if provided abi type is this data type
     */
    static isAbiType(abiType: string): boolean;
    /**
     * Return bigint representation
     */
    toBigInt(): bigint;
    /**
     * Return Uint512 structure with HexString props
     * limbx: HexString
     */
    toUint512HexString(): {
        limb0: string;
        limb1: string;
        limb2: string;
        limb3: string;
    };
    /**
     * Return Uint512 structure with DecimalString props
     * limbx DecString
     */
    toUint512DecimalString(): {
        limb0: string;
        limb1: string;
        limb2: string;
        limb3: string;
    };
    /**
     * Return api requests representation witch is felt array
     */
    toApiRequest(): string[];
}

/**
 * Format a hex number to '0x' and 64 characters, adding leading zeros if necessary.
 * @param {BigNumberish} address
 * @returns {string} Hex string : 0x followed by 64 characters. No upper case characters in the response.
 */
declare function addAddressPadding(address: BigNumberish): string;
/**
 * Check the validity of a Starknet address, and format it as a hex number : '0x' and 64 characters, adding leading zeros if necessary.
 * @param {BigNumberish} address
 * @returns {string} Hex string : 0x followed by 64 characters. No upper case characters in the response.
 */
declare function validateAndParseAddress(address: BigNumberish): string;
declare function getChecksumAddress(address: BigNumberish): string;
/**
 * If the casing of an address is mixed, it is a Checksum Address, which uses a specific pattern of uppercase and lowercase letters within
 * a given address to reduce the risk of errors introduced from typing an address or cut and paste issues.
 *
 * @param address string
 *
 * @returns true if the ChecksumAddress is valid
 */
declare function validateChecksumAddress(address: string): boolean;

/**
 * Loosely validate a URL `string`.
 */
declare function isUrl(s?: string): boolean;
declare function buildUrl(baseUrl: string, defaultPath: string, urlOrPath?: string): string;

declare abstract class AbiParserInterface {
    /**
     * Helper to calculate inputs length from abi
     * @param abiMethod FunctionAbi
     * @return number
     */
    abstract methodInputsLength(abiMethod: FunctionAbi): number;
    /**
     *
     * @param name string
     * @return FunctionAbi | undefined
     */
    abstract getMethod(name: string): FunctionAbi | undefined;
    /**
     * Return Abi in legacy format
     * @return Abi
     */
    abstract getLegacyFormat(): Abi;
}

declare const isLen: (name: string) => boolean;
declare const isTypeFelt: (type: string) => boolean;
declare const isTypeArray: (type: string) => boolean;
declare const isTypeTuple: (type: string) => boolean;
declare const isTypeNamedTuple: (type: string) => boolean;
declare const isTypeStruct: (type: string, structs: AbiStructs) => boolean;
declare const isTypeEnum: (type: string, enums: AbiEnums) => boolean;
declare const isTypeOption: (type: string) => boolean;
declare const isTypeResult: (type: string) => boolean;
declare const isTypeUint: (type: string) => boolean;
declare const isTypeUint256: (type: string) => boolean;
declare const isTypeLiteral: (type: string) => boolean;
declare const isTypeBool: (type: string) => boolean;
declare const isTypeContractAddress: (type: string) => boolean;
declare const isTypeEthAddress: (type: string) => boolean;
declare const isTypeBytes31: (type: string) => boolean;
declare const isTypeByteArray: (type: string) => boolean;
declare const isTypeSecp256k1Point: (type: string) => boolean;
declare const isCairo1Type: (type: string) => boolean;
declare const getArrayType: (type: string) => string;
/**
 * Test if an ABI comes from a Cairo 1 contract
 * @param abi representing the interface of a Cairo contract
 * @returns TRUE if it is an ABI from a Cairo1 contract
 * @example
 * ```typescript
 * const isCairo1: boolean = isCairo1Abi(myAbi: Abi);
 * ```
 */
declare function isCairo1Abi(abi: Abi): boolean;
/**
 * Return ContractVersion (Abi version) based on Abi
 * or undefined for unknown version
 * @param abi
 * @returns string
 */
declare function getAbiContractVersion(abi: Abi): ContractVersion;
/**
 * named tuple cairo type is described as js object {}
 * struct cairo type are described as js object {}
 * array cairo type are described as js array []
 */
/**
 * Create Uint256 Cairo type (helper for common struct type)
 * @example
 * ```typescript
 * uint256('892349863487563453485768723498');
 * ```
 */
declare const uint256: (it: BigNumberish) => Uint256;
/**
 * Create Uint512 Cairo type (helper for common struct type)
 * @param it BigNumberish representation of a 512 bits unsigned number
 * @returns Uint512 struct
 * @example
 * ```typescript
 * uint512('345745685892349863487563453485768723498');
 * ```
 */
declare const uint512: (it: BigNumberish) => Uint512;
/**
 * Create unnamed tuple Cairo type (helper same as common struct type)
 * @example
 * ```typescript
 * tuple(1, '0x101', 16);
 * ```
 */
declare const tuple: (...args: (BigNumberish | object | boolean)[]) => Record<number, BigNumberish | object | boolean>;
/**
 * Create felt Cairo type (cairo type helper)
 * @returns format: felt-string
 */
declare function felt(it: BigNumberish): string;

declare const cairo_felt: typeof felt;
declare const cairo_getAbiContractVersion: typeof getAbiContractVersion;
declare const cairo_getArrayType: typeof getArrayType;
declare const cairo_isCairo1Abi: typeof isCairo1Abi;
declare const cairo_isCairo1Type: typeof isCairo1Type;
declare const cairo_isLen: typeof isLen;
declare const cairo_isTypeArray: typeof isTypeArray;
declare const cairo_isTypeBool: typeof isTypeBool;
declare const cairo_isTypeByteArray: typeof isTypeByteArray;
declare const cairo_isTypeBytes31: typeof isTypeBytes31;
declare const cairo_isTypeContractAddress: typeof isTypeContractAddress;
declare const cairo_isTypeEnum: typeof isTypeEnum;
declare const cairo_isTypeEthAddress: typeof isTypeEthAddress;
declare const cairo_isTypeFelt: typeof isTypeFelt;
declare const cairo_isTypeLiteral: typeof isTypeLiteral;
declare const cairo_isTypeNamedTuple: typeof isTypeNamedTuple;
declare const cairo_isTypeOption: typeof isTypeOption;
declare const cairo_isTypeResult: typeof isTypeResult;
declare const cairo_isTypeSecp256k1Point: typeof isTypeSecp256k1Point;
declare const cairo_isTypeStruct: typeof isTypeStruct;
declare const cairo_isTypeTuple: typeof isTypeTuple;
declare const cairo_isTypeUint: typeof isTypeUint;
declare const cairo_isTypeUint256: typeof isTypeUint256;
declare const cairo_tuple: typeof tuple;
declare const cairo_uint256: typeof uint256;
declare const cairo_uint512: typeof uint512;
declare namespace cairo {
  export { cairo_felt as felt, cairo_getAbiContractVersion as getAbiContractVersion, cairo_getArrayType as getArrayType, cairo_isCairo1Abi as isCairo1Abi, cairo_isCairo1Type as isCairo1Type, cairo_isLen as isLen, cairo_isTypeArray as isTypeArray, cairo_isTypeBool as isTypeBool, cairo_isTypeByteArray as isTypeByteArray, cairo_isTypeBytes31 as isTypeBytes31, cairo_isTypeContractAddress as isTypeContractAddress, cairo_isTypeEnum as isTypeEnum, cairo_isTypeEthAddress as isTypeEthAddress, cairo_isTypeFelt as isTypeFelt, cairo_isTypeLiteral as isTypeLiteral, cairo_isTypeNamedTuple as isTypeNamedTuple, cairo_isTypeOption as isTypeOption, cairo_isTypeResult as isTypeResult, cairo_isTypeSecp256k1Point as isTypeSecp256k1Point, cairo_isTypeStruct as isTypeStruct, cairo_isTypeTuple as isTypeTuple, cairo_isTypeUint as isTypeUint, cairo_isTypeUint256 as isTypeUint256, cairo_tuple as tuple, cairo_uint256 as uint256, cairo_uint512 as uint512 };
}

/**
 * convert a Cairo ByteArray to a JS string
 * @param myByteArray Cairo representation of a LongString
 * @returns a JS string
 * @example
 * ```typescript
 * const myByteArray = {
 *    data: [],
 *    pending_word: '0x414243444546474849',
 *    pending_word_len: 9
 * }
 * const result: String = stringFromByteArray(myByteArray); // ABCDEFGHI
 * ```
 */
declare function stringFromByteArray(myByteArray: ByteArray): string;
/**
 * convert a JS string to a Cairo ByteArray
 * @param myString a JS string
 * @returns Cairo representation of a LongString
 * @example
 * ```typescript
 * const myByteArray: ByteArray = byteArrayFromString("ABCDEFGHI");
 * ```
 * Result is :
 * {
 *    data: [],
 *    pending_word: '0x414243444546474849',
 *    pending_word_len: 9
 * }
 */
declare function byteArrayFromString(targetString: string): ByteArray;

declare const byteArray_byteArrayFromString: typeof byteArrayFromString;
declare const byteArray_stringFromByteArray: typeof stringFromByteArray;
declare namespace byteArray {
  export { byteArray_byteArrayFromString as byteArrayFromString, byteArray_stringFromByteArray as stringFromByteArray };
}

declare class CallData {
    abi: Abi;
    parser: AbiParserInterface;
    protected readonly structs: AbiStructs;
    protected readonly enums: AbiEnums;
    constructor(abi: Abi);
    /**
     * Validate arguments passed to the method as corresponding to the ones in the abi
     * @param type ValidateType - type of the method
     * @param method string - name of the method
     * @param args ArgsOrCalldata - arguments that are passed to the method
     */
    validate(type: ValidateType, method: string, args?: ArgsOrCalldata): void;
    /**
     * Compile contract callData with abi
     * Parse the calldata by using input fields from the abi for that method
     * @param method string - method name
     * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).
     * @return Calldata - parsed arguments in format that contract is expecting
     * @example
     * ```typescript
     * const calldata = myCallData.compile("constructor", ["0x34a", [1, 3n]]);
     * ```
     * ```typescript
     * const calldata2 = myCallData.compile("constructor", {list:[1, 3n], balance:"0x34"}); // wrong order is valid
     * ```
     */
    compile(method: string, argsCalldata: RawArgs): Calldata;
    /**
     * Compile contract callData without abi
     * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data
     * @returns Calldata
     */
    static compile(rawArgs: RawArgs): Calldata;
    /**
     * Parse elements of the response array and structuring them into response object
     * @param method string - method name
     * @param response string[] - response from the method
     * @return Result - parsed response corresponding to the abi
     */
    parse(method: string, response: string[]): Result;
    /**
     * Format cairo method response data to native js values based on provided format schema
     * @param method string - cairo method name
     * @param response string[] - cairo method response
     * @param format object - formatter object schema
     * @returns Result - parsed and formatted response object
     */
    format(method: string, response: string[], format: object): Result;
    /**
     * Helper to extract structs from abi
     * @param abi Abi
     * @returns AbiStructs - structs from abi
     */
    static getAbiStruct(abi: Abi): AbiStructs;
    /**
     * Helper to extract enums from abi
     * @param abi Abi
     * @returns AbiEnums - enums from abi
     */
    static getAbiEnum(abi: Abi): AbiEnums;
    /**
     * Helper: Compile HexCalldata | RawCalldata | RawArgs
     * @param rawCalldata HexCalldata | RawCalldata | RawArgs
     * @returns Calldata
     */
    static toCalldata(rawCalldata?: RawArgs): Calldata;
    /**
     * Helper: Convert raw to HexCalldata
     * @param raw HexCalldata | RawCalldata | RawArgs
     * @returns HexCalldata
     */
    static toHex(raw?: RawArgs): HexCalldata;
    /**
     * Parse the elements of a contract response and structure them into one or several Result.
     * In Cairo 0, arrays are not supported.
     * @param typeCairo string or string[] - Cairo type name, ex : "hello::hello::UserData"
     * @param response string[] - serialized data corresponding to typeCairo.
     * @return Result or Result[] - parsed response corresponding to typeData.
     * @example
     * const res2=helloCallData.decodeParameters("hello::hello::UserData",["0x123456","0x1"]);
     * result = { address: 1193046n, is_claimed: true }
     */
    decodeParameters(typeCairo: AllowArray<string>, response: string[]): AllowArray<Result>;
}

declare function isSierra(contract: CairoContract | string): contract is SierraContractClass | CompiledSierra;
declare function extractContractHashes(payload: DeclareContractPayload): CompleteDeclareContractPayload;
/**
 * Helper to redeclare response Cairo0 contract
 */
declare function contractClassResponseToLegacyCompiledContract(ccr: ContractClassResponse): LegacyCompiledContract;

/**
 * Parse Transaction Receipt Event from UDC invoke transaction and
 * create DeployContractResponse compatible response with addition of the UDC Event data
 *
 * @returns DeployContractResponse | UDC Event Response data
 */
declare function parseUDCEvent(txReceipt: InvokeTransactionReceiptResponse): {
    transaction_hash: string;
    contract_address: string;
    address: string;
    deployer: string;
    unique: string;
    classHash: string;
    calldata_len: string;
    calldata: string[];
    salt: string;
};

/**
 * Request Permission for wallet account, return addresses that are allowed by user
 * @param silentMode false: request user interaction allowance. true: return only pre-allowed
 * @returns allowed accounts addresses
 */
declare function requestAccounts(swo: StarknetWindowObject, silentMode?: boolean): Promise<string[]>;
/**
 * Request Permission for wallet account
 * @returns allowed accounts addresses
 */
declare function getPermissions(swo: StarknetWindowObject): Promise<starknet_types.Permission[]>;
/**
 * Request adding ERC20 Token to Wallet List
 * @param asset WatchAssetParameters
 * @returns boolean
 */
declare function watchAsset(swo: StarknetWindowObject, asset: WatchAssetParameters): Promise<boolean>;
/**
 * Request adding custom Starknet chain
 * @param chain AddStarknetChainParameters
 * @returns boolean
 */
declare function addStarknetChain(swo: StarknetWindowObject, chain: AddStarknetChainParameters): Promise<boolean>;
/**
 * Request Wallet Network change
 * @param chainId StarknetChainId
 * @returns boolean
 */
declare function switchStarknetChain(swo: StarknetWindowObject, chainId: StarknetChainId$1): Promise<boolean>;
/**
 * Request the current chain ID from the wallet.
 * @returns The current Starknet chain ID.
 */
declare function requestChainId(swo: StarknetWindowObject): Promise<StarknetChainId$1>;
/**
 * Get deployment data for a contract.
 * @returns The deployment data result.
 */
declare function deploymentData(swo: StarknetWindowObject): Promise<starknet_types.GetDeploymentDataResult>;
/**
 * Add an invoke transaction to the wallet.
 * @param params The parameters required for the invoke transaction.
 * @returns The result of adding the invoke transaction.
 */
declare function addInvokeTransaction(swo: StarknetWindowObject, params: AddInvokeTransactionParameters): Promise<starknet_types.AddInvokeTransactionResult>;
/**
 * Add a declare transaction to the wallet.
 * @param params The parameters required for the declare transaction.
 * @returns The result of adding the declare transaction.
 */
declare function addDeclareTransaction(swo: StarknetWindowObject, params: AddDeclareTransactionParameters): Promise<starknet_types.AddDeclareTransactionResult>;
/**
 * Add a deploy account transaction to the wallet.
 * @param params The parameters required for the deploy account transaction.
 * @returns The result of adding the deploy account transaction.
 */
declare function addDeployAccountTransaction(swo: StarknetWindowObject, params: AddDeployAccountTransactionParameters): Promise<starknet_types.AddDeployAccountTransactionResult>;
/**
 * Sign typed data using the wallet.
 * @param params The typed data to sign.
 * @returns An array of signatures as strings.
 */
declare function signMessage(swo: StarknetWindowObject, typedData: TypedData): Promise<string[]>;
/**
 * Get the list of supported specifications.
 * @returns An array of supported specification strings.
 */
declare function supportedSpecs(swo: StarknetWindowObject): Promise<string[]>;
declare function onAccountChange(swo: StarknetWindowObject, callback: AccountChangeEventHandler): void;
declare function onNetworkChanged(swo: StarknetWindowObject, callback: NetworkChangeEventHandler): void;

declare const connect_addDeclareTransaction: typeof addDeclareTransaction;
declare const connect_addDeployAccountTransaction: typeof addDeployAccountTransaction;
declare const connect_addInvokeTransaction: typeof addInvokeTransaction;
declare const connect_addStarknetChain: typeof addStarknetChain;
declare const connect_deploymentData: typeof deploymentData;
declare const connect_getPermissions: typeof getPermissions;
declare const connect_onAccountChange: typeof onAccountChange;
declare const connect_onNetworkChanged: typeof onNetworkChanged;
declare const connect_requestAccounts: typeof requestAccounts;
declare const connect_requestChainId: typeof requestChainId;
declare const connect_signMessage: typeof signMessage;
declare const connect_supportedSpecs: typeof supportedSpecs;
declare const connect_switchStarknetChain: typeof switchStarknetChain;
declare const connect_watchAsset: typeof watchAsset;
declare namespace connect {
  export { connect_addDeclareTransaction as addDeclareTransaction, connect_addDeployAccountTransaction as addDeployAccountTransaction, connect_addInvokeTransaction as addInvokeTransaction, connect_addStarknetChain as addStarknetChain, connect_deploymentData as deploymentData, connect_getPermissions as getPermissions, connect_onAccountChange as onAccountChange, connect_onNetworkChanged as onNetworkChanged, connect_requestAccounts as requestAccounts, connect_requestChainId as requestChainId, connect_signMessage as signMessage, connect_supportedSpecs as supportedSpecs, connect_switchStarknetChain as switchStarknetChain, connect_watchAsset as watchAsset };
}

/**
 * Main
 */

/** @deprecated prefer the 'num' naming */
declare const number: typeof num;

export { type Abi, type AbiEntry, type AbiEnums, type AbiEvents, type AbiStructs, Account, AccountInterface, type AccountInvocationItem, type AccountInvocations, type AccountInvocationsFactoryDetails, type AllowArray, type Args, type ArgsOrCalldata, type ArgsOrCalldataWithOptions, type ArraySignatureType, type AsyncContractFunction, type BigNumberish, type Block$1 as Block, type BlockIdentifier, type BlockNumber, BlockStatus, BlockTag, type BlockWithTxHashes, type Builtins, type ByteArray, type ByteCode, type Cairo1Event, type CairoAssembly, type CairoContract, CairoCustomEnum, type CairoEnum, type CairoEnumRaw, CairoOption, CairoOptionVariant, CairoResult, CairoResultVariant, CairoUint256, CairoUint512, type CairoVersion, type Call, type CallContractResponse, CallData, type CallDetails, type CallOptions, type CallStruct, type Calldata, type CompiledContract, type CompiledSierra, type CompiledSierraCasm, type CompilerVersion, type CompleteDeclareContractPayload, type CompressedProgram, Contract, type ContractClass, type ContractClassPayload, type ContractClassResponse, type ContractEntryPointFields, ContractFactory, type ContractFactoryParams, type ContractFunction, ContractInterface, type ContractOptions, type ContractVersion, CustomError, type DeclareAndDeployContractPayload, type DeclareContractPayload, type DeclareContractResponse, type DeclareContractTransaction, type DeclareDeployUDCResponse, type DeclareSignerDetails, type DeclareTransactionReceiptResponse, type DeployAccountContractPayload, type DeployAccountContractTransaction, type DeployAccountSignerDetails, type DeployAccountTransactionReceiptResponse, type DeployContractResponse, type DeployContractUDCResponse, type DeployTransactionReceiptResponse, type Details, EntryPointType, type EntryPointsByType, type EnumAbi, type EstimateFee, type EstimateFeeAction, type EstimateFeeBulk, type EstimateFeeDetails, type EstimateFeeResponse, type EstimateFeeResponseBulk, EthSigner, type EventAbi, type EventEntry, type FeeEstimate, type FunctionAbi, GatewayError, type GetBlockResponse, type GetTransactionReceiptResponse, type GetTransactionResponse, type GetTxReceiptResponseWithoutHelper, type HexCalldata, HttpError, type Invocation, type Invocations, type InvocationsDetails, type InvocationsDetailsWithNonce, type InvocationsSignerDetails, type InvokeFunctionResponse, type InvokeOptions, type InvokeTransactionReceiptResponse, type L1HandlerTransactionReceiptResponse, type LegacyCompiledContract, type LegacyContractClass, type LegacyEvent, LibraryError, Literal, type MessageToL1, type MultiDeployContractResponse, type MultiType, type Nonce, type OptionalPayload, type ParsedEvent, type ParsedEvents, type ParsedStruct, type PendingBlock, type PendingStateUpdate, type Program, RpcProvider as Provider, ProviderInterface, type ProviderOptions, type PythonicHints, index$3 as RPC, rpc_0_6 as RPC06, rpc_0_7 as RPC07, type RawArgs, type RawArgsArray, type RawArgsObject, type RawCalldata, ReceiptTx, type RejectedTransactionReceiptResponse, type Result, type RevertedTransactionReceiptResponse, RpcChannel, RpcProvider, type RpcProviderOptions, SIMULATION_FLAG, type SierraContractClass, type SierraContractEntryPointFields, type SierraEntryPointsByType, type SierraProgramDebugInfo, type Signature, Signer, SignerInterface, type SimulateTransactionDetails, type SimulateTransactionResponse, type SimulatedTransaction, type SimulationFlags, type StarkProfile, type StateUpdate, type StateUpdateResponse, type Storage, type StructAbi, type SuccessfulTransactionReceiptResponse, TransactionExecutionStatus, TransactionFinalityStatus, type TransactionReceipt, type TransactionReceiptCallbacks, type TransactionReceiptCallbacksDefault, type TransactionReceiptCallbacksDefined, type TransactionReceiptStatus, type TransactionReceiptUtilityInterface, type TransactionReceiptValue, TransactionStatus, type TransactionStatusReceiptSets, TransactionType, type Tupled, type TypedContractV2, UINT_128_MAX, UINT_128_MIN, UINT_256_HIGH_MAX, UINT_256_HIGH_MIN, UINT_256_LOW_MAX, UINT_256_LOW_MIN, UINT_256_MAX, UINT_256_MIN, UINT_512_MAX, UINT_512_MIN, Uint, type Uint256, type Uint512, type UniversalDeployerContractPayload, type UniversalDetails, type V2DeclareSignerDetails, type V2DeployAccountSignerDetails, type V2InvocationsSignerDetails, type V3DeclareSignerDetails, type V3DeployAccountSignerDetails, type V3InvocationsSignerDetails, type V3TransactionDetails, ValidateType, WalletAccount, type WeierstrassSignatureType, addAddressPadding, buildUrl, byteArray, cairo, constants, contractClassResponseToLegacyCompiledContract, defaultProvider, ec, encode, eth, index as events, extractContractHashes, fixProto, fixStack, getCalldata, getChecksumAddress, type getContractVersionOptions, type getEstimateFeeBulkOptions, type getSimulateTransactionOptions, index$1 as hash, isSierra, isUrl, json, merkle, num, number, parseUDCEvent, provider, selector, shortString, splitArgsAndOptions, stark, starknetId, transaction, typedData, index$2 as types, uint256$1 as uint256, v2 as v2hash, v3 as v3hash, validateAndParseAddress, validateChecksumAddress, type waitForTransactionOptions, connect as wallet };
